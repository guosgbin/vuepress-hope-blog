<!doctype html>
<html lang="en-US" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.20" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.78" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme="dark"] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background: var(--vp-c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://blog.guosgbin.cn/test/HowToSayResume.html"><meta property="og:description" content="skill 编解码 Base 64 Base64 是一种常见的用于将二进制数据转换为文本字符串的编码方式，它由 64 个字符组成，通常包括 A-Z、a-z、0-9 和两个额外字符作为填充符号。Base64 编码经常用于在网络传输、存储或者处理不支持二进制数据的场景下（图片二进制流的每个字节不可能全部是可见字符），比如在电子邮件、XML 文件、URL 参..."><meta property="og:type" content="article"><meta property="og:locale" content="en-US"><meta property="og:updated_time" content="2025-04-21T15:01:57.000Z"><meta property="article:modified_time" content="2025-04-21T15:01:57.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"","image":[""],"dateModified":"2025-04-21T15:01:57.000Z","author":[{"@type":"Person","name":"超威蓝猫 Dylan Kwok","url":"","email":"guosgbin@163.com"}]}</script><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin=""><link href="https://fonts.googleapis.com/css2?family=LXGW+WenKai+Mono+TC" rel="stylesheet"><link href="https://fonts.googleapis.com/css2?family=LXGW+WenKai+TC" rel="stylesheet"><link rel="icon" href="/小熊猫.svg"><title></title><meta name="description" content="skill 编解码 Base 64 Base64 是一种常见的用于将二进制数据转换为文本字符串的编码方式，它由 64 个字符组成，通常包括 A-Z、a-z、0-9 和两个额外字符作为填充符号。Base64 编码经常用于在网络传输、存储或者处理不支持二进制数据的场景下（图片二进制流的每个字节不可能全部是可见字符），比如在电子邮件、XML 文件、URL 参...">
    <link rel="preload" href="/assets/style-DJJ2bZ_d.css" as="style"><link rel="stylesheet" href="/assets/style-DJJ2bZ_d.css">
    <link rel="modulepreload" href="/assets/app-B6zx7rvj.js"><link rel="modulepreload" href="/assets/HowToSayResume.html-nA29rAbb.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-DlAUqK2U.js">
    <link rel="prefetch" href="/assets/index.html-CnQcBmR8.js" as="script"><link rel="prefetch" href="/assets/01-创建和销毁对象.html-BnTacjmF.js" as="script"><link rel="prefetch" href="/assets/01-CAS和Unsafe的API分析.html-Dzfc7fh1.js" as="script"><link rel="prefetch" href="/assets/02-基本类型原子类AtomicLong.html-KWWHRS13.js" as="script"><link rel="prefetch" href="/assets/03-引用类型原子类AtomicReference.html-Nb0JyNlD.js" as="script"><link rel="prefetch" href="/assets/04-原子数组类AtomicLongArray.html-CfUM6P6b.js" as="script"><link rel="prefetch" href="/assets/05-原子操作类AtomicReferenceFieldUpdater.html-DddWr9MG.js" as="script"><link rel="prefetch" href="/assets/06-高性能原子类LongAdder.html-BGF7QtMP.js" as="script"><link rel="prefetch" href="/assets/07-LockSupport分析.html-DqtUTvMf.js" as="script"><link rel="prefetch" href="/assets/08-AQS简单介绍.html-ak4siiH_.js" as="script"><link rel="prefetch" href="/assets/09-基于ReentrantLock分析AQS的独占模式.html-D_dLwmun.js" as="script"><link rel="prefetch" href="/assets/10-基于CountDownLatch分析AQS的共享模式.html-k6D-6OfM.js" as="script"><link rel="prefetch" href="/assets/11-AQS的Condition机制.html-BvHawWC1.js" as="script"><link rel="prefetch" href="/assets/12-信号量Semaphore.html-_58Hlew-.js" as="script"><link rel="prefetch" href="/assets/13-循环栏栅CyclicBarrier.html-BAKVE9fO.js" as="script"><link rel="prefetch" href="/assets/14-阶段Phaser.html-BR7bEdwm.js" as="script"><link rel="prefetch" href="/assets/15-交换Exchanger.html-BEWd_cP8.js" as="script"><link rel="prefetch" href="/assets/16-读写锁ReentrantReadWriteLock.html-BSBK415d.js" as="script"><link rel="prefetch" href="/assets/17-Future模式-FutureTask.html-ASyZq3sI.js" as="script"><link rel="prefetch" href="/assets/18-线程池体系概述.html-GneWGaQ9.js" as="script"><link rel="prefetch" href="/assets/19-线程池体系-AbstractExecutorService.html-CqjM7D55.js" as="script"><link rel="prefetch" href="/assets/20-线程池体系-ThreadPoolExecutor.html-DqjpOBYK.js" as="script"><link rel="prefetch" href="/assets/21-线程池体系-ScheduledThreadPoolExecutor.html-D63o9M42.js" as="script"><link rel="prefetch" href="/assets/22-CopyOnWriteArrayList写时复制.html-DDfSXDNX.js" as="script"><link rel="prefetch" href="/assets/23-CopyOnWriteArraySet写时复制.html-Cgbwc7NW.js" as="script"><link rel="prefetch" href="/assets/24-ConcurrentSkipListMap跳表.html-BBlhLwLQ.js" as="script"><link rel="prefetch" href="/assets/25-ConcurrentSkipListSet跳表.html-Bk18GK5a.js" as="script"><link rel="prefetch" href="/assets/26-ConcurrentHashMap源码分析.html-CWHclIQd.js" as="script"><link rel="prefetch" href="/assets/27-阻塞队列ArrayBlockingQueue.html-Ci242ZTI.js" as="script"><link rel="prefetch" href="/assets/28-阻塞队列LinkedBlockingQueue.html-69smUzAb.js" as="script"><link rel="prefetch" href="/assets/29-阻塞队列LinkedBlockingDeque.html-B7XoBwrp.js" as="script"><link rel="prefetch" href="/assets/30-阻塞队列PriorityBlockingQueue.html-58wUtPbY.js" as="script"><link rel="prefetch" href="/assets/31-阻塞队列DelayQueue.html-BXXxPwzL.js" as="script"><link rel="prefetch" href="/assets/32-阻塞队列SynchronousQueue.html-CSQoVjzg.js" as="script"><link rel="prefetch" href="/assets/33-阻塞队列LinkedTransferQueue.html-vIvy1QoW.js" as="script"><link rel="prefetch" href="/assets/SPI机制.html-C_EWlvTw.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis01：myabtis的整体架构.html-CoAwn94X.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis02：入门案例.html-D7zqe3a2.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis03：解析全局配置文件.html-7CCNlDuE.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis04：解析Mapper映射文件.html-p1GxE43V.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis05：解析Statement操作节点.html-BVUX4aKS.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis06：解析SQL语句.html-tOXnEv9d.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis07：Java方法和SQL语句绑定.html-CPjokwx6.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis08：获得SqlSession.html-DTCS4tZE.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis09：Executor执行器.html-BHA0QQT0.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis10：缓存机制.html-BRbt3n8U.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis11：StatementHandler.html-D0x4jcT6.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis12：参数解析和赋值.html-BEChFj1O.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis13：结果集处理.html-BjKQ7mz4.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis14：插件.html-QsOouWfQ.js" as="script"><link rel="prefetch" href="/assets/01-服务端启动流程.html-lFlP1FxY.js" as="script"><link rel="prefetch" href="/assets/02-服务端启动添加ChannelInitializer到管道.html-nQ2g7JQo.js" as="script"><link rel="prefetch" href="/assets/03-客户端启动流程.html-UzYd3jDZ.js" as="script"><link rel="prefetch" href="/assets/04-线程体系-NioEventLoopGroup.html-CGGBCpX7.js" as="script"><link rel="prefetch" href="/assets/05-线程体系-NioEventLoop相关父接口分析.html-BxlAMLG6.js" as="script"><link rel="prefetch" href="/assets/06-线程体系-AbstractEventExecutor.html-BF07CBhh.js" as="script"><link rel="prefetch" href="/assets/07-线程体系-AbstractScheduledEventExecutor-优先队列.html-BnUvRB8S.js" as="script"><link rel="prefetch" href="/assets/08-线程体系-NioEventLoop概述.html-9gGMogMR.js" as="script"><link rel="prefetch" href="/assets/09-线程体系-NioEventLoop开启Selector及优化.html-ntKkuqtT.js" as="script"><link rel="prefetch" href="/assets/10-线程体系-NioEventLoop绑定线程.html-Dks9-jKH.js" as="script"><link rel="prefetch" href="/assets/11-线程体系-NioEventLoop的run方法.html-BTvbd0Nx.js" as="script"><link rel="prefetch" href="/assets/12-线程体系-NioEventLoop规避JDK的NIO空循环bug.html-5Brmsc-a.js" as="script"><link rel="prefetch" href="/assets/13-线程体系-NioEventLoop的优雅关闭.html-CQboUKzE.js" as="script"><link rel="prefetch" href="/assets/14-服务端处理客户端的连接(ACCEPT).html-DO4ila4q.js" as="script"><link rel="prefetch" href="/assets/15-客户端处理READ事件概述.html-kSjou7x0.js" as="script"><link rel="prefetch" href="/assets/16-客户端处理READ事件详解及RecvByteBufAllocator.html-jvgK1btM.js" as="script"><link rel="prefetch" href="/assets/17-Netty管道机制.html-BH7dXI5J.js" as="script"><link rel="prefetch" href="/assets/18-Netty发送数据流程及出站缓冲区.html-ChDpHkkW.js" as="script"><link rel="prefetch" href="/assets/Redis_Benchmark基准测试.html-Cp9t5l3b.js" as="script"><link rel="prefetch" href="/assets/Redis_Cluster集群和槽管理命令.html-1TcMvkUo.js" as="script"><link rel="prefetch" href="/assets/Redis_Cluster集群基本特性和集群搭建.html-BxzM6gTI.js" as="script"><link rel="prefetch" href="/assets/Redis_Cluster集群管理工具redis-cli.html-CjyZaZK6.js" as="script"><link rel="prefetch" href="/assets/Redis_Pipeline优化RTT.html-MnYgMh4b.js" as="script"><link rel="prefetch" href="/assets/Redis_Sentinel高可用.html-BPkHqYnq.js" as="script"><link rel="prefetch" href="/assets/Redis_key设计规范.html-B6fYBHXi.js" as="script"><link rel="prefetch" href="/assets/Redis事务.html-DCeurrmJ.js" as="script"><link rel="prefetch" href="/assets/Redis内存淘汰策略.html-ByRXr4Fe.js" as="script"><link rel="prefetch" href="/assets/Redis发布订阅.html-T5GP3pe7.js" as="script"><link rel="prefetch" href="/assets/Redis复制.html-BRV-CtGH.js" as="script"><link rel="prefetch" href="/assets/Redis大key和热key问题.html-lpYg2cgp.js" as="script"><link rel="prefetch" href="/assets/Redis慢查询日志.html-CY7gcxJO.js" as="script"><link rel="prefetch" href="/assets/Redis持久化机制.html-BGKTxbAN.js" as="script"><link rel="prefetch" href="/assets/Redis键空间通知(keyspace notification).html-NTw_u78M.js" as="script"><link rel="prefetch" href="/assets/redis-cli 使用.html-BZ3aiZV6.js" as="script"><link rel="prefetch" href="/assets/01-RocketMQ概述.html-BfcpzQV6.js" as="script"><link rel="prefetch" href="/assets/02-NameServer启动流程.html-Cpsdkudl.js" as="script"><link rel="prefetch" href="/assets/03-Broker启动流程.html-D1Y_OLDz.js" as="script"><link rel="prefetch" href="/assets/04-RocketMQ网络通信原理.html-ChQ7W5v7.js" as="script"><link rel="prefetch" href="/assets/05-RocketMQ 服务端和客户端的启动.html-CM8oVJFZ.js" as="script"><link rel="prefetch" href="/assets/06-RocketMQ网络通信源码.html-ClYPGkSE.js" as="script"><link rel="prefetch" href="/assets/07-NameServer作用和路由元信息.html-BxPtsO_v.js" as="script"><link rel="prefetch" href="/assets/08-NameServer路由管理源码分析.html-U7uqzxSd.js" as="script"><link rel="prefetch" href="/assets/09-生产者相关类分析.html-DV1Qq-IT.js" as="script"><link rel="prefetch" href="/assets/10-生产者启动流程.html-n9uhMvjQ.js" as="script"><link rel="prefetch" href="/assets/11-生产者发送消息.html-Dv8AILOP.js" as="script"><link rel="prefetch" href="/assets/12-Broker存储机制概述.html-CAzUOEh2.js" as="script"><link rel="prefetch" href="/assets/13-MappedFile和MappedFileQueue分析.html-CaNvNyDu.js" as="script"><link rel="prefetch" href="/assets/14-CommitLog原理分析.html-CbeuRufX.js" as="script"><link rel="prefetch" href="/assets/15-broker的刷盘机制.html-BcrvFwEL.js" as="script"><link rel="prefetch" href="/assets/16-ConsumeQueue和Index原理分析.html-CrLmhODH.js" as="script"><link rel="prefetch" href="/assets/17-broker过期文件删除机制.html-CT6AV5Do.js" as="script"><link rel="prefetch" href="/assets/18-消费者启动流程(TODO).html-DpNZdbDI.js" as="script"><link rel="prefetch" href="/assets/19-消息拉取入口和消息队列负载均衡.html-CWngHdw5.js" as="script"><link rel="prefetch" href="/assets/20-消费者发送消息拉取请求流程.html-D1QfHsik.js" as="script"><link rel="prefetch" href="/assets/21-broker处理消息拉取请求-1-主流程.html-BVxwhPY1.js" as="script"><link rel="prefetch" href="/assets/22-broker处理消息拉取请求-2-长轮询.html-BqYHHkvf.js" as="script"><link rel="prefetch" href="/assets/23-broker处理消息拉取请求-3-读取消息.html-DhFzOxol.js" as="script"><link rel="prefetch" href="/assets/24-消费者处理从broker拉取的消息.html-BTiX6IeN.js" as="script"><link rel="prefetch" href="/assets/25-并发消费原理.html-CStdOPII.js" as="script"><link rel="prefetch" href="/assets/001-服务器CPU问题-规律性峰刺.html-BVHw4GO6.js" as="script"><link rel="prefetch" href="/assets/002-服务器CPU配置降低GC分析.html-BvzWoGyb.js" as="script"><link rel="prefetch" href="/assets/003-服务器CPU使用率较低但系统负载高.html-BeHC8CO3.js" as="script"><link rel="prefetch" href="/assets/004-log4j2内存泄露导致的频繁fullgc.html-DoBj4BSp.js" as="script"><link rel="prefetch" href="/assets/005-线程池父子任务使用不当造成死锁.html-Ctxce3tv.js" as="script"><link rel="prefetch" href="/assets/006-linux系统参数-连接队列长度过小导致连接丢弃.html-BFTmHXfu.js" as="script"><link rel="prefetch" href="/assets/007-redis频繁淘汰-清除redis线上未设置过期时间的key.html-DERbZF8E.js" as="script"><link rel="prefetch" href="/assets/008-JVM堆外内存泄露排查.html-CDdKIsJD.js" as="script"><link rel="prefetch" href="/assets/IM如何保证消息不丢失.html-mgjjxGrO.js" as="script"><link rel="prefetch" href="/assets/经验-查询类接口超时优化技巧.html-B-tt4LKZ.js" as="script"><link rel="prefetch" href="/assets/项目-IM长连接优化.html-BSJHaxUc.js" as="script"><link rel="prefetch" href="/assets/项目-服务降级.html-B4RQfhxa.js" as="script"><link rel="prefetch" href="/assets/项目-直播间业务多级缓存优化.html-DvcSOuio.js" as="script"><link rel="prefetch" href="/assets/项目-线程池优化.html-sEbW30q5.js" as="script"><link rel="prefetch" href="/assets/JUC相关问题.html-itaTKXNw.js" as="script"><link rel="prefetch" href="/assets/JVM问题.html-DrppOPBY.js" as="script"><link rel="prefetch" href="/assets/MySQL相关问题.html-eB_CxYk_.js" as="script"><link rel="prefetch" href="/assets/Redis相关问题.html-PH2siMOH.js" as="script"><link rel="prefetch" href="/assets/RocketMQ相关问题.html-D8ueqMX6.js" as="script"><link rel="prefetch" href="/assets/二分查找.html-BKghAyPp.js" as="script"><link rel="prefetch" href="/assets/二叉树.html-DGYfBFVG.js" as="script"><link rel="prefetch" href="/assets/代码随想录题目目录.html-BSho0SC5.js" as="script"><link rel="prefetch" href="/assets/Linux命令.html-C3F36iwy.js" as="script"><link rel="prefetch" href="/assets/index.html-CppWVnFt.js" as="script"><link rel="prefetch" href="/assets/ThreadLocal源码分析.html-Cb_FWGII.js" as="script"><link rel="prefetch" href="/assets/resume.html-BCqW5ipw.js" as="script"><link rel="prefetch" href="/assets/项目-IM限流-公网流量降低.html-B9LENNKp.js" as="script"><link rel="prefetch" href="/assets/404.html-C3fHBPRL.js" as="script"><link rel="prefetch" href="/assets/index.html-WlpG6Mdo.js" as="script"><link rel="prefetch" href="/assets/index.html-By1pgaRh.js" as="script"><link rel="prefetch" href="/assets/index.html-DEZyUcCN.js" as="script"><link rel="prefetch" href="/assets/index.html-ERCe84Nc.js" as="script"><link rel="prefetch" href="/assets/index.html-7KpYW2cl.js" as="script"><link rel="prefetch" href="/assets/index.html-DMJnIzR7.js" as="script"><link rel="prefetch" href="/assets/index.html-mLdwYIW9.js" as="script"><link rel="prefetch" href="/assets/index.html-3bW-ToHx.js" as="script"><link rel="prefetch" href="/assets/index.html-Ds9ys55R.js" as="script"><link rel="prefetch" href="/assets/index.html-DsH-lpDt.js" as="script"><link rel="prefetch" href="/assets/mermaid.esm.min-Cnb6OeVw.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-DXWKOczD.js" as="script"><link rel="prefetch" href="/assets/giscus-BwIGYrs0.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">Skip to main content</a><!--]--><div class="theme-container external-link-icon has-toc" vp-container><!--[--><header id="navbar" class="vp-navbar" vp-navbar><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><a class="route-link vp-brand" href="/" aria-label="Take me home"><img class="vp-nav-logo" src="/小熊猫.svg" alt><!----><!----></a><!--]--></div><div class="vp-navbar-center"><!--[--><nav class="vp-nav-links"><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/" aria-label="超威蓝猫小站" iconsizing="height"><!---->超威蓝猫小站<!----></a></div></nav><!--]--></div><div class="vp-navbar-end"><!--[--><!----><div class="vp-nav-item vp-action"><a class="vp-action-link" href="https://github.com/guosgbin/vuepress-blog" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" name="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="vp-nav-item hide-in-mobile"><button type="button" class="vp-outlook-button" tabindex="-1" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon" name="outlook"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="vp-outlook-dropdown"><!----></div></button></div><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar" vp-sidebar><!----><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/" aria-label="超威蓝猫小站" iconsizing="both"><!---->超威蓝猫小站<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/contact.html" aria-label="/contact.html" iconsizing="both"><!---->/contact.html<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/about.html" aria-label="/about.html" iconsizing="both"><!---->/about.html<!----></a></li></ul><!----></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!----></h1><div class="page-info"><span class="page-author-info" aria-label="Author🖊" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon" name="author"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><span class="page-author-item">超威蓝猫 Dylan Kwok</span></span><span property="author" content="超威蓝猫 Dylan Kwok"></span></span><!----><span class="page-date-info" aria-label="Writing Date📅" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon" name="calendar"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span data-allow-mismatch="text">April 3, 2025</span><meta property="datePublished" content="2025-04-03T07:07:29.000Z"></span><!----><span class="page-reading-time-info" aria-label="Reading Time⌛" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon" name="timer"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>About 82 min</span><meta property="timeRequired" content="PT82M"></span><!----><!----></div><hr></div><!----><div class="" vp-content><!----><div id="markdown-content"><nav class="table-of-contents"><ul><li><a aria-current="page" href="/test/HowToSayResume.html#skill" class="router-link-active router-link-exact-active">skill</a><ul><li><a aria-current="page" href="/test/HowToSayResume.html#编解码" class="router-link-active router-link-exact-active">编解码</a></li><li><a aria-current="page" href="/test/HowToSayResume.html#netty-相关-网络相关" class="router-link-active router-link-exact-active">Netty 相关，网络相关</a></li><li><a aria-current="page" href="/test/HowToSayResume.html#spring-循环依赖问题" class="router-link-active router-link-exact-active">Spring 循环依赖问题</a></li><li><a aria-current="page" href="/test/HowToSayResume.html#分布式事务本地消息表" class="router-link-active router-link-exact-active">分布式事务本地消息表</a></li><li><a aria-current="page" href="/test/HowToSayResume.html#spi-机制-以及其在-motan-中怎么用的" class="router-link-active router-link-exact-active">SPI 机制，以及其在 Motan 中怎么用的</a></li></ul></li><li><a aria-current="page" href="/test/HowToSayResume.html#introduce" class="router-link-active router-link-exact-active">introduce</a></li><li><a aria-current="page" href="/test/HowToSayResume.html#哈啰工作内容" class="router-link-active router-link-exact-active">哈啰工作内容</a><ul><li><a aria-current="page" href="/test/HowToSayResume.html#iot-架构" class="router-link-active router-link-exact-active">IoT 架构</a></li><li><a aria-current="page" href="/test/HowToSayResume.html#what-did-i-do" class="router-link-active router-link-exact-active">what did i do</a></li><li><a aria-current="page" href="/test/HowToSayResume.html#项目介绍" class="router-link-active router-link-exact-active">项目介绍</a></li></ul></li><li><a aria-current="page" href="/test/HowToSayResume.html#克拉工作内容" class="router-link-active router-link-exact-active">克拉工作内容</a><ul><li><a aria-current="page" href="/test/HowToSayResume.html#architecture" class="router-link-active router-link-exact-active">architecture</a></li><li><a aria-current="page" href="/test/HowToSayResume.html#what-did-i-do-1" class="router-link-active router-link-exact-active">what did I do</a></li></ul></li><li><a aria-current="page" href="/test/HowToSayResume.html#project-introduce" class="router-link-active router-link-exact-active">project introduce</a><ul><li><a aria-current="page" href="/test/HowToSayResume.html#im-系统设计" class="router-link-active router-link-exact-active">IM 系统设计</a></li><li><a aria-current="page" href="/test/HowToSayResume.html#im-系统设计-2" class="router-link-active router-link-exact-active">IM 系统设计 2</a></li><li><a aria-current="page" href="/test/HowToSayResume.html#im-过滤器链-异常处理-url-映射" class="router-link-active router-link-exact-active">IM 过滤器链，异常处理，url 映射</a></li><li><a aria-current="page" href="/test/HowToSayResume.html#直播间多级缓存优化" class="router-link-active router-link-exact-active">直播间多级缓存优化</a></li><li><a aria-current="page" href="/test/HowToSayResume.html#国际版迁移" class="router-link-active router-link-exact-active">国际版迁移</a></li><li><a aria-current="page" href="/test/HowToSayResume.html#慢查询优化" class="router-link-active router-link-exact-active">慢查询优化</a></li><li><a aria-current="page" href="/test/HowToSayResume.html#内存泄漏" class="router-link-active router-link-exact-active">内存泄漏</a></li><li><a aria-current="page" href="/test/HowToSayResume.html#cpu-峰刺问题" class="router-link-active router-link-exact-active">CPU 峰刺问题</a></li></ul></li><li><a aria-current="page" href="/test/HowToSayResume.html#project-qps" class="router-link-active router-link-exact-active">project QPS</a></li><li><a aria-current="page" href="/test/HowToSayResume.html#im-down-stream-data" class="router-link-active router-link-exact-active">IM down stream data</a></li><li><a aria-current="page" href="/test/HowToSayResume.html#jvm-data" class="router-link-active router-link-exact-active">JVM data</a></li><li><a aria-current="page" href="/test/HowToSayResume.html#interview-question" class="router-link-active router-link-exact-active">interview question</a><ul><li><a aria-current="page" href="/test/HowToSayResume.html#didichuxing-1-打车业务" class="router-link-active router-link-exact-active">didichuxing 1 打车业务</a></li><li><a aria-current="page" href="/test/HowToSayResume.html#didichuxing-2-打车业务" class="router-link-active router-link-exact-active">didichuxing 2 打车业务</a></li><li><a aria-current="page" href="/test/HowToSayResume.html#xiaohongshu-1-im-方向" class="router-link-active router-link-exact-active">xiaohongshu 1 IM 方向</a></li><li><a aria-current="page" href="/test/HowToSayResume.html#ali-sumaitong-1-这个人妥妥的傻呗" class="router-link-active router-link-exact-active">Ali sumaitong 1 这个人妥妥的傻呗</a></li><li><a aria-current="page" href="/test/HowToSayResume.html#ali-飞猪度假" class="router-link-active router-link-exact-active">Ali 飞猪度假</a></li><li><a aria-current="page" href="/test/HowToSayResume.html#ali-飞猪-im" class="router-link-active router-link-exact-active">Ali 飞猪 IM</a></li><li><a aria-current="page" href="/test/HowToSayResume.html#ali-飞猪度假-1" class="router-link-active router-link-exact-active">Ali 飞猪度假</a></li><li><a aria-current="page" href="/test/HowToSayResume.html#meituan直播" class="router-link-active router-link-exact-active">meituan直播</a></li><li><a aria-current="page" href="/test/HowToSayResume.html#didi-beijing-打车" class="router-link-active router-link-exact-active">didi beijing 打车</a></li><li><a aria-current="page" href="/test/HowToSayResume.html#保险" class="router-link-active router-link-exact-active">保险</a></li><li><a aria-current="page" href="/test/HowToSayResume.html#alipay-直播" class="router-link-active router-link-exact-active">alipay 直播</a></li><li><a aria-current="page" href="/test/HowToSayResume.html#hello-iot" class="router-link-active router-link-exact-active">hello iot</a></li><li><a aria-current="page" href="/test/HowToSayResume.html#zijie-直播广告" class="router-link-active router-link-exact-active">zijie 直播广告</a></li></ul></li></ul></nav><h2 id="skill" tabindex="-1"><a class="header-anchor" href="#skill"><span>skill</span></a></h2><h3 id="编解码" tabindex="-1"><a class="header-anchor" href="#编解码"><span>编解码</span></a></h3><h4 id="base-64" tabindex="-1"><a class="header-anchor" href="#base-64"><span><strong>Base 64</strong></span></a></h4><p>Base64 是一种常见的用于将二进制数据转换为文本字符串的编码方式，它由 64 个字符组成，通常包括 A-Z、a-z、0-9 和两个额外字符作为填充符号。Base64 编码经常用于在网络传输、存储或者处理不支持二进制数据的场景下（图片二进制流的每个字节不可能全部是可见字符），比如在电子邮件、XML 文件、URL 参数等地方。</p><p><strong>基于64个可打印字符来表示二进制数据的办法。</strong></p><p>Base64 的码表只有 64 个字符， 如果要表达 64 个字符的话，使用 6 的 bit 即可完全表示( 2 的 6 次方为 64)。因为 Base64 的编码只有 6 个 bit 即可表示，而正常的字符是使用 8 个 bit 表示， 8 和 6 的最小公倍数是 24，所以 4 个 Base64 字符可以表示 3 个标准的 ascll 字符。</p><p>将字符串转换为 base64 时，会先把字符串转换为对应的 ascII 码，然后从左往右 6 位截取（6 位对应一位 base64 码），若最后不足 6 位（一个 base64 码）补 0，不足 3 个字符串则补 =（解码时会自动去掉）</p><figure><img src="/assets/v2-159dbcb23a8129ee40c0c17c59c383f9_720w-CRYKIHK0.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>由于 = 字符也可能出现在 Base64 编码中，但 = 用在 URL、Cookie 里面会造成歧义，所以，很多 Base64 编码后会把 = 去掉。因为 base64 码的位数永远是 4 的倍数，所以解码时若位数不足可以在末尾补 =。</p><p>Base64 编码的优点在于其结果是纯文本，易于处理和传输，而且不会受到大部分文本编码的限制。然而，需要注意的是Base64 编码会使数据稍微膨胀，因为每 3 个字节的数据会编码成 4 个字符，所以编码后的数据会比原始数据略大。</p><p>将图片转换成 Base64 的编码方式是因为可以将图片直接嵌入到网页中，而不是从外部载入，这样就减少了 HTTP 请求。</p><p>总之，Base64 编码是一种常见的数据编码方式，适用于多种场景下的<strong>二进制数据处理和传输，但需要注意编码后数据会膨胀</strong>，适用场景需要谨慎选择。</p><h4 id="base62" tabindex="-1"><a class="header-anchor" href="#base62"><span><strong>base62</strong></span></a></h4><p>其实就是 26 个小写字母 + 26 个大写字母 + 10 个数字 = 62，然后对一个数做 62 进制与十进制的映射。这种编码方式常用于生成短链接、加密传输等场景。</p><p><strong>短链的设计</strong>：主要思路，维护一个全局自增的 id，每来一个长 url，将其与一个自增 id 绑定，然后利用 base62 将该自增 id 转换为 base62 字符串，即完成转换。</p><p><strong>我们 IM 项目用这个 base62 主要是用来做认证的 token 的设计</strong>，比如 uid + appId + clientId 等..，每一个做 base62 的转换</p><h3 id="netty-相关-网络相关" tabindex="-1"><a class="header-anchor" href="#netty-相关-网络相关"><span>Netty 相关，网络相关</span></a></h3><h4 id="tcp-三次握手" tabindex="-1"><a class="header-anchor" href="#tcp-三次握手"><span>TCP 三次握手</span></a></h4><blockquote><p><a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/qzcsu/article/details/72861891</a> 看这个</p></blockquote><p>TCP（Transmission Control Protocol）是一种常用的传输层协议，用于在网络中可靠地传输数据。在建立和终止TCP连接时，使用了三次握手和四次挥手的过程。</p><figure><img src="/assets/format_png-DMtW0g6q.png" alt="format,png" tabindex="0" loading="lazy"><figcaption>format,png</figcaption></figure><blockquote><p><strong>最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器。</strong></p></blockquote><ol><li><strong>第一次握手（SYN）</strong>：客户端向服务器发送一个带有 SYN 标志的数据包，表示客户端请求连接；</li><li><strong>第二次握手（SYN-ACK）</strong>：服务器收到客户端的 SYN 请求后，会把客户端的请求存到半连接队列中去（SYN 队列），然后返回一个带有 SYN+ACK 的数据包，表示确认收到客户端的请求，并向客户端发出自己的连接请求；</li><li><strong>第三次握手（ACK）</strong>：客户端收到服务器的连接确认后，会再次向服务器发送一个带有 ACK 标志的数据包，表示客户端也确认连接。这时服务器会将这个请求添加到全连接队列中去，等待服务调用 accept() 方法。</li></ol><p>下面的是详细的，面试可不说这个，太长了：</p><ol><li>TCP 服务器进程先创建传输控制块 TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了 LISTEN（监听）状态；</li><li>TCP 客户进程也是先创建传输控制块 TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位 SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号；表示请求建立连接；</li><li>TCP 服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP 服务器进程进入了 SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号；</li><li>TCP 客户进程收到确认后，还要向服务器给出确认，。确认报文的 ACK=1，ack=y+1，自己的序列号 seq=x+1，此时，TCP 连接建立，客户端进入 ESTABLISHED（已建立连接）状态。TCP 规定，ACK 报文段可以携带数据，但是如果不携带数据则不消耗序号；</li><li>当服务器收到客户端的确认后也进入 ESTABLISHED 状态，此后双方就可以开始通信了；</li></ol><blockquote><p>为什么TCP客户端最后还要发送一次确认呢？</p><p>一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</p><p>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，客户端迟迟没有收到服务器的确认报文，就会认为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时之前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p><p>如果采用的是三次握手，就算是第一次失效的报文传送到服务器了，服务器接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接，也就不会去建立连接了。</p></blockquote><h4 id="tcp-四次挥手" tabindex="-1"><a class="header-anchor" href="#tcp-四次挥手"><span>TCP 四次挥手</span></a></h4><blockquote><p>数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于 ESTABLISHED 状态，然后客户端主动关闭，服务器被动关闭。</p></blockquote><p>四次挥手（Four-Way Handshake）是在客户端和服务器之间终止TCP连接时使用的过程。它的步骤如下：</p><figure><img src="/assets/format_png-20230724213231333-w6EsKsdW.png" alt="四次挥手" tabindex="0" loading="lazy"><figcaption>四次挥手</figcaption></figure><ol><li>第一次挥手（FIN）：客户端想要关闭连接时，会发送一个带有 FIN 标识的数据包给服务器，客户端不再发送数据，但仍然可以接收数据；</li><li>第二次挥手（ACK）：服务器接收到 FIN 报文后，会给客户端返回一个 ACK 的确认报文，告知客户端已经收到关闭请求，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受；</li><li>第三次挥手（FIN）：服务器将最后的数据发送完毕后，就会给客户端发送一个 FIN 数据包；</li><li>第四次挥手（ACK）：客户端收到服务器的连接释放的 FIN 报文后，会给服务器发送一个 ACK 报文。此时，客户端就进入了 TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2 × MSL（最长报文段寿命）的时间后，才进入 CLOSED 状态；</li></ol><p>下面的是详细的，面试可不说这个，太长了：</p><ol><li>第一步（FIN）：当客户端想要关闭连接时，发送一个带有 FIN（结束）标志的 TCP 报文段给服务器。客户端不再发送数据，但仍然可以接收数据。报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态；</li><li>第二步（ACK）：服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li><li>第三步：客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li><li>第四步：服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li><li>第五步（ACK）：客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2 × MSL（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入CLOSED状态。</li><li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li></ol><br><blockquote><p><strong>为什么客户端最后还要等待 2MSL？</strong></p><p>MSL（Maximum Segment Lifetime），TCP 允许不同的实现可以设置不同的 MSL 值。表示报文在网络中存活的最长时间，通常为 2 分钟。</p><p>第一，保证客户端发送的最后一个 ACK 报文能够到达服务器，因为这个 ACK 报文可能丢失，站在服务器的角度看来，我已经发送了 FIN+ACK 报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个 2MSL 时间段内收到这个重传的报文，接着给出回应报文，并且会重启 2MSL 计时器。</p><p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个 2MSL 时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p><p>因此，等待 2MSL 时间是为了保证连接的可靠关闭和防止出现连接混乱的情况。</p></blockquote><br><blockquote><p><strong>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</strong></p><p>建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。<br> 而关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以服务器可以立即关闭，也可以发送一些数据给客户端后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，服务器的 ACK 和 FIN 一般都会分开发送，从而导致多了一次。</p><p>半关闭状态的存在使得两个方向上的数据传输可以分别控制，允许一方先关闭发送数据的能力，而另一方仍然可以接收数据。这样可以有效地进行双向通信的结束和连接的关闭。</p></blockquote><br><blockquote><p><strong>如果已经建立了连接，但是客户端突然出现故障了怎么办？</strong></p><p>TCP keep-alive</p><p>TCP 还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为 2 小时，若 2 小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔 75 秒发送一次。若一连发送 9 个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。（总耗时：7200 秒 + 75 秒* 9 次 = 2 小时 11 分钟 ）</p><p>TCP协议提供了保活机制，服务器端可以启用选项来监测连接的存活状态。当服务器端启用了保活机制，并在一定时间内没有收到客户端的响应时，会发送保活探测报文给客户端。如果一定次数内仍未收到客户端的响应，则会判断客户端已经出现故障，并关闭连接。</p><p>Linux 系统下， TCP keep-alive 参数如下：</p><ul><li><code>net.ipv4.tcp_keepalive_time</code>：探测开始之前的空闲时间（我的线上服务器 1800s，也就是 30min）</li><li><code>net.ipv4.tcp_keepalive_intvl</code>：两次探测之间的时间间隔（我的线上服务器 75s）</li><li><code>net.ipv4.tcp_keepalive_probes</code>：探测重试次数（我的线上服务器 9 次）</li></ul><p>查看具体数值：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>$ cat /proc/sys/net/ipv4/tcp_keepalive_time</span></span>
<span class="line"><span>1800</span></span>
<span class="line"><span>$ cat /proc/sys/net/ipv4/tcp_keepalive_intvl</span></span>
<span class="line"><span>75</span></span>
<span class="line"><span>$ cat /proc/sys/net/ipv4/tcp_keepalive_probes</span></span>
<span class="line"><span>9</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>为什么还需要应用层 keepalive ?</strong></p><ul><li>协议分层，各层关注点不同：<br> 传输层关注是否“通”，应用层关注是否可服务？ 服务器连接在，但是不定可以服务（例如服务不过来等）。</li><li>TCP 层的 keepalive 默认关闭，且经过路由等中转设备 keepalive 包可能会被丢弃。</li><li>TCP 层的 keepalive 时间太长：默认 &gt; 2 小时，虽然可改，但属于系统参数，改动影响所有应用。</li></ul></blockquote><h4 id="什么是黏包和半包" tabindex="-1"><a class="header-anchor" href="#什么是黏包和半包"><span>什么是黏包和半包？</span></a></h4><p>概念：</p><ul><li><strong>黏包：一次性接收多条消息；</strong></li><li><strong>半包：分好几次接收不完整的消息；</strong></li></ul><p>产生原因：</p><ul><li>**产生黏包主要是因为每次写入的数据比较少，比如远远小于套接字缓冲区的大小。**此时，网卡往往不会立马发送，而是将数据合并后一起发送，这样效率也会高一些。但是，对方接收到的可能就是黏包。另外，如果接收方读取数据不够及时，也会产生黏包现象；</li><li><strong>产生半包的原因</strong>：<strong>比如当发送方发送的数据大于套接字缓冲区的大小时，数据在底层必然会分成多次发送</strong>，因此接收方收到的可能就是半包。另外一个非常重要的因素就是最大传输单元，数据是按 TCP/IP 逐渐封装后传输的。应用层数据在作为数据部分传递给数据链路层之前，需要加上传输层的头，才能逐层封装传递。既然要封装，就必然涉及数据内容的大小控制，否则就不存在封装的概念了。各层协议中报文内容的大小就由最大传输单元控制。当发送的数据大于协议各层的最大传输单元时，就必须拆包；</li></ul><p><strong>Netty 是如何处理黏包的？</strong></p><ul><li>使用的是 LengthFieldBasedFrameDecoder 解码器；</li><li>原理：在数据包中添加一个固定长度的长度字段，用来表示整个数据包的长度。<code>LengthFieldBasedFrameDecoder</code> 首先根据配置的偏移量、长度字段的长度等参数，从接收到的数据中读取长度字段的值。从而可以准确地分割出完整的数据包。</li></ul><p><strong>Netty 是如何处理黏包的？</strong></p><ul><li>使用的是 LengthFieldBasedFrameDecoder 解码器；</li><li>在接收数据时，可以维护一个缓冲区，等待接收到足够的数据以组成一个完整的数据包再进行处理。如果接收到的数据不足以构成完整的数据包，就继续等待后续数据的到达；</li></ul><h4 id="各个-io-模式" tabindex="-1"><a class="header-anchor" href="#各个-io-模式"><span>各个 IO 模式</span></a></h4><ul><li><strong>BIO：阻塞同步</strong>，程序会阻塞一直等待数据，直到数据就绪；</li><li><strong>NIO：非阻塞同步</strong>，程序可以立即返回，无需等待数据就绪，数据就绪后系统会通知我们去处理；</li><li><strong>AIO：非阻塞异步</strong>，系统会把数据读好返回并回调给我们；</li></ul><blockquote><p>I/O 复用是一种 I/O 模式，通过这种模式可以同时监听多个 I/O 事件，从而有效地管理多个 I/O 操作。在实际应用中，常见的 I/O 复用技术包括 select、poll 和 epoll。</p><ol><li><strong>select</strong>：<code>select</code> 是 POSIX 标准定义的一种 I/O 复用机制，它允许程序监视一组文件描述符，当其中任何一个文件描述符就绪时，<code>select</code> 将通知程序可以执行 I/O 操作。<code>select</code> 的缺点是效率较低，受到文件描述符数量的限制。</li><li><strong>poll</strong>：<code>poll</code> 与 <code>select</code> 类似，也是一种基于事件驱动的 I/O 复用方式，不同之处在于 <code>poll</code> 不受文件描述符数量的限制。但是在大量文件描述符的情况下，<code>poll</code> 的性能也可能变得较低。</li><li><strong>epoll</strong>：<code>epoll</code> 是 Linux 特有的一种 I/O 复用机制，可以对大量的文件描述符进行高效的 I/O 复用。<code>epoll</code> 使用了事件通知的机制，当文件描述符就绪时，内核会通知应用程序进行处理。相比于 <code>select</code> 和 <code>poll</code>，<code>epoll</code> 在大规模并发连接的情况下性能更好。</li></ol><p>I/O 复用的优势在于可以同时管理多个 I/O 事件，避免了传统阻塞模式下需要为每个连接创建一个线程或进程的开销，从而提高了系统资源利用率和性能。因此，在高并发的网络编程场景下，常常会选择使用 I/O 复用来实现高效的事件驱动的网络通信。</p></blockquote><h4 id="nio-的-3-种-reactor-模式" tabindex="-1"><a class="header-anchor" href="#nio-的-3-种-reactor-模式"><span>NIO 的 3 种 Reactor 模式</span></a></h4><p>① <strong>Reactor 单线程模式</strong>，<strong>接收连接、处理读写操作、注册事件、扫描事件等所有操作都由一个线程来完成</strong>。显而易见，这个线程的压力很大，很容易称为系统瓶颈。</p><figure><img src="/assets/image-20230721210304692-9944586-BSaK6HgZ.png" alt="image-20230721210304692" tabindex="0" loading="lazy"><figcaption>image-20230721210304692</figcaption></figure><p>② <strong>Reactor 多线程模式</strong>，主 Reactor 负责监听事件，当有事件发生时，通过线程池将事件分发给工作线程进行处理。</p><p>它弥补了 Reactor 单线程模式中的缺陷，解码、处理、编码等比较复杂且耗时较长的操作将由线程池来做。</p><figure><img src="/assets/image-20230721210829367-9944910-B8QiV9N8.png" alt="image-20230721210829367" tabindex="0" loading="lazy"><figcaption>image-20230721210829367</figcaption></figure><p>③ <strong>Reactor 主从多线程</strong>，包含一个主 Reactor 和从 Reactor。主 Reactor 负责监听连接事件，从 Reactor 负责处理读写事件。主 Reactor 接受新连接后，将其分配给从 Reactor 处理，可以有效减轻主 Reactor 的负担，提高并发处理能力。</p><figure><img src="/assets/image-20230721210842645-9944923-BGBFxnib.png" alt="image-20230721210842645" tabindex="0" loading="lazy"><figcaption>image-20230721210842645</figcaption></figure><h4 id="netty-的参数调整" tabindex="-1"><a class="header-anchor" href="#netty-的参数调整"><span>Netty 的参数调整</span></a></h4><ul><li><p>系统参数，有几个比较重要</p><ul><li>程序最多可以打开的文件数目。因为对于服务器网络应用来说，每个连接的建立都需要打开一个 「文件」。具体而言，<strong>在建立 TCP 连接时，系统将为每个 TCP 连接创建一个 Socket 句柄，也就是文件句柄</strong>。但是 Linux 系统对每个进程能够打开的文件句柄数量做了限制，如果超出限制就会报错，默认是 1024。通过 <strong>ulimit -n [xxx]</strong> 命令增大允许的文件句柄数目。可以考虑将 ulimit 命令作为启动脚本的一部分；</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[im_user@bjvpc22-202 ~]$ ulimit -a</span></span>
<span class="line"><span>core file size          (blocks, -c) unlimited</span></span>
<span class="line"><span>data seg size           (kbytes, -d) unlimited</span></span>
<span class="line"><span>scheduling priority             (-e) 0</span></span>
<span class="line"><span>file size               (blocks, -f) unlimited</span></span>
<span class="line"><span>pending signals                 (-i) 61386</span></span>
<span class="line"><span>max locked memory       (kbytes, -l) 64</span></span>
<span class="line"><span>max memory size         (kbytes, -m) unlimited</span></span>
<span class="line"><span>open files                      (-n) 655350</span></span>
<span class="line"><span>pipe size            (512 bytes, -p) 8</span></span>
<span class="line"><span>POSIX message queues     (bytes, -q) 819200</span></span>
<span class="line"><span>real-time priority              (-r) 0</span></span>
<span class="line"><span>stack size              (kbytes, -s) 8192</span></span>
<span class="line"><span>cpu time               (seconds, -t) unlimited</span></span>
<span class="line"><span>max user processes              (-u) 61386</span></span>
<span class="line"><span>virtual memory          (kbytes, -v) unlimited</span></span>
<span class="line"><span>file locks                      (-x) unlimited</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>全连接队列长度</strong>：min(backlog,somaxconn)，net.core.somaxconn，somaxconn 是Linux内核参数，默认128，可通过/proc/sys/net/core/somaxconn进行配置；业务的 listen(fd, backlog) 的 backlog；</li><li><strong>半连接队列长度</strong>：tcp_max_syn_backlog，内核参数，通过/proc/sys/net/ipv4/tcp_max_syn_backlog来设置；net.core.somaxconn，somaxconn 是Linux内核参数，默认128，可通过/proc/sys/net/core/somaxconn进行配置；业务 tcp 调用 listen(fd, backlog) 的 backlog；</li></ul></li><li><p>Netty 系统参数调整：（目前只分析针对 NIO 的）</p><ol><li>SocketChannel <ol><li><strong>SO_SNDBUF</strong>：TCP 数据发送缓冲区大小。如果发送缓冲区太小，发送方发送的数据可能会被阻塞，直到缓冲区有足够的空间来存储数据。如果发送缓冲区太大，可能会导致过多的内存占用；通常调成带宽和延时的乘积；</li><li><strong>SO_RCVBUF</strong>：TCP 数据接收缓冲区大小；通常调成带宽和延时的乘积；</li><li><strong>SO_KEEPALIVE</strong>：TCP Keepalive，长连接用的，通过周期性发送探测数据包来实现这个目标。如果在一段时间内没有数据或确认报文通过网络，这个特性就会触发，发送一个探测包到对端主机。如果接收到回应，连接就继续保持开启。如果没有收到回应，TCP Keepalive则会再次发送探测包，直到达到预设的次数，如果还没有收到回应，就会认为连接已经断开，并关闭这个连接；</li><li><strong>SO_LINGER</strong>：关闭 Socket 的延迟时间，默认禁用，socket.close() 方法立即返回，待发送的数据将由系统后台继续发送；0 表示立即关闭。</li><li><strong>TCP_NODELAY</strong>：设置是否启用 Nagle 算法。这种算法可将小的碎片数据连接成更大的报文来提高发送效率。如果需要发送一些比较小的报文，那么需要禁用 Nagle 算法；</li></ol></li><li>ServerSocketChannel <ol><li><strong>SO_RCVBUF</strong>：</li><li><strong>SO_BACKLOG</strong>：连接请求的处理是围绕一个请求队列进行的。执行一次 accept() 方法就相当于处理请求队列中的一个请求并建立连接，没来得及处理的连接请求就会在请求队列中等待处理，SO_BACKLOG 就是设置这个等待队列的长度。</li></ol></li></ol></li><li><p>Netty 非系统参数调整</p><ol><li><strong>高低水位</strong>，最重要的；我们用的 8k，128k</li><li><strong>高水位</strong>：表示写缓冲区的上限。当写缓冲区的字节数超过高水位时，Channel 的 isWritable() 方法会返回 false，从而阻止继续写入数据，直到缓冲区中的数据量下降到低水位以下；</li><li><strong>低水位</strong>：表示写缓冲区的下限。一旦写缓冲区的字节数降到低水位以下，Channel 的 isWritable() 方法会再次返回 true，允许继续写入数据；</li><li>注意：需要在 write 的时候判断 channel 是否可写，否则这个高低水位没什么用；</li></ol></li></ul><p>查看 linux 默认和最大的发送缓冲区和接收缓冲区的大小：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>cat /proc/sys/net/core/rmem_max | awk &#39;{ print $1 / (1024 * 1024) }&#39;</span></span>
<span class="line"><span>cat /proc/sys/net/core/wmem_max | awk &#39;{ print $1 / (1024 * 1024) }&#39;</span></span>
<span class="line"><span>cat /proc/sys/net/core/rmem_default | awk &#39;{ print $1 / 1024 }&#39;</span></span>
<span class="line"><span>cat /proc/sys/net/core/wmem_default | awk &#39;{ print $1 / 1024 }&#39;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>cat tcp_wmem | awk &#39;{print $2 / 1024}&#39;</span></span>
<span class="line"><span>64</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="netty-内存泄漏检测" tabindex="-1"><a class="header-anchor" href="#netty-内存泄漏检测"><span>Netty 内存泄漏检测</span></a></h4><p>（1）<strong>Netty 中的资源管理</strong></p><ul><li>初始化一个资源的时候它的引用计数为 1；</li><li>当你释放它的时候，它的引用计数会减 1，如果引用计数到 0 了，这个对象就会<strong>释放并且它们的资源就能回到内存池</strong>中；</li></ul><p>如果一个 <code>ByteBuf</code> 没有执行完自己该做的 release，它就已经不可达了，JVM 就有可能对它们执行 GC。我们知道一旦一个对象被 GC 了，那就不可能再去调用它的 release 方法了。那这个 <code>ByteBuf</code> 就所占用的内存池资源就没法还回去，内存池上可用资源就会越来越少，换言之。这时候我们就产生了内存泄漏。</p><p>（2）netty 的内存泄漏检测机制需要完成两个任务：</p><ul><li><strong>在泄漏发生的时候，我们需要有个通知机制来知晓被 GC 的对象没有调用自己该有的 release 方法来释放池化资源</strong>；</li><li>需要有个记录机制来记录这些泄漏的对象使用的地方，方便溯源；</li></ul><p><strong>（3）Netty 内存检测的实现</strong></p><ul><li>当申请资源时，例如使用 <code>ByteBuf buffer = ctx.alloc().buffer() </code>申请堆外内存，将引用计数加 1，同时定义<strong>弱引用 DefaultResourceLeak 并将其添加到一个集合</strong><code>（#allLeak）</code>中；</li><li>当释放资源时，例如归还内存到内存池，会将引用计数减 1。当减到 0 的时候，自动执行释放资源的操作，并将弱引用从之前的那个集合中移除；</li><li>正常流程时会将 Bytebuf 和弱引用的断开，并将自己从 集合<code>（#allLeak）</code>中移除，这样该 ByteBuf 被 GC 时，就会进入到 refQueue，在遍历 refQueue 的时候回去尝试从 集合<code>（#allLeak）</code>中 移除元素，因为是正常 release 了，所以此时并没有出现内存泄露；</li><li>异常流程，没有正常调用 release 方法，也就是没有将自己从 集合<code>（#allLeak）</code>中移除，等到发生 GC 时，就会加入到 refQueue，在遍历refQueue 的时候发现集合<code>（#allLeak）</code>中有该 ref，说明发生内存泄露了。如果发生内存泄露，就会打出日志，可以通过配置指定是全样本检查，还是抽样检查 sample；</li></ul><h3 id="spring-循环依赖问题" tabindex="-1"><a class="header-anchor" href="#spring-循环依赖问题"><span>Spring 循环依赖问题</span></a></h3><p>Spring 中引起循环依赖有如下几个原因</p><ol><li>原型模式下的循环依赖（无法解决）；</li><li>单例模式下的构造方法注入属性导致的循环依赖（无法解决）;</li><li>单例模式下的 setter 方法注入属性导致的循环依赖（可以解决）；</li></ol><p>Spring 检查原型模式的循环依赖的伪代码：ThreadLocal 实现的</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (查询标记，bean 正在创建中) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    抛异常</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">标记 bean 正在创建中</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">创建 bean</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">标记 bean 创建完成了</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Spring 的代理增强一般都是在实例初始化最后执行的，其实是 AbstractAutoProxyCreator 后置处理器的 postProcessAfterInitialization 创建代理对象的。但是假如发生循环依赖就需要提前创建代理对象了，因为别的实例需要注入这个代理对象，假如不提前创建那么注入的就是原始对象了，那就不符合要求了。</p><p>前面说了 Spring 的代理增强一般都是在实例初始化最后执行的，假如发生循环依赖就需要提前创建代理对象了。那么问题了，Spring 是如何防止重复创建代理对象的。发送循环依赖提前创建对象其实是调用的 AbstractAutoProxyCreator#getEarlyBeanReference 方法，提前创建会将Bean 的信息添加到 earlyProxyReferences 中，它是一个 Map。Spring 在初始化阶段做代理增强是在后置处理器 AbstractAutoProxyCreator 的 postProcessAfterInitialization 方法做的，可以看到这里面判断了 earlyProxyReferences 中是否之前代理过，假如代理过就不再重复代理了。</p><p>循环依赖总结</p><ul><li>单例 set 方法的循环依赖，Spring 会使用三个级别的缓存来解决，无需额外的配置； 允许 Spring 在实例化和初始化 Bean 的过程中，暂时存储正在创建的 Bean 实例，以便在发生循环依赖时能够提前曝光（early exposing）。 <ol><li><strong>一级缓存的对象是已经走完全部生命周期的对象</strong>，也就是存储完全初始化的单例 Bean 实例；</li><li><strong>三级缓存存放的对象是 bean 对应的工厂对象，发生循环依赖时，会从工厂对象获取产品（可能是原始 bean，也可能是代理后的 bean</strong>）;</li><li><strong>二级缓存存在，说明发生循环依赖了，存放的是从三级缓存中的工厂对象获取的对象（可能是原始 bean，也可能是代理后的 bean）</strong>;</li></ol></li><li>Spring 在一般情况下都是在 bean 的初始化阶段去创建代理对象的，但是假如发生循环依赖就会提前给创建代理对象存放到二级缓存中；</li><li><strong>二级缓存的意义</strong>：假如提前创建了代理对象，在最后的阶段需要从二级缓存中获取该代理对象，保证最终返回的结果是代理后的对象；</li><li>构造方法和原型模式的循环依赖，Spring 自己是无法自动帮我们解决的，但是我们可以通过一些方案来规避这个问题； <ul><li><a href="">@Lazy </a> 注解； 可以在 Bean 上使用 @Lazy 注解延迟加载 Bean，从而避免循环依赖问题。当 Bean 被标记为 @Lazy 时，Spring 容器会在第一次使用该 Bean 时才进行初始化。</li><li>ObjectFactory 和 ObjectProvider 接口；</li><li>Java 官方提供的 Provider 接口；</li><li>上面的这些方案基本思路就是将真正获取对象的时机延迟了，这样就不会发送循环依赖问题了</li></ul></li></ul><img src="/assets/image-20240304183303178-xvccp-3g.png" alt="image-20240304183303178" style="zoom:100%;"><h3 id="分布式事务本地消息表" tabindex="-1"><a class="header-anchor" href="#分布式事务本地消息表"><span>分布式事务本地消息表</span></a></h3><p>消息表字段：id, biz_id, biz_type, msg, msg_result, msg_desc,atime,try_count。分别表示uuid，业务id，业务类型，消息内容，消息结果（成功或失败），消息描述，创建时间，重试次数， 其中biz_id，msg_desc字段是可选的。</p><ol><li>Producer 端准备 1 张消息表，把 update DB 和 insert message 这 2 个操作，放在一个 DB 事务里面，也就是说保证业务操作和本地消息表的操作是原子性的。发送消息到消费方，如果消息发送失败，会进行重试发送。</li><li>定时任务把消息表中的 message 传送给 MQ。失败了，不断重试重传。允许消息重复，但消息不会丢。</li><li>Consumer 端准备一个判重表。处理过的消息，记在判重表里面。实现业务的幂等。但这里又涉及一个原子性问题：如果保证消息消费 + insert message 到判重表这2个操作的原子性；</li></ol><h3 id="spi-机制-以及其在-motan-中怎么用的" tabindex="-1"><a class="header-anchor" href="#spi-机制-以及其在-motan-中怎么用的"><span>SPI 机制，以及其在 Motan 中怎么用的</span></a></h3><ul><li>API：当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 API ，这种接口和实现都是放在实现方的；</li><li>SPI：<strong>当接口存在于调用方这边时，调用方定义接口规则，不同的实现按照这个接口规则去实现，提供各种的服务</strong>；</li></ul><p>有很多开源框架都涉及到了 SPI 技术，例如 <strong>JDBC 的数据驱动</strong>、<strong>Motan 和 Dubbo 扩展的 SPI 机制</strong>、Spring 的 SPI 机制、日志框架中的 SPI 机制。</p><h4 id="jdk-的-spi-机制源码分析" tabindex="-1"><a class="header-anchor" href="#jdk-的-spi-机制源码分析"><span>JDK 的 SPI 机制源码分析</span></a></h4><p>为什么要在 resource 的 <code>/META-INF/services</code> 文件夹下面创建文件呢？其实这个路径是 JDK 的 ServiceLoader 类源码中写死的，如下：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> PREFIX </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;META-INF/services/&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里我们分析下 ServiceLoader 实现 SPI 的机制，也就是分析上面的案例的代码是如何得到实现类对象的，案例测试代码如下：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Test</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> test</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 初始化一个 ServiceLoader</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    ServiceLoader</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Loadbalance</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> s </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> ServiceLoader</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">load</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">Loadbalance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    Iterator</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Loadbalance</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> iterator </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> s</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">iterator</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 加载所有的 Service Provider</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    while</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">iterator</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">hasNext</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Loadbalance</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> loadbalance </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> iterator</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        loadbalance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;用户服务&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        loadbalance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setWeightString</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;100&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>老样子先看一下整体的流程图：</p><img src="/assets/JDK%E7%9A%84SPI%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90-BjzGXvlD.png" alt="JDK的SPI流程分析" style="zoom:100%;"><p>第一步：调用 java.util.ServiceLoader#load(Class) 方法获取一个 ServiceLoader 对象，这一步没有做什么特殊处理，就是初始化一个 ServiceLoader 实例，并且初始化了一个延迟加载 Service 的迭代器 lookupIterator。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ServiceLoader</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Class</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">S</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> svc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ClassLoader</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> cl) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    service </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Objects</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">requireNonNull</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(svc, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Service interface cannot be null&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    loader </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (cl </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> ClassLoader</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getSystemClassLoader</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> :</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> cl</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    acc </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getSecurityManager</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> !=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> AccessController</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getContext</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> :</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    reload</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> reload</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    providers</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">clear</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 创建一个懒加载用的迭代器</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    lookupIterator </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> LazyIterator</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(service</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> loader)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第二步：调用迭代器的 hasNext() 方法查看是否有 Service 实现可以获取，第一次获取会去前面说的延迟加载的迭代器 lookupIterator 中去尝试获取 Service 实现，最后会调用 java.util.ServiceLoader.LazyIterator#hasNextService 方法</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">/* 是否有更多的 service */</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> boolean</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> hasNextService</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (nextName </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (configs </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        try</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // PREFIX = &quot;META-INF/services/&quot;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">            String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> fullName </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> PREFIX </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> service</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (loader </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">                configs </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> ClassLoader</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getSystemResources</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(fullName);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            else</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">                configs </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> loader</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getResources</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(fullName);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">IOException</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> x</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">            fail</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(service</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;Error locating configuration files&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> x)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    while</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> ((pending </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">||</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> !</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">pending</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">hasNext</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">configs</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">hasMoreElements</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> false</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        pending </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> parse</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(service</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> configs</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">nextElement</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    nextName </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> pending</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面 java.util.ServiceLoader.LazyIterator#hasNextService 方法的关键部分就是获取文件路径，也就是 <code>String fullName = PREFIX + service.getName();</code>，然后通过加载器去加载这个资源，最后调用 java.util.ServiceLoader#parse 方法去解析这个文件里面的内容，也就是我们写在里面的 Service 的实现类的全限定名称。该 parse 方法的实现如下</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Iterator</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> parse</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Class</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> service</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> URL</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> u)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    throws </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ServiceConfigurationError</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">{</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    InputStream</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> in </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    BufferedReader</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> r </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    ArrayList</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> names </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ArrayList</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    try</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        in </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> u</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">openStream</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        r </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> BufferedReader</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> InputStreamReader</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(in</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;utf-8&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">))</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> lc </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        while</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> ((lc </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> parseLine</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(service</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> u</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> r</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> lc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> names)) </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">IOException</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> x</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        fail</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(service</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;Error reading configuration file&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> x)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">finally</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">       // ...... 省略关流处理 ......</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> names</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">iterator</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方法的作用就是，没解析一行就去尝试将解析出来的 Service 实现类的全限定名存到 names 集合里面去。</p><p>第三步：调用迭代器的 next() 方法获取 Service 实现类的实例，ServiceLoader 中有缓存机制，这里就不分析它的缓存机制了。如果 Service 实现类的实例还没有创建，就会去调用 java.util.ServiceLoader.LazyIterator#nextService 去实例化 Service 实现类。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> S</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> nextService</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">hasNextService</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">())</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        throw</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> NoSuchElementException</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> cn </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> nextName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    nextName </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    Class</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> c </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    try</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        c </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">forName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(cn, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">false</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, loader);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ClassNotFoundException</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> x</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // ...... 省略异常处理 ......</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">service</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">isAssignableFrom</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(c)</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // ...... 省略异常处理 ......</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    try</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        S</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> p </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> service</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">cast</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">c</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">newInstance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">());</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        providers</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">put</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(cn, p);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Throwable</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> x</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">       // ...... 省略异常处理 ......</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    throw</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Error</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">          // This cannot happen</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其实就是通过反射去创建 Service 的实现类了。</p><h4 id="motan-dubbo-中的-spi-机制的提现" tabindex="-1"><a class="header-anchor" href="#motan-dubbo-中的-spi-机制的提现"><span>Motan/Dubbo 中的 SPI 机制的提现</span></a></h4><p>以 Motan 为例分析，Motan 自己实现了类似 JDK 的 ServiceProvider 的 SPI 机制，在 JDK 的 SPI 机制上做了自己的扩展。</p><p>com.weibo.api.motan.core.extension.ExtensionLoader 类是 SPI 机制的核心，它支持 JDK ServiceProvider 和注解方式去配置 SPI，获取 Service 实现类的实例核心代码如下：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> T</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> getExtension</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> boolean</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> throwWhenNotFound) {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    checkInit</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // ...... 省略异常处理 ......</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    try</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Spi</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> spi </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> type</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getAnnotation</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">Spi</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">spi</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">scope</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Scope</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">SINGLETON</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 单例处理</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            return</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> getSingletonInstance</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> throwWhenNotFound)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 获取保存的 name 对应类的 Class 文件</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">            Class</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">T</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> clz </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> extensionClasses</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(name);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // ...... 省略异常处理 ......</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 反射创建实例</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> clz</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">newInstance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">MotanFrameworkException</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> mfe</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // ...... 省略异常处理 ......</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单看一下 motan-core 包下的 <code>META-INF/services/</code> 中有多少个 LoadBalance 的实现类。</p><img src="/assets/image-20230711191248797-9073970-Cm8e19WZ.png" alt="image-20230711191248797" style="zoom:100%;"><p>关于 Motan、Dubbo 的 SPI 机制后面有机会再详细分析。</p><h2 id="introduce" tabindex="-1"><a class="header-anchor" href="#introduce"><span>introduce</span></a></h2><p>面试官你好，我叫 XXX，来自湖北黄冈。</p><p>我做了 5 年多的 Java 服务端开发，目前有直播社交类、即时通讯 IM 和物联网 IoT 方面的工作经验。</p><ul><li><p>现在在哈啰 1 年的时间了，主要的工作内容是 IoT 设备接入域的子域负责人，负责 IoT 设备接入域的稳定性治理和出海服务。</p></li><li><p>在前面一家公司待了 3 年时间，后期角色是虚线带人，加我一起 3 个人。主要工作内容是作为 IM 服务和出海服务的负责人，跟进需求的进度，并持续推动。从需求评审、CR 等流程下来，让服务保质保量的按时交付。</p></li></ul><p>工作中的一些碎片化的时间会利用起来去梳理当前我负责的服务上的现有逻辑、日志、监控和告警，找出一些可能存在的性能问题、逻辑漏洞，并推动解决他们。</p><p>下班后的时间会学习一些开源框架的源码设计，目前我已经看了 Netty、RocketMQ、JUC、Spring、Mybatis 的核心源码了，学习这些框架的目的是为了从中学设计模式的使用，和一些架构设计思路，并且把学到的知识更好的运用在项目中。最近一年看的宏观上的知识多一点，比如架构设计、SRE、稳定性治理方面的内容了。</p><h2 id="哈啰工作内容" tabindex="-1"><a class="header-anchor" href="#哈啰工作内容"><span>哈啰工作内容</span></a></h2><h3 id="iot-架构" tabindex="-1"><a class="header-anchor" href="#iot-架构"><span>IoT 架构</span></a></h3><p>哈啰 IoT 分为 PaaS 域和 SaaS 域，（有业务属性的就归 SaaS 管）</p><ul><li>PaaS 域：主要关注对象是设备，涉及设备连接、设备管理、设备运维（任务、OTA）、消息处理等。</li><li>SaaS 域：主要关注的场景联动和增值服务，例如 sim 卡管理、语音平台、故障平台等。</li></ul><p>我个人主要负责的是 PaaS 子域相关的服务。</p><blockquote><p>注意 PaaS 和 SaaS 的真实概念，而不是哈啰 IoT 部门的划分。</p></blockquote><p>TODO-KWOK 来个整体架构图</p><h3 id="what-did-i-do" tabindex="-1"><a class="header-anchor" href="#what-did-i-do"><span>what did i do</span></a></h3><p>我来哈啰主要做的事情就是 IoT 系统的稳定性治理：</p><ul><li>设备协议治理专项：主导协议变更三板斧机制（可灰度、可观测、可回滚），实现全年协议变更 0 故障，MTTR 缩短至 1 分钟；</li><li>核心链路可观测：制定系统日志规范，完善域内监控，实现 100% 核心链路日志覆盖，异常定位时效提升至分钟级；</li><li>核心服务性能优化：通过降低 CPU、内存占用、磁盘 IO等手段，使消息流转服务器规模缩减 50%，年省成本 15w；</li><li>多租户架构升级：完成 10w QPS 流量链路、资源隔离改造，建立哈啰内部租户成本核算体系，支持商业化计费系统落地；</li><li>IoT 出海 owner：负责出海技术架构建设和技术方案，支撑新加坡、澳洲业务落地；</li></ul><h3 id="项目介绍" tabindex="-1"><a class="header-anchor" href="#项目介绍"><span>项目介绍</span></a></h3><h4 id="设备协议治理专项" tabindex="-1"><a class="header-anchor" href="#设备协议治理专项"><span>设备协议治理专项</span></a></h4><p><strong>背景：</strong></p><ul><li>产品协议变更风险高：每次变更都是对全量设备生效，且没有快速精准的止血手段；（23年有很多因为协议变更导致的故障）</li><li>针对某些业务线有很多非标的定制化逻辑，需要治理；</li></ul><p><strong>目标</strong>：建立协议变更三板斧能力（可灰度、可观测、可回滚），全年实现协议变更 0 故障，秒级回滚能力。</p><p><strong>核心内容</strong>：</p><ul><li>协议发布流程变更，将产品的协议分为草稿、灰度和正式版本；</li><li>发布过程通过白名单设备 ID 验证后，按 1‰→1%→5%→10%→30%→50%→100% 阶梯式流量灰度；</li><li>灰度中或者发布完成后，异常时一键回滚至上一可用版本，快速止血。</li></ul><p>这个专项主要还是功能改造，除了上面的协议变更的三板斧，这个专项还做了非标链路迁移和平台相关的操作优化，最后的结果是 24 年全年由协议变更导致的故障降为 0 次。</p><p><strong>技术难点与突破</strong>：</p><ul><li>历史债务治理：由于历史架构局限性，前期建设力不足，业务增长期快速迭代，遗留代码结构和存储结构等问题，重构设备协议管理和解析功能，保障千万级设备兼容性；</li><li>高流量链路迁移：在 10万 QPS的核心链路上，实现协议元数据平滑迁移，过程中零数据丢失、零服务中断；</li></ul><p><strong>成果</strong>：2024年全年协议变更相关故障降为0次，提供协议变更导致故障的秒级回滚能力。</p><p><strong>预设技术追问答案</strong></p><p><strong>追问 1：灰度发布机制如何实现流量分级？</strong></p><p>Q：阶梯式灰度发布具体如何实现？设备 ID 的路由策略是什么？如何爆炸各阶段流量切换的平滑性？</p><p>A：</p><ul><li>路由策略：基于设备 ID 的哈希取模（如 hash(deviceId)%1000）,将设备映射到固定区间，通过页面调整灰度比例（例如 1‰ 对应 0-1 号段）</li><li>平滑切换：通过管控后台实时更新灰度规则，协议解析服务通过设备 ID 路由到不同的版本的协议；</li></ul><p><strong>追问 2：如何实现秒级回滚？</strong></p><p>Q：“一键回滚”的技术细节是什么？回滚是否需要停机？如何保证回滚过程中的数据一致性？</p><p>A：</p><ul><li>灰度中：开关控制灰度失效，直接走的最新稳定版本的协议数据；</li><li>全量推送后：每个产品的协议变更都有版本记录，通过回退最佳一次的稳定版本协议数据即可；</li></ul><p><strong>追问 3：历史债务治理中的兼容性保障</strong></p><p>Q：重构协议解析模块时，如何保证千万级设备的兼容性？是否需要对历史数据做迁移？</p><p>A：</p><ul><li>双解析逻辑：服务同时支持新旧协议存储数据，通过阶梯式灰度，将解析方式迁移到新链路；</li><li>数据迁移：存量数据脚本迁移到新的存储表，增量数据双写逻辑；</li><li>测试验证：线上流量录制回放，对比新旧链路解析结果的一致性；</li></ul><h4 id="多租户架构升级" tabindex="-1"><a class="header-anchor" href="#多租户架构升级"><span>多租户架构升级</span></a></h4><p>TODO-KWOK</p><p><strong>背景：</strong></p><p><strong>目标</strong>：</p><p><strong>核心内容</strong>：</p><p><strong>技术难点与突破</strong>：</p><p><strong>成果</strong>：</p><p><strong>预设技术追问答案</strong></p><p>追问 1：计费体系</p><p>Q：你们的计费体系是怎么样的？</p><p>A:</p><p><strong>IoT 计费体系调研</strong></p><blockquote><p>亚马逊定价计算器：<a href="https://calculator.amazonaws.cn/#/createCalculator/IoTCore?trk=pricing-ban" target="_blank" rel="noopener noreferrer">https://calculator.amazonaws.cn/#/createCalculator/IoTCore?trk=pricing-ban</a></p><ul><li><a href="https://www.amazonaws.cn/iot-core/pricing/additional-details/" target="_blank" rel="noopener noreferrer">https://www.amazonaws.cn/iot-core/pricing/additional-details/</a></li></ul><p>阿里云未提供物联网定价计算器，只能从详细页预估：<a href="https://help.aliyun.com/zh/iot/product-overview/billing/?spm=a2c4g.11186623.help-menu-30520.d_0_1.438116186gnqF3&amp;scm=20140722.H_55732._.OR_help-T_cn~zh-V_1" target="_blank" rel="noopener noreferrer">https://help.aliyun.com/zh/iot/product-overview/billing/?spm=a2c4g.11186623.help-menu-30520.d_0_1.438116186gnqF3&amp;scm=20140722.H_55732._.OR_help-T_cn~zh-V_1</a></p><p>华为云：</p><ul><li><a href="https://www.huaweicloud.com/pricing.html#/iothub" target="_blank" rel="noopener noreferrer">https://www.huaweicloud.com/pricing.html#/iothub</a></li><li>计费详情：<a href="https://support.huaweicloud.com/price-iothub/iot_price_00001.html" target="_blank" rel="noopener noreferrer">https://support.huaweicloud.com/price-iothub/iot_price_00001.html</a></li></ul><p>腾讯云：</p><ul><li><p><a href="https://buy.cloud.tencent.com/iotexplorer" target="_blank" rel="noopener noreferrer">https://buy.cloud.tencent.com/iotexplorer</a></p></li><li><p><a href="https://cloud.tencent.com/document/product/1081/104124" target="_blank" rel="noopener noreferrer">https://cloud.tencent.com/document/product/1081/104124</a></p></li></ul></blockquote><p>计费模式：分为可以分为包月和按需计费，由于暂时还未做商业化，目前支持按需计费。</p><table><thead><tr><th>对比项</th><th>阿里云</th><th>华为云</th><th>腾讯云</th><th>亚马逊</th></tr></thead><tbody><tr><td>计费模式</td><td>包年、包月、按量计费</td><td>包年、包月、按需计费</td><td></td><td></td></tr><tr><td>企业版计费项</td><td>包年包月：<br>消息上下行TPS<br>消息转发TPS<br>同时在线设备数<br>增值服务<br>存储、计算处理单元</td><td>包年包月<br><br>存储、计算处理单元</td><td>包年包月：<br>同时在线设备数<br>设备注册上限<br>设备上下行消息TPS<br>存储、计算处理单元</td><td>连接数和连接时长<br>消息数<br>规则引擎触发次数<br>设备影子</td></tr><tr><td>公共版计费项目</td><td>按量计费：<br>上下行消息数<br>设备在线时长<br>OTA 升级次数</td><td>按量计费：<br>实例规格<br>设备端消息数<br>规则转发消息数<br>OTA 升级次数</td><td>按量计费：<br>设备激活码<br>消息数<br>OTA 次数</td><td></td></tr></tbody></table><blockquote><p>关于消息数：腾讯云的定位是，消息计数为 “每条消息内容长度 / 512 Bytes” 向上取整计算。</p><p>关于 OTA 次数：阿里云和腾讯云的定位是 “((每个OTA升级包大小/100 MB)向上取整数) * 升级成功的设备数&quot;。</p></blockquote><h4 id="核心链路可观测" tabindex="-1"><a class="header-anchor" href="#核心链路可观测"><span>核心链路可观测</span></a></h4><p><strong>背景</strong>：2023年IoT域引发的线上故障频发，严重影响系统稳定性。为此我们在2024年启动专项治理，核心链路可观测性建设是其中的关键一环。当时面临三大痛点：</p><ul><li><strong>日志干扰严重</strong>：核心链路中大量无效Error/Warn日志，既浪费存储资源又干扰排障；</li><li><strong>排障效率低</strong>：日志格式不规范（如缺失关键设备ID）、错误码定义模糊（如&quot;系统异常&quot;覆盖20+场景），无法确定问题边界，导致平均故障定位耗时长达30分钟；</li><li><strong>告警噪音大</strong>：大量低优先级和无效的告警淹没，真实危机容易被掩盖；</li></ul><p><strong>目标</strong>：</p><ul><li>构建&quot;1-3-10&quot;故障响应机制：1分钟发现、3分钟响应、10分钟恢复。</li></ul><p><strong>核心内容</strong>：</p><ul><li><p><strong>日志治理</strong>（主导推进）：</p><ul><li><strong>阶段化实施</strong>： <ul><li><strong>异常清洗期</strong>：调整删除无效的、不合理的日志打印，做到不被无用的日志干扰；</li><li><strong>规范提效期</strong>：推动研发侧落地“日志规范”，统一设备ID、业务场景（注册/上行/下行/ACK/短信/蓝牙等），提升日志搜索效率。实现内部排查使用，对业务方做到可解释，逐步封装业务的问题类型；</li><li><strong>价值延伸期</strong>（产品运营）：IoT 平台基于日志数据做系统瓶颈分析，产品/业务方同学基于日志进行用户分析；</li></ul></li><li><strong>关键创新</strong>： <ul><li>设计错误码分级体系（平台错误码，业务错误码，场景错误码），明确异常场景的精准归因。</li></ul></li></ul></li><li><p><strong>告警优化</strong>（方案设计）：</p><ul><li><p><strong>问题破局</strong>：通过分析历史告警的数据和触发规则，找出其中不合理的地方，通过改动同比、环比、绝对阈值等方式优化告警规则</p><ul><li><p>案例 1：短信：（环比 -&gt; 同环比）</p><ul><li>问题：短信下行波动使用的是环比。但是下行短信的 TPS 波动一般都在 50 的范围内，在业务高峰期，由于短信的基数比较大，相同的波动不会产生告警，而在业务低峰期，相同的波动就会产生较大的告警。</li><li>处理方式：1）调整为同环比的方式，短信 tps 具有较强的业务潮汐特性，环比策略难以表明 TPS 的变化是异常情况导致的，采用同比方式比较合理。2）短信的波动较为明显，仍然需要环比来识别异常情况。</li><li>最终方案：较前一天&amp;前 5 分钟波动 10%，且持续 2 分钟则触发告警。</li></ul></li><li><p>案例 2：下行请求错误数：(环比 -&gt; 移动平均环比)</p><ul><li>基数比较低，而且有明显的业务潮汐特性，采用移动平均环比的方式比较合适，但是平台暂时不支持，结合日志治理方式，推动业务方调整，避免请求到下线设备；同时提高告警阈值。</li></ul></li></ul></li><li><p><strong>效果验证</strong>： 告警总量下降 70% 的同时，关键业务（设备开锁成功率）告警召回率从77%提升至95%。</p></li><li><blockquote><p>召回率 = 正确触发的告警数 / 实际应触发告警的总数</p><p>实际应触发告警的总数 = 正确触发的告警数 + 漏报的</p></blockquote></li></ul></li></ul><p><strong>专项难点</strong>：</p><ul><li>系统复杂性治理——需要梳理问题日志和告警数量较多；（逐个梳理）</li><li>跨域协作推动——业务团队优先保障需求交付速度，对日志规范落地存在抵触；（展示规范日志在关键故障中的定位价值，纳入研发KPI考核）</li><li>流程变革阻力——习惯迁移与效率平衡，研发习惯改变引发<strong>短期阵痛</strong>（有些人打日志还是随性而为，没有规范）</li></ul><p><strong>成果</strong>：通过治理后，IoT 域 MTTD（平均故障检测时间）从 15 分钟降至 1 分钟，MTTR（平均修复/恢复时间）从 30 分钟压缩至 5 分钟。</p><p>​</p><p><strong>预设技术追问答案</strong></p><p>Q：<strong>配置告警策略有哪些？</strong></p><p>A：</p><ul><li><strong>静态阈值：</strong><ul><li>说明：实际值和设置的阈值比较不在范围内，则为异常</li><li>使用场景：指标统计报错数量，或指标数据时间单位（一天）比较恒定</li></ul></li><li><strong>同比：</strong><ul><li>说明：当前 t 时刻的实际值和同期历史数据（t-1d，t-2d....）的均值作比较，满足所设条件则为异常（实际值超出上下限则为异常）</li><li>使用场景：单位之间（一天），指标数据有明显趋势且稳定</li><li>缺点：节假日和雨季可能会误报</li></ul></li><li><strong>环比：</strong><ul><li>说明：实际值与前几分钟（5-10min 最佳）的平均值做比较，满足所涉条件则为异常</li><li>使用场景：短期内（近几分钟）的数据无大幅数据波动，指标属于平稳型</li><li>缺点：由于是与短期内做比较，随着时间推移若异常指标逐渐趋于稳定时，会产生恢复的假象，建议核心指标持续时长设置为 0s（立即告警）且为高级告警。</li></ul></li><li><strong>同比区间&amp;环比区间策略</strong><ul><li>说明：可参考同比、环比策略。唯一区别，会根据用户设置的上下限范围，则为异常</li><li>使用场景：数据无大幅波动，指标属于平稳型（不能容忍下范围增长和下跌）</li><li>缺点：若指标超出了用户设置的上下限范围，则无法触发警告，故同时一定要配置同比或环比的策略进行兜底</li></ul></li><li><strong>移动平均同比：</strong><ul><li>说明：以滑动时间窗口的方式计算窗口内的平均值，然后做检测，符合所设条件则为异常</li><li>使用场景：特定场景定制的策略，一般用不到</li></ul></li><li><strong>时间范围静态阈值：</strong><ul><li>说明：取前几分钟（t-1,t-2,t-3...）的总和（s），与当前时刻（t）的值作比较，比较逻辑与静态阈值相同</li><li>使用场景：特定场景定制的策略，一般用不到</li></ul></li><li><strong>静态阈值同比：</strong><ul><li>静态阈值+同比策略，（多种基础算法的组合，两种算法都命中才认为异常）</li></ul></li><li><strong>静态阈值环比：</strong><ul><li>静态阈值+环比策略，（多种基础算法的组合，两种算法都命中才认为异常）</li></ul></li><li><strong>同环比策略</strong><ul><li>同比环比同时命中</li><li>同比 7d 出现波动，并且同时满足环比前几个点的波动情况，才会触发告警，该策略用来弥补节假日同比误报率的场景，但要知晓环比策略的确定进行配置。</li></ul></li></ul><p><strong>Q：错误码分级体系的设计逻辑是什么？如何避免不同业务场景的错误码冲突？</strong></p><p>A：</p><ul><li>使用首位为字母，后 4 位为数字的方式来表示错误码，分场景 <ul><li>首位： A 表示业务错误，B 表示平台本身错误，C 表示二方包错误，D 表示三方包错误。</li><li>中间两位表示场景，例如 注册/上行/下行/ACK/短信/蓝牙</li><li>后两位表示场景具体的错误码</li></ul></li><li>单独起一个错误码包，IoT 域内共用错误码。</li></ul><p><strong>Q：告警优化案例中提到“同比+环比”策略，为何选择这两种方法的组合？如何确定阈值（如10%）？</strong></p><ul><li>业务潮汐特性导致单一环比在高/低峰期不敏感，同比可消除周期性波动，而环比捕捉短期异常。阈值通过历史数据分析如正常波动范围。</li></ul><p><strong>非核心讲解内容：</strong></p><p>目标拆解：</p><ul><li><p>如何降低误报数？</p><ul><li>原因：告警规则阈值和采样周期不合理导致告警频繁；</li><li>解决：调整告警规则阈值和条件；告警分级，避免大量无效低优先级的告警触发；</li></ul></li><li><p>如何降低误报率？</p><ul><li><p>原因：告警阈值过低（规则敏感）导致业务未出现问题的情况下，被识别为有问题；</p></li><li><p>解决：从指标角度分为周期性和波动性两个维度，分别设置对应的告警策略；</p></li><li><blockquote><p>同比：7 天平均值、昨天同期。（长期趋势、周期性变化）</p><p>环比：相邻周期（短期波动，及时变化）</p></blockquote></li><li><table><thead><tr><th>周期性\波动性</th><th>大</th><th>小</th></tr></thead><tbody><tr><td>明显</td><td>A：同比（适度曲线平滑拟合）</td><td>B：同环比结合（同比检测异常/环比减小误报）</td></tr><tr><td>不明显</td><td>C：绝对阈值（如设定历史均值的±2倍标准差为异常，曲线平滑拟合）</td><td>D：静态阈值环比（减小误报，如环比涨跌幅超5%即报警）</td></tr></tbody></table><p>解决：从业务角度，一方面需要衡量指标视角下规则配置的合理性，另一方面明确指标视角下未识别的业务有损情况。</p></li></ul></li><li><p>如何降低漏报率？</p><ul><li>原因：告警阈值过高（规则不敏感）导致业务有问题的情况下未被识别出有问题</li><li>解决：调整告警规则，设置合适阈值和条件；告警分级；通过日志辅助判断，识别业务问题。</li></ul></li><li><p>日志建设（未建设）：</p><ul><li>现有问题： <ul><li>以应用维度记录异常日志，需要分段排查，问题定位效率低；</li><li>异常记录缺失关键字段，难以区分是业务方使用问题还是平台本身问题；</li><li>缺乏关联性，难以判断问题根因，需要结合上下游；</li></ul></li></ul></li><li><p>使用场景：</p><ul><li>IoT 研发和测试：线上问题定位。（快速定位问题，构建功能指标&amp;性能指标基准促进平台建设）</li><li>业务方：设备维度全链路日志查看。（提供对接业务方的 traceid 查询调用链日志，支持查看灰度设备日志，支持基于业务场景的告警，做好了业务可以通过 IoT 可观测平台反向推进业务建设）</li><li>产品/运营：设备运营情况。（支持多维度聚合查询，识别异常设备特征）</li></ul></li></ul><h4 id="核心服务性能优化" tabindex="-1"><a class="header-anchor" href="#核心服务性能优化"><span>核心服务性能优化</span></a></h4><p>TODO-KWOK</p><h4 id="iot出海负责人" tabindex="-1"><a class="header-anchor" href="#iot出海负责人"><span>IoT出海负责人</span></a></h4><p><strong>背景和目标：</strong></p><p>随着国内共享单车业务趋于饱和，公司期望在欧美、东南亚和澳洲出城，负责海外的设备接入和数据服务，构建海外基础设施体系，将国内服务迁移到海外。</p><p><strong>具体实施：</strong></p><ul><li>基础设施搭建：申请域名、服务器、SLB 之类的；</li><li>迁移代码性能优化：迁移过来的代码压测有性能问题，同时解决不了的问题需要我来解决。（JVM元空间内存泄露了）</li><li>搭建海外监控和告警体系：例如两轮设备的开关锁指标，心跳，消息流转等指标；</li></ul><p><strong>关键成果：</strong></p><ul><li>主要是支撑海外 20w 设备接入，另外负责海外新品接入。海外服务搭建完成后，后期主要是涉及到业务对接和系统维护了。</li></ul><h2 id="克拉工作内容" tabindex="-1"><a class="header-anchor" href="#克拉工作内容"><span>克拉工作内容</span></a></h2><h3 id="architecture" tabindex="-1"><a class="header-anchor" href="#architecture"><span>architecture</span></a></h3><p>我们项目主要是分为 4 个部分，<strong>直播间业务、广播剧业务、周边电商业务、小说业务</strong>，这些业务基于一些共用的基础服务，比如 IM 服务，用户服务，资金服务，订单服务等等。</p><p>我们组主要负责<strong>直播间相关业务</strong>、<strong>自研 IM 服务</strong>和<strong>出海服务</strong>。</p><p><strong>一、直播间服务有哪些内容呢，如下：</strong></p><ol><li>直播 PK；</li><li>直播连麦；</li><li>送礼；</li><li>抽卡，扭蛋；</li><li>粉丝团；</li><li>各种排行榜；</li><li>还有一些其他活动相关的业务逻辑；</li></ol><p><strong>二、自研 IM 服务主要业务如下：</strong></p><ol><li>私聊；</li><li>群聊；</li><li>聊天室（直播间弹幕）；</li><li>一些业务消息； <ol><li>比如某个用户在直播间发了一个大礼物需要全站飘屏，这个时候就需要给所有的直播间推消息了；</li><li>还有用户升级了，会给他弹一个弹窗吧，说他升级了，这个触发逻辑就是 IM 服务端下推的消息，客户端收到后去做解析；</li></ol></li></ol><p>三、除开这些还有一些海外的套壳版本的 app 也是我们维护的。目前有<strong>日本的直播 app</strong>，<strong>北美的听广播剧的 app</strong>。</p><p><strong>最后 IM 服务和出海北美的 app 是我 owner 的。</strong></p><h3 id="what-did-i-do-1" tabindex="-1"><a class="header-anchor" href="#what-did-i-do-1"><span>what did I do</span></a></h3><p>后期负责<strong>直播间业务</strong>和<strong>海外业务</strong>的需求迭代，<strong>维护 IM 服务</strong>。工作中主要是版本需求和技术优化各占一半吧。</p><p>我主要做的需求：</p><ul><li>自研 IM 服务从 0 到 1 参与设计和开发，由于其他参与的开发离职了，后期这个服务也是由我来 owner。 <ul><li>从技术选型，功能设计，协议设计，编码落地都是有参与其中；</li><li>我主要做的事情是基于 Netty 和 SocketIO 搭建长连接服务器，设计类似 SpringMVC 的那种过滤器链和接口映射关系；</li><li>参与设计私聊、群聊和直播间消息的链路设计；</li><li>再就是其它 IM 相关的业务开发和性能优化了；</li></ul></li><li>直播间业务的话主要就参与功能迭代和优化了；</li><li>另外北美的套壳听广播剧的 app，我是 owner，虚线带人；</li></ul><p>我做了那些优化：</p><ol><li><p><strong>通过 IM 的上行下行限流策略，降低公网流量，减少 50% 的公网流量的运维费用；</strong></p></li><li><p><strong>大主播开播导致 IM 服务的 CPU 飚高。通过优化编解码的次数，降低 8% 的 CPU 使用率；</strong></p></li><li><p><strong>线上规律性的 CPU 峰刺</strong>，</p><ol><li>一小时一次的是因为日志量上来了，每个小时日志压缩都会导致 CPU 变高。通过将日志压缩转移到闲时压缩；</li><li>几分钟一次的 CPU 变高，是因为内存泄漏。解决内存泄漏的代码，服务恢复正常；</li></ol></li><li><p><strong>Redis 的大 key 拆分</strong>：</p><ol><li>之前有个备注名的业务，旧的实现是每个用户的备注列表是通过 hash 来实现的，也就是 field 是对方用户 uid，value 是给对方的备注。这样在用户给别人备注非常多的情况下，就会变成一个大 key。后面我给这个 hash 改成 string 来实现了，就消除了大 key；</li></ol></li><li><p><strong>SQL 慢查询优化专项：直播服务相关慢查询次数降低 90 %</strong>；</p></li><li><p>设计手动服务降级策略，保证核心服务的稳定性；</p></li><li><p>大主播开播关播瞬时导致直播服务的 CPU 飚高，然后趋于稳定。通过多级缓存进行优化；</p></li></ol><h2 id="project-introduce" tabindex="-1"><a class="header-anchor" href="#project-introduce"><span>project introduce</span></a></h2><h3 id="im-系统设计" tabindex="-1"><a class="header-anchor" href="#im-系统设计"><span>IM 系统设计</span></a></h3><h4 id="自研背景" tabindex="-1"><a class="header-anchor" href="#自研背景"><span>自研背景</span></a></h4><p>早期我们使用腾讯 IM 收发消息，稳定性、触达率、实时性都没有问题。</p><p>随着 app 的 DAU 越来越高，每月需要花费一笔很大的费用，老板成立 IM 专项，期望逻辑可定制化且费用可控。</p><h4 id="技术选型" tabindex="-1"><a class="header-anchor" href="#技术选型"><span>技术选型</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Kafka,Redis,Netty,Hystrix,Nacos,Motan,Springboot</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="功能设计" tabindex="-1"><a class="header-anchor" href="#功能设计"><span>功能设计</span></a></h4><p><strong>消息优先级</strong></p><ol><li>实时性（如礼物消息要求快速到达，不能丢）；</li><li>限流丢弃（如弹幕文本消息、点赞消息、免费礼物允许限流，维度可以是频率，也可以是直播间人数）；</li></ol><p><strong>QoS</strong></p><ol><li>至少到达 1 次（有可能重复，若未收到确认，则重传消息直至成功）（我们平台用的这个）</li><li>至多到达 1 次（有可能丢消息）</li><li>必达 1 次（不能重复）</li></ol><p><strong>有限时效实时消息（有效期内到达，否则丢弃，不落地=如点赞）</strong></p><p><strong>敏感词检查（是否进行敏感词检查，如点赞/系统消息就不需要检查，文本消息必须检查）</strong></p><p><strong>群消息(群聊/聊天室)</strong></p><ol><li>直播间人数无上限</li><li>直播间在线人数 ==&gt; 支持查询用户在线状态</li><li>直播间成员 ==&gt; 支持查询在线直播间用户列表( ==&gt; 这个在业务上去做)</li><li>消息内容(业务级定义:文本/点赞/礼物/离线消息 ==&gt; 这个目前业务进直播间有拉历史消息)</li><li>支持游客态查询消息(游客态)</li></ol><p><strong>C2C消息(单聊)</strong></p><p>支持用户与用户之间互发消息 （目前消息类型有:拉黑/增删管理员/PK和连麦发起）</p><p><strong>支持环境</strong>(语言)</p><ol><li>Android(Java/Kotlin)</li><li>iOS(ObjectC/Swift)</li><li>PC(C++)</li><li>WEB/H5(JS)</li></ol><p><strong>多端支持</strong></p><ol><li>多端登陆</li><li>多端消息同步(主要需求是主播多端操作的消息同步)</li></ol><p><strong>服务端需求</strong></p><ol><li>消息回调 <ol><li>文本消息</li><li>礼物</li><li>点赞</li></ol></li><li>弹性伸缩</li><li>故障转移</li><li>降级</li><li>监控</li><li>消息染色/路径跟踪</li><li>消息日志</li><li>到达率(统计?)</li></ol><p>消息回调到服务端，主要做的是做消息转发到其他 IM，离线消息 push 等逻辑。</p><h4 id="消息存储模型" tabindex="-1"><a class="header-anchor" href="#消息存储模型"><span>消息存储模型</span></a></h4><p>消息的存储模型分为<strong>写扩散读聚合</strong>、<strong>读扩散写聚合</strong>。</p><figure><img src="/assets/p106170-BGJNvawa.png" alt="读扩散与写扩散" tabindex="0" loading="lazy"><figcaption>读扩散与写扩散</figcaption></figure><p><strong>写扩散模型（推送模型）</strong>：会话产生的消息投递到message_inbox表中，该表类似于个人邮件的收件箱，其中保存着个人的所有会话，会话中的消息按其产生的时间顺序排列。这种存储形式的好处是能实现灵活的消息状态管理，会话中的每条消息在面向不同的接收者时可以呈现出不同的状态。（以更高的存储成本支持更高的更新性能）</p><ul><li>优点： <ul><li><strong>读取效率高</strong>；接收端只需要读取自己的独立的队列，无复杂的聚合逻辑，适合高频读取场景；</li><li><strong>定制化处理</strong>：支持消息删除等个性化操作，不影响其他接受者；</li><li><strong>实时性强</strong>：消息同步延迟低，适合在线推送场景。</li></ul></li><li>缺点： <ul><li><strong>存储成本高</strong>：消息写入与接受者数量成正比，群里场景下写入放大显著（如万人群一条消息写入万次）</li><li><strong>写入压力大</strong>：高并发可能成为系统瓶颈；</li></ul></li><li>适用场景： <ul><li><strong>小型群聊</strong>（成员数 &lt; 500）或单聊；</li><li>对实时性要求高的场景（如在线聊天、通知推送）</li></ul></li></ul><p><strong>读扩散模型（拉取模型）</strong>：消息归属于会话，相当于数据库中存储着一张conversation_message表，其中包含该会话产生的所有消息。这种存储形式的好处是消息入库效率高，只保存会话与消息的绑定关系即可。（数据一致性处理效率和数据变更效率会成为系统性能瓶颈）</p><ul><li>优点： <ul><li><strong>存储成本低</strong>：消息仅存储一次，适合海量消息场景；</li><li><strong>写入效率高</strong>：无写入放大问题，适合大规模群聊（如万人群）</li></ul></li><li>缺点： <ul><li><strong>读取复杂度高</strong>：需多次查询（如消息内容表+用户删除记录表）,易应发 IO 热点。</li><li><strong>实时性依赖缓存</strong>：需结合缓存机制（如 redis）优化高频读取，否则延迟较高。</li></ul></li><li>适用场景； <ul><li>**大型群聊（**成员数 &gt; 10000）</li><li>历史消息漫游、冷数据存储（如 Hbase 归档）</li></ul></li></ul><p><strong>我们系统怎么实现的呢？</strong></p><p>我们 IM 系统业务分为私聊、群聊、直播间聊天；</p><ul><li>其中私聊和群聊（限制 500 人）使用的是写扩散的方式，每个用户有自己的消息箱； <ul><li>用户针对私聊，群聊的消息可以删除，使用写扩散的方式可以很方便实现。</li><li>另外群聊限制人数是 500 人，这时候使用写扩散的方式，写入压力能够接受。</li></ul></li><li>直播间使用的是读扩散的方式，一条直播间消息只存储一条记录。 <ul><li>直播间人数一般比较多，有些直播间会有 5w 人，如果使用写扩散的方式，写入压力很大。</li><li>而且直播间的消息只会在直播间回放的时候才回去查询，没有针对某个用户单独的设置。</li></ul></li></ul><h4 id="系统整体架构" tabindex="-1"><a class="header-anchor" href="#系统整体架构"><span>系统整体架构</span></a></h4><figure><img src="/assets/IM%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9B%BE--Kbb8xDO.png" alt="IM系统架构图" tabindex="0" loading="lazy"><figcaption>IM系统架构图</figcaption></figure><p>主要分为 5 个服务</p><ol><li><strong>长连接网关服务</strong>：承接客户端长连接接入，比如登录、进房、退房等操作，另外是将下行消息写到对端；</li><li><strong>短连接客户端 API 服务</strong>：主要是承接客户端上行消息的入口；</li><li><strong>第三方 API 和 Callback 服务</strong>：主要是承接业务下行消息的入口；</li><li><strong>apiServer 服务</strong>：核心的逻辑处理的服务器；</li><li><strong>群组服务</strong>：主要是群组业务的服务；</li></ol><h4 id="上行消息限流" tabindex="-1"><a class="header-anchor" href="#上行消息限流"><span>上行消息限流</span></a></h4><p>在配置文件中配置哪些上行消息是允许限流的，在实际接受到上行消息时，根据配置走不同的接口。</p><ul><li>允许限流的上行消息：使用 Hystrix 做熔断，提前返回错误信息。</li><li>不允许限流的上行消息，不走限流逻辑。</li></ul><p>Hystrix 的配置：</p><ul><li>主要设置的是 fallback 的降级方法；</li><li>execute.isolation.thread.timeoutMilliseconds = 2000，设置方法的超时时间为 2 秒，超时后标记为 TIMEOUT 状态。</li><li>circuitBreaker.requestVolumeThreshold = 50，在 10 秒窗口内，若请求数 ≥ 50 且错误率超过阈值 50%，熔断器开启。</li><li>线程池属性：核心线程数 2000，队列最大容量 5000。空闲线程最大 2 分钟。</li></ul><h4 id="认证-token-设计" tabindex="-1"><a class="header-anchor" href="#认证-token-设计"><span>认证 token 设计</span></a></h4><table><thead><tr><th style="text-align:left;">版本号(2位)</th><th style="text-align:left;">uid(12位)</th><th style="text-align:left;">appId(4位)</th><th style="text-align:left;">tick(登陆计数器)(3位)</th><th style="text-align:left;">clientId(客户端类型)(1位)</th><th style="text-align:left;">uidtype(用户类型)（1位）</th><th style="text-align:left;">随机字符(8位)</th><th style="text-align:left;">加密串(6位)</th></tr></thead><tbody><tr><td style="text-align:left;">0-2</td><td style="text-align:left;"><code>2-14</code></td><td style="text-align:left;"><code>14-18</code></td><td style="text-align:left;"><code>18-21 </code></td><td style="text-align:left;"><code>21-22</code></td><td style="text-align:left;"><code>22-23</code></td><td style="text-align:left;"><code>23-31</code></td><td style="text-align:left;"><code>31-37</code></td></tr></tbody></table><p>IM 系统接入流程</p><p><strong>从 KilaServer 拿 access_token(1) -&gt; 调用 dispatch -&gt; 获取长连接地址:端口和 access_token(2) -&gt; 长连接登录(进入直播间) -&gt;轮询(收发消息)</strong></p><h4 id="协议设计" tabindex="-1"><a class="header-anchor" href="#协议设计"><span>协议设计</span></a></h4><p>主要包括<strong>请求头</strong>和<strong>请求体</strong>了</p><p>请求头就是一堆 key，value，比如：</p><ul><li>token</li><li>requestid</li><li>机型：安卓或者iOS</li><li>appid</li><li>请求消息的类型，是群发、单发、获取长连接地址、登录等类型；</li></ul><p>对应请求体：</p><ul><li>不同的类型的协议的，需要携带的请求体的 key，value 不一样；</li></ul><h4 id="probuf-序列化" tabindex="-1"><a class="header-anchor" href="#probuf-序列化"><span>probuf 序列化</span></a></h4><p>不是我做的，不看了</p><h4 id="ack-机制-消息必达" tabindex="-1"><a class="header-anchor" href="#ack-机制-消息必达"><span>ACK 机制&amp;消息必达</span></a></h4><p>如何保证消息的 100% 必达？也就是至少投递一次。</p><p><strong>消息分级</strong>：</p><ul><li>首先我们系统里面针对消息做了优先级分级，比如私聊、群聊消息都高优先级必达的，直播间的消息如何是付费消息（送礼等）、主播和房管发的消息是必须必达的。</li></ul><p><strong>ACK 机制</strong>：</p><ul><li>另外我们针对消息是否需要 ACK，重要的消息给客户端返回一个需要响应 ACK 的标记，客户端接收到消息后就会发送一个 ACK 消息到 IM 系统，用于统计消息的触达率。</li></ul><p><strong>如何保证消息必达</strong>：应用层确认 + 消息可靠性传递的 4 个消息</p><img src="/assets/image-20240305182354462-BRd9uw41.png" alt="image-20240305182354462" style="zoom:67%;"><p>im 系统是通过超时、重传、确认、去重的机制来保证消息的可靠投递，不丢不重</p><ul><li>客户端维护一个超时和重传的 ACK 队列，当指定时间内没有收到服务端的 ACK，则会重新发送消息；</li><li>客户端需要根据消息的唯一性 msgId 进行去重校验；</li></ul><p><strong>成果</strong>：经过线上验证 IM 系统的私聊和群聊消息的触达率 100%，直播间的到达率 99.9%。</p><h4 id="压测数据参考" tabindex="-1"><a class="header-anchor" href="#压测数据参考"><span>压测数据参考</span></a></h4><p><strong>服务介绍：</strong></p><ul><li>api-server(收发消息服务层，登录session，房间成员、关系/消息收发消息等业务处理)</li><li>api-exchange(第三方消息回调，包含腾讯/微博的回调以及回调给KilaServer的消息)</li><li>center-connect (上行发消息，称短连接API服务)</li><li>api-connect(下行收消息，称长连接)</li></ul><p>下行(收消息)</p><p>压测环境 阿里云ECS 16核 32G 专用网络 最大100M，redis(pub/sub 4台 1G 4.0高配2W连接数)</p><p>api-sever 1台(192.168.5.55)， api-connect 1台(192.168.5.34)，center-connect 1台 独立机(192.168.5.35)，redis(pub/sub 4台 1G 4.0高配2W连接数)</p><ul><li>单台 ECS 空消息情况下 TCP 连接数峰值 2.5W (由于测试客户端限制，还没有达到最大值，预估 3W 左右）</li><li>单台 ECS 空消息 WebSocket 连接数峰值 2W (由于测试客户端限制，还没有达到最大值，预估 2.5W 左右）</li><li>有消息收发的情况下，连接数预估 1W 左右，因为消息会占用很大的网络流量(<strong>微博的机器是按照单实例 1W 的连接分布</strong>)</li></ul><h4 id="im-系统部署" tabindex="-1"><a class="header-anchor" href="#im-系统部署"><span>IM 系统部署</span></a></h4><p>优化前：</p><ul><li>长连接：41 台，按一台抗 1w 长连接，抗 40w 用户同时在线轻轻松松；</li><li>短连接：6 台；</li><li>群组服务：6 台；</li><li>thirdparty 第三方：3 台；</li><li>service 核心服务：6 台；</li></ul><h3 id="im-系统设计-2" tabindex="-1"><a class="header-anchor" href="#im-系统设计-2"><span>IM 系统设计 2</span></a></h3><h4 id="平台支持" tabindex="-1"><a class="header-anchor" href="#平台支持"><span>平台支持</span></a></h4><ul><li>Android、iOS、Mac、Windows、Web、H5、小程序、嵌入式 Linux（ARM，MIPS）</li><li>服务端（含管理类 API 接口）、是否有 Demo 应用以及源码、是否有视频教程、是否提供 UI 组件</li></ul><h4 id="部署节点" tabindex="-1"><a class="header-anchor" href="#部署节点"><span>部署节点</span></a></h4><ul><li>公有云</li><li>专有云</li><li>私有云：企业将系统直接部署到企业自己的服务器上，数据直接保存在本地。即时通信 IM 已支持私有化部署功能，可以协助企业进行私有化版本的部署、实施、运营维护。</li><li>是否支持海外节点</li></ul><h4 id="消息类型" tabindex="-1"><a class="header-anchor" href="#消息类型"><span>消息类型</span></a></h4><ul><li>文本消息：消息内容是普通文本</li><li>图片消息：消息内容为图片 URL 地址、尺寸、图片大小等信息</li><li>表情消息：表情消息为开发者自定义</li><li>语音消息：语音数据需要提供时长信息，以秒为单</li><li>地理位置消息：消息内容为地理位置标题、经度、纬度信息</li><li>文件消息：消息内容为文件的 URL 地址、大小、格式等信息，格式不限</li><li>短视频消息：消息内容为视频文件的 URL 地址、时长、大小、格式等信息</li><li>自定义消息：开发者自定义的消息类型，例如红包消息、石头剪刀布等形式的消息</li><li>系统通知消息：包含内置的系统通知消息和开发者自定义系统通知消息</li><li>群 Tips 消息：系统性通知消息，例如有成员进出群组，群的描述信息被修改，群成员的资料发生变化等</li><li>透传消息：透传消息可视为一条指令，通过发送这条指令给对方，通知对方要执行的操作，对方收到消息可自定义处理；</li></ul><h4 id="消息功能" tabindex="-1"><a class="header-anchor" href="#消息功能"><span>消息功能</span></a></h4><ul><li>消息下载：App 管理员可以通过该接口获取 App 中最近7天某天某小时的所有单发或群组消息记录</li><li>离线消息：用户登录后退到后台，当有用户给其发消息时，即时通信 IM 支持离线推送</li><li>漫游消息：在新设备登录时，将服务器记录(云端)的历史消息存储进行同步</li><li>多端同步：多终端消息同步，可同时收到消息</li><li>历史消息：支持本地历史消息和云端历史消息</li><li>消息撤回：撤回投递成功的消息，默认撤回 2 分钟内的消息。撤回操作仅支持单聊和群聊消息，不支持直播群的撤回</li><li>已读回执：查看点对点会话中对方的已读未读状态</li><li>消息转发：将消息转发给其他用户或群组</li><li>@功能：群内 @ 消息与普通消息没有本质区别，仅是在被 @ 的人在收到消息时，需要在 UI 上做特殊处理</li><li>正在输入：可以通过在线消息实现</li><li>离线推送：支持苹果 APNs、小米推送、华为推送、魅族推送、OPPO 推送、vivo 推送、Google FCM 推送</li><li>消息删除：使用消息的 remove 方法可以在本地删除消息</li><li>红包功能：红包消息与@消息类似</li><li>全员推送：基于即时通信 IM 通信架构实现的一组 REST API，用以支持 App 应用的全员推送、标签推送、属性推送等消息推送需求，客户端可通过 SDK 在线推送、离线推送（Android 后台通知和 APNs）接收推送的消息</li><li>本地消息搜索：支持搜索好友，搜索群组、群成员；搜索消息，按照会话分组</li><li>第三方回调：发送方消息发出后，应用服务器可据此进行必要的数据同步，或者根据业务需求干预事件的后续处理流程，比如鉴权校验，校验通过后方进行投递，否则消息不投递</li><li>离线推送：离线推送是指当应用被杀死时，通过厂商推送接收消息。iOS 设备使用苹果推送通知服务（APNs），Android 设备为谷歌云消息传递服务（FCM）、华为推送、小米推送、魅族推送、OPPO 推送和 vivo 推送。</li></ul><h4 id="关系链功能" tabindex="-1"><a class="header-anchor" href="#关系链功能"><span>关系链功能</span></a></h4><ul><li>查找好友：可通过用户账号 ID 查找好友</li><li>申请添加好友：要选择默认是否需要申请理由，目前是默认不需要</li><li>添加好友：发送添加好友请求</li><li>导入好友：支持批量导入单向好友</li><li>更新好友：支持批量更新同一用户的多个好友的关系链数据</li><li>删除好友：成为好友后可以删除好友</li><li>获取所有好友：获取所有好友，默认只拉取基本资料</li><li>同意/拒绝好友：收到请求加好友请求的系统通知后，可以通过或者拒绝</li><li>添加用户到黑名单：把任意用户拉黑，如果此前是好友关系会解除好友关系</li><li>移除黑名单：把用户从黑名单中移除</li><li>获取黑名单列表：拉取用户黑名单列表</li><li>好友备注：成为好友后可以给好友备注</li><li>设置好友自定义资料：最多20个好友自定义字段</li><li>创建好友分组：创建分组时，可以同时指定添加的用户，同一用户可以添加到多个分组</li><li>删除好友分组：删除好友分组</li><li>校验好友：支持批量校验好友关系</li><li>校验黑名单：支持批量校验黑名单</li><li>添加好友到某分组：将好友添加到好友分组</li><li>从某分组删除好友：将好友从好友分组中删除</li><li>重命名好友分组：重命名好友分组</li><li>获取指定好友分组信息：获取指定的好友分组</li><li>获取所有好友分组：获取所有分组信息，另外，通过获取所有好友也可以获取分组信息</li><li>关系链资料存储：SDK 可以对关系链资料进行存储</li><li>好友资料变更系统通知：好友资料变更可以收到系统通知</li><li>关系链变更系统通知：关系链变更可以收到系统通知</li></ul><h4 id="数据统计" tabindex="-1"><a class="header-anchor" href="#数据统计"><span>数据统计</span></a></h4><ul><li>活跃用户数：与服务器产生连接交互的去重用户数</li><li>新增注册用户数：新增注册 ID 数量</li><li>累计注册用户数：查看所有注册用户数</li><li>上行消息数：可以选择时间查看上行消息数</li><li>发送消息人数：可以选择时间查看发送消息人数</li><li>最高同时在线人数：可以选择时间查看在线同时在线人数</li><li>单聊上行消息数：可以选择时间查看单聊上行消息数</li><li>单聊发消息人数：可以选择时间查看单聊发消息人数</li><li>群聊上行消息数：可以选择时间查看群组中上行消息数</li><li>群聊发消息人数：可以选择时间查看群组中发消息的人数</li><li>发消息群组数：可以选择时间查看发消息群组数</li><li>新增群组数：可以选择时间查看新增群组数</li><li>累计群组数：可以选择时间查看累计群组数</li><li>导出数据：可以选择时间导出数据</li></ul><h4 id="在线状态" tabindex="-1"><a class="header-anchor" href="#在线状态"><span>在线状态</span></a></h4><p>每个用户的状态类型有以下三种：</p><ul><li>前台运行状态（Online）</li><li>后台运行状态（PushOnline）</li><li>未登录状态（Offline）</li></ul><blockquote><p>后台运行状态（PushOnline）只有手机端（Android、iOS、iPad、Mac）会存在，PC、Linux、小程序和 Web 端不存在该种状态。</p></blockquote><ul><li><p><strong>前台运行状态（Online）</strong>：是指客户端和即时通信 IM 服务端保持有顺畅的 TCP 网络连接，客户端可以发消息给即时通信 IM 服务端，也可以收到来自即时通信 IM 服务端推送的消息。**当用户打开 App 后，状态即为前台运行状态（Online）。**App 启动后，客户端和即时通信 IM 服务端建立 TCP 长连接，即时通信 IM 服务端保存客户端的在线信息，例如客户端的网络链路信息，客户端的平台版本等。App 在运行过程中，IM SDK 会定时发送心跳来确认用户的在线状态。</p></li><li><p><strong>后台运行状态（PushOnline）</strong>：是指客户端和即时通信 IM 服务端的 TCP 长连接断开。此时可收到消息的离线推送。 以下场景用户的状态为后台运行状态（PushOnline）：</p><ul><li>用户使用完 App ，把 App 切后台后进程被手机操作系统 kill 掉，或者用户主动 kill 掉 App 进程。 如果 App 在手机操作系统的保活白名单中，用户把 App 切后台，进程并不会被手机操作系统 kill 掉。此时状态仍然为前台运行状态（Online）。前台运行状态（Online）和后台运行状态（PushOnline）判断的标准之一是 App 进程是否被 kill ，即客户端和即时通信 IM 服务端的 TCP 长连接是否断开。</li><li>用户主动关闭客户端网络（例如打开手机飞行模式），或者客户端网络完全不可用（例如进入完全没有网络信号的隧道）。 在这种特殊情况下，客户端连 TCP 协议的 FIN 包或 RST 包都无法发出，即时通信 IM 服务端需要等待 400 秒后发现心跳包超时，状态才会变成后台运行状态（PushOnline）。</li></ul></li><li><p><strong>未登录状态（Offline）</strong>，是指用户没有输入账号和密码登录前的状态，此时无法收到消息的在线推送，也无法收到消息的离线推送。 以下场景用户的状态为未登录状态（Offline）：</p><ul><li>用户主动登出，或下载 App 后还未进行过登录时。</li><li>用户状态变成后台运行状态（PushOnline）后，7天内没有再登录过，此时状态变为未登录状态（Offline）。</li></ul></li></ul><h4 id="状态变更感知的实时性" tabindex="-1"><a class="header-anchor" href="#状态变更感知的实时性"><span>状态变更感知的实时性</span></a></h4><p><strong>Android/iOS/iPad/PC/Mac/Linux</strong></p><p>对于绝大多数情况，用户状态的变化都能实时感知，例如：</p><ul><li>用户主动登录，状态变成前台运行状态（Online）。</li><li>用户主动登出, 状态变成未登录状态（Offline）。</li><li>用户主动 kill 客户端进程，或者用户切后台后，客户端进程被手机操作系统 kill 掉，状态变成后台运行状态（PushOnline）。</li></ul><p>只有以下一种特殊情况，IM 云服务器需要等待400秒的心跳超时时间才能感知状态变更： 当网络完全不可用时，客户端连 TCP 协议层的 FIN 包或 RST 包都无法发出时，IM 云服务器需要等待400秒的心跳超时时间才能感知到状态变成后台运行状态（PushOnline）。常见的场景有用户主动关闭客户端的网络（例如开启手机的飞行模式），或者进入完全没有网络信号的隧道。</p><p><strong>Web</strong></p><p>用户主动登录 Web 端时，IM 云服务器可以实时感知到状态变成前台运行状态（Online）。</p><p>各种场景的退出/断线的状态变更实时性如下：</p><ul><li>直接关闭页面，可以实时感知，状态变成未登录状态（Offline）。</li><li>页面不关闭时，网络断开，需要 60s 才能感知到，状态变成未登录状态（Offline）。</li><li>主动调用 destroy 接口，可以实时感知，变成未登录状态（Offline）。</li></ul><p><strong>小程序</strong></p><p>用户主动登录小程序端时，IM 云服务器可以实时感知到状态变成前台运行状态（Online）。</p><p>各种场景的退出/断线的状态变更实时性如下：</p><ul><li>点右上角退出，5s 内感知到状态变成未登录状态（Offline）。</li><li>断网(如手机开启飞行模式) ，60s 感知到状态变成未登录状态（Offline）。</li><li>微信切后台，30s 左右状态变成未登录状态（Offline）。</li><li>杀掉微信进程，可以实时感知，变成未登录状态（Offline）。</li><li>主动调用 destroy 接口，可以实时感知，变成未登录状态（Offline）。</li></ul><h4 id="多端登录" tabindex="-1"><a class="header-anchor" href="#多端登录"><span>多端登录</span></a></h4><ul><li>互踢：IM SDK 在同时登录多个终端（如同时登录 PC、Android）时，会进行互踢，只有最后一个登录的设备可以在线，之前登录的都会被踢下线；</li><li>同时在线：Android、iPhone、iPad、Windows、Mac、Web；</li></ul><h4 id="登录逻辑" tabindex="-1"><a class="header-anchor" href="#登录逻辑"><span>登录逻辑</span></a></h4><img src="/assets/%E8%B4%A6%E5%8F%B7%E9%9B%86%E6%88%90%E4%B8%8E%E7%99%BB%E5%BD%95%E5%8E%9F%E7%90%86%E6%96%B0%E5%9B%BE-E2X-KhFi.png" alt="img" style="zoom:100%;"><h4 id="其他" tabindex="-1"><a class="header-anchor" href="#其他"><span>其他</span></a></h4><ul><li>聊天室消息优先级；</li><li>反垃圾；</li><li>数据加密；</li><li>协议设计；</li></ul><p>群组和聊天室的区别：</p><p>群组：</p><ul><li>群组是支持多人沟通的即时通讯系统，<strong>成员关系相对稳定</strong>。所有群成员可在群中收发送消息。<strong>当群成员离线时，可以收到推送消息</strong>。群组分为公开群和私有群，公开群可以被搜索到，非群成员可以加入；私有群不能被搜索到，需要群主或群管理员添加用户进入。群组成员支持多种角色：群主、群管理员、群成员。群组提供丰富的管理能力，例如，群组禁言、黑名单和白名单等。</li></ul><p>聊天室：</p><ul><li>聊天室是支持多人加入的组织。<strong>聊天室中的成员没有固定关系</strong>，用户离线后，超过 2 分钟会自动退出聊天室。聊天室成员在离线后，不会收到推送消息。聊天室可以应用于直播、消息广播等；</li></ul><h3 id="im-过滤器链-异常处理-url-映射" tabindex="-1"><a class="header-anchor" href="#im-过滤器链-异常处理-url-映射"><span>IM 过滤器链，异常处理，url 映射</span></a></h3><p>Spring 容器初始化完成后，我们可以监听初始化完成的事件，<strong>ApplicationListener 接口</strong>，监听 ContextRefreshEvent 事件</p><ul><li>初始化过滤器链；</li><li>初始化 url 映射；（表示消息类型对应的处理器方法的映射关系）</li><li>初始化异常处理器；</li></ul><h4 id="过滤器链" tabindex="-1"><a class="header-anchor" href="#过滤器链"><span>过滤器链</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Map</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Object</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> beansWithAnnotation </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> applicationContext</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getBeansWithAnnotation</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">WesyncFilter</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>获取带有 @WesyncFilter 注解的所有类的 beanName 和实例，然后给这些过滤器通过 @Order 排序一下，放到代表过滤器链的集合 wesyncFilterChain 中，按照优先级排序。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> WesyncFilterChain</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> wesyncFilterChain </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在真正的上行消息逻辑前后，调用过滤器链的 before 和 after 方法。</p><h4 id="url-映射" tabindex="-1"><a class="header-anchor" href="#url-映射"><span>url 映射</span></a></h4><p>获取带有 @WesyncURL 的所有类的 beanName 和实例，带了 @WesyncURL 注解的就说明是有协议和处理器方法的映射关系的，需要找到对应的方法去处理这个协议。</p><p>根据前面查找到的 @WesyncURL 的类的 class 文件，获取他的父类，或者接口，遍历这些类中的所有方法，查看上面是否有 @WesyncURL 注解。</p><p>映射信息如下：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> UrlMapping</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 协议名</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> tag</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 协议</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    Object</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> realBean</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 实例</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> realMethod</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 协议对应的方法</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // ......</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>初始化映射关系：</p><ul><li>第一步：找到所有 @WesyncURL 注解的 bean；</li><li>第二步：通过 Spring 提供的反射工具类 ReflectionUtils.doWithMethods，找到所有带 @WesyncURL 的 bean 中的带 @WesyncURL 注解的方法。</li><li>最后就是将协议对应的 class 和 method 确定好了，真正消息上行时，通过 class 和 method 去反射调用方法去处理数据。</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> initUrlMappings</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ApplicationContext</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> applicationContext) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (urlTagMapping </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        logger</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">debug</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;begin init urlMappings..&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        urlTagMapping </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> HashMap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> UrlMapping</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Map</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Object</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> beansWithAnnotation </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> applicationContext</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getBeansWithAnnotation</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">WesyncURL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        UrlMapping</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> urlMapping </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> UrlMapping</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Object</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> realBean </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> key </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> beansWithAnnotation</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">keySet</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            realBean </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> beansWithAnnotation</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            urlMapping</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setRealBean</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(realBean);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">            initHandlerMethods</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">realBean</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getClass</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(),</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> urlTagMapping</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> urlMapping)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        logger</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">debug</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;end init urlMappings...&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="直播间多级缓存优化" tabindex="-1"><a class="header-anchor" href="#直播间多级缓存优化"><span>直播间多级缓存优化</span></a></h3><h4 id="突发流量多级缓存优化" tabindex="-1"><a class="header-anchor" href="#突发流量多级缓存优化"><span>突发流量多级缓存优化</span></a></h4><p>背景：由于大主播开关播，用户同时进入直播间会有大量的接口调用，导致系统 QPS 激增，对系统的冲击比较大，为了应对突发流量，设计了直播间的多级缓存优化。</p><p>目前系统中有基本上所有数据都有 Redis 缓存层，但是 QPS 调用量大的接口里面可能需要查询各种各样的信息，导致接口的跨度比较大，可能会查询很多次 Redis 或者 DB。</p><p>比如接口需要返回一个 RoomStart 的对象，但是这个对象的数据组装来自很多个 service 的接口调用，考虑提前将数据组装好，将 RoomStart 对象存放到本地缓存和 Redis 中，就是一个镜像数据。（前提是这些数据的更新频率不高）</p><p>主要流程如下，两层缓存；</p><ul><li>本地缓存：并为存储所有数据，而是存储上次刷新时间戳，实现定时刷新 Redis 缓存的目的；</li><li>Redis 缓存：当本地缓存的刷新时间戳失效后，调用 Service 接口刷新 Redis 缓存；</li></ul><h4 id="本地缓存回种超时优化-异步刷新" tabindex="-1"><a class="header-anchor" href="#本地缓存回种超时优化-异步刷新"><span>本地缓存回种超时优化（异步刷新）</span></a></h4><p>背景：礼物的数据更新的频率不高，使用本地缓存去存储，但是假如本地缓存过期回种的时候只会允许一个线程去刷新数据，其他线程就会等待，导致 RPC 超时，给用户不好的体验。</p><p>优化：针对礼物这种静态数据但请求量大的业务场景，通过异步刷新本地缓存 , 保证本地缓存的数据是最新的。</p><ul><li>查询时先获取上次刷新的时间 , 如果到了需要刷新的时间仍然返回缓存中的结果, 同时启动异步刷新缓存的任务；</li><li>这样可以避免在用户请求线程中回种导致用户请求超时；</li><li>例如有些业务 比如查询主播自定义礼物单次从查询回种需要查询 1900+ 条数据回种必然超时可以使用这个工具类异步刷新本地缓存；</li></ul><p>主要优化思路：</p><ul><li>一个业务需要保存两个本地缓存的 key，一个实际数据和上次刷新时间；</li><li>如果从本地缓存没有获取到数据，那么还是要同步等待数据刷新；</li><li>如果从本地缓存获取到了数据，但是距离上次刷新时间已经到期了。此次会返回旧数据，然后异步刷新数据；</li></ul><h4 id="本地缓存的问题" tabindex="-1"><a class="header-anchor" href="#本地缓存的问题"><span>本地缓存的问题</span></a></h4><p>问题：本地缓存会出现 「数据漂移」的现象。具体体现为集群中的多个服务中的本地缓存的刷新时机不一样，两台机器内的本地数据的不一样，用户两次请求分别打到了这两个机器上，导致用户看到的效果不同。</p><p>解决：无法解决，使用本地缓存的场景就是为了存储数据变更频率不高的场景，那么对这种数据不一致性是可以接受的。</p><h3 id="国际版迁移" tabindex="-1"><a class="header-anchor" href="#国际版迁移"><span>国际版迁移</span></a></h3><p>没啥好说的，就是重构一下代码，数据隔离兼容多 app，为后续新建 app 缩短时间。</p><h3 id="慢查询优化" tabindex="-1"><a class="header-anchor" href="#慢查询优化"><span>慢查询优化</span></a></h3><p><strong>慢查询优化主要有下面几个方向：</strong></p><ul><li>重新设计索引；</li><li>优化查询语句；</li><li>建立缓存，对于变化频率不大数据可以考虑建立 本地缓存+定时刷新 的策略；</li><li>冷数据备份；</li></ul><p><strong>本次慢查询优化，降低了 90% 的慢查询次数，主要就是按照上面的几个策略去处理的：</strong></p><ul><li>有的 SQL 并不需要查所有的字段，只查询需要的字段；</li><li>有的查询无法走索引，所以需要重新设计索引，优化查询效率；</li><li>有的慢查询虽然设计了缓存，但是它过期时间比较快，导致访问数据库的次数也比较多，针对一些变化频率不高，或者时效性不高的数据可以直接存在 redis 中，不设置过期时间；</li><li>对于一些记录类型的表，可以做冷数据备份，因为一般记录性的操作端上露出的也就一年或者半年的数据；</li></ul><h3 id="内存泄漏" tabindex="-1"><a class="header-anchor" href="#内存泄漏"><span>内存泄漏</span></a></h3><p><strong>内存泄漏产生背景：</strong></p><ul><li>背景：我们需要统计一下直播间维度的某个数据，使用我们的一个打日志的工具类，传入某个指标的key，就会定时打印统计日志了；</li></ul><p><strong>上线一台机器后发现问题：</strong></p><ul><li>CPU 每隔几分钟就会打满，十分有规律；</li><li>通过服务器的监控和 TOP 命令的查询，发送就是服务器频繁 GC，垃圾回收器占满了 CPU；</li></ul><p><strong>定位问题：</strong></p><ul><li>很明显就是此处加的统计代码导致的内存泄漏；</li><li>首先查看服务 JVM 的一些信息，使用 jstat、jmap 等命令，jmap 可以查看堆中那个对象占用比较大；</li><li>发现是统计的日志打印的工具类中的一个 Map 非常大，很明显就是没有移除 Map 的元素导致内存泄漏了。</li></ul><p><strong>处理：</strong></p><ul><li>因为工具类中有个隐藏的 Map，而且它对外没有提供 remove 方法，导致越来越大，发生内存泄漏。</li><li>工具类增加该 Map 的移除方法，解决；</li></ul><h3 id="cpu-峰刺问题" tabindex="-1"><a class="header-anchor" href="#cpu-峰刺问题"><span>CPU 峰刺问题</span></a></h3><p><strong>在我工作的时候遇到的 CPU 的蜂刺问题不少，具体遇到的有下面的情况：</strong></p><ol><li>大主播开播导致的服务器的 CPU 的飙升，对于服务来说瞬时 QPS 可能会突然翻好几倍，会导致服务请求堆积，响应变慢： <ul><li>Push 服务 CPU 飙升；</li><li>涉及到的 Redis CPU 飙升；（这可能会影响到在该 Redis 实例上的其他业务的响应速度）</li></ul></li><li>发生内存泄漏导致 CPU 规律性的飙升，就是垃圾回收线程在清理垃圾；</li><li>由于某些定时操作导致 CPU 的规律性飙升，例如某些业务的定时任务，也有可能是日志定时压缩导致的 CPU 飙升；</li></ol><p><strong>大主播开关播的 CPU 峰刺是怎么优化的呢？</strong></p><ul><li>定位问题和数据分析：通过监控分析 CPU 激增前后的接口的 QPS 的变化情况，定位那些接口导致的 CPU 激增； <ul><li>定位到了导致开关播峰刺的主要接口 8 个；</li><li>双端关播接口存在差异，关播时安卓比 iOS 多调用了15个接口；</li><li>关播瞬间 Android 多调用的接口瞬时 QPS 占总 QPS 的 55%；</li></ul></li><li>优化方向： <ul><li>通过链路追踪来分析是接口的跨度那部分占比大，减少循环 RPC 或者访问 Redis 的情况；</li><li>针对 Redis 的热 key 和大 key 进行拆分，分散热点数据，也可以将拆分后的 key 部署到 redis 集群上；</li></ul></li><li>确定优化方案： <ul><li>将大主播开关播使用的接口数据整合到 Redis 和本地缓存中；</li><li>在开播、关播、数据变更时预先加载数据到缓存中，同时定时刷新缓存数据；</li><li>减少不必要的接口调用，精简接口字段；</li><li>缓存采用 “算法路由 + 多节点负载” 的架构，保证请求均匀分发到多个实例，避免单节点压力；</li></ul></li></ul><h2 id="project-qps" tabindex="-1"><a class="header-anchor" href="#project-qps"><span>project QPS</span></a></h2><p>广播剧服务：</p><ul><li>单台机器：闲时平均 60，高峰期平均 160</li><li>总体：闲时平均 1800，高峰期平均 4800</li><li>采样 24 台</li></ul><p>直播服务：</p><ul><li>单台机器：闲时平均 50，高峰期平均 130</li><li>总体：闲时平均 1250，高峰期平均 3250</li><li>采样 25 台机器</li></ul><p>核心 service 服务，Motan RPC TPS：</p><ul><li>采样 49 台</li><li>单台机器：闲时平均 400，高峰期平均 1100</li><li>总体：闲时平均 24500，高峰期平均 53900</li></ul><p>IM 服务 QPS：</p><ul><li>apiserver 总体：闲时平均 166，高峰期平均 1242</li><li>thirdparty 总体：闲时平均 100，高峰期平均 574</li><li>长连接 总体：闲时平均 1000，高峰期平均 4078</li><li>短连接 总体：闲时平均 116，高峰期平均 450</li></ul><h2 id="im-down-stream-data" tabindex="-1"><a class="header-anchor" href="#im-down-stream-data"><span>IM down stream data</span></a></h2><p>总体：</p><ul><li>闲时平均每秒 10000 消息下发</li><li>高峰期平均每秒 100 0000 消息下行</li></ul><p>抽样单台：</p><ul><li>闲时平均每秒 500 消息下发</li><li>高峰期平均每秒 5 0000 消息下行</li></ul><h2 id="jvm-data" tabindex="-1"><a class="header-anchor" href="#jvm-data"><span>JVM data</span></a></h2><p>线上 service 使用的垃圾回收器</p><p>进程信息</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>tomcat   13195     1 88 06:46 ?        03:25:32 /opt/java/jdk/bin/java -Xms12g -Xmx12g -Xmn3g -Xss512k -XX:+ExplicitGCInvokesConcurrent -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=70 -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=5 -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=15 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/data/soft/logs/bak -Xloggc:/data/soft/logs/gc.log.20230703_064617 -Djava.net.preferIPv4Stack=true -classpath /手动打码/WEB-INF/classes:/手动打码/WEB-INF/lib/* com.uxin.zb.bootstrap.Provider</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>根据提供的信息，这是关于Tomcat服务器的启动命令和参数配置。下面是对该命令和参数的分析：</p><ul><li><code>-Xms12g</code>：设置JVM的初始堆大小为12GB。</li><li><code>-Xmx12g</code>：设置JVM的最大堆大小为12GB。</li><li><code>-Xmn3g</code>：设置新生代（Young Generation）的大小为3GB。</li><li><code>-Xss512k</code>：设置线程栈大小为512KB。</li><li><code>-XX:+ExplicitGCInvokesConcurrent</code>：启用显式触发并发垃圾回收。</li><li><code>-XX:+UseParNewGC</code>：指定使用并行的新生代垃圾回收器。</li><li><code>-XX:+UseConcMarkSweepGC</code>：指定使用并发标记-清除（CMS）垃圾回收器。</li><li><code>-XX:CMSInitiatingOccupancyFraction=70</code>：设置CMS垃圾回收器触发标记阈值为70%。</li><li><code>-XX:+UseCMSCompactAtFullCollection</code>：指定在进行完整垃圾收集时使用压缩算法。</li><li><code>-XX:CMSFullGCsBeforeCompaction=5</code>：设置在进行压缩前进行完整垃圾回收的次数为5次。</li><li><code>-XX:+PrintGCDetails</code>：打印详细的垃圾回收信息。</li><li><code>-XX:+PrintGCDateStamps</code>：打印垃圾回收事件的日期时间戳。</li><li><code>-XX:SurvivorRatio=8</code>：设置幸存者空间（Survivor Space）与伊甸园空间（Eden Space）的大小比例为8:1。</li><li><code>-XX:MaxTenuringThreshold=15</code>：设置对象晋升到老年代的最大年龄阈值为15。</li><li><code>-XX:+HeapDumpOnOutOfMemoryError</code>：在发生OutOfMemoryError时生成堆转储文件。</li><li><code>-XX:HeapDumpPath=/data/soft/logs/bak</code>：指定堆转储文件的路径为<code>/data/soft/logs/bak</code>。</li><li><code>-Xloggc:/data/soft/logs/gc.log.20230703_064617</code>：将GC日志输出到<code>/data/soft/logs/gc.log.20230703_064617</code>文件中。</li><li><code>-Djava.net.preferIPv4Stack=true</code>：设置Java虚拟机首选使用IPv4网络栈。</li><li><code>-classpath /手动打码/WEB-INF/classes:/手动打码/WEB-INF/lib/*</code>：指定类路径，包括应用程序的类和依赖库。</li><li><code>com.uxin.zb.bootstrap.Provider</code>：要启动的主类。</li></ul><h2 id="interview-question" tabindex="-1"><a class="header-anchor" href="#interview-question"><span>interview question</span></a></h2><h3 id="didichuxing-1-打车业务" tabindex="-1"><a class="header-anchor" href="#didichuxing-1-打车业务"><span>didichuxing 1 打车业务</span></a></h3><ul><li>项目：你负责那些业务，挑一个你负责的业务说说？</li><li>项目：说一下你的 IM 服务的架构，以及发送消息的整个流程？</li><li>说一下线程池的各个参数的作用，你是怎么设置的？为什么要这样设置？</li><li>多个线程同时执行，多个线程的任务都执行完后，执行一个任务，说思路？</li><li>算法：简单的二进制转换的题；</li></ul><h3 id="didichuxing-2-打车业务" tabindex="-1"><a class="header-anchor" href="#didichuxing-2-打车业务"><span>didichuxing 2 打车业务</span></a></h3><ul><li>项目：你负责那些业务，挑一个你负责的业务说说？</li><li>慢查询优化怎么做的，有哪些方向？</li><li>那些会导致慢查询？</li><li>TCP 断开过程？timewait 在那边？它的作用是什么？</li><li>https 为什么安全？</li><li>一个日志文件，如何用 shell 脚本查询出出现频率最高的 IP 地址；</li><li>滴滴打车，用户打完车后，累加此次的打车里程，需要准确的计算他超过了多少个百分比的用户，怎么设计？</li><li>短链如何设计，如何存储？</li><li>算法：简单的双指针题目；</li></ul><h3 id="xiaohongshu-1-im-方向" tabindex="-1"><a class="header-anchor" href="#xiaohongshu-1-im-方向"><span>xiaohongshu 1 IM 方向</span></a></h3><ul><li>说一下你们的 IM 系统架构，发消息的流程；</li><li>Netty 有那些组件，它们的作用是什么？</li><li>Netty 服务端的启动流程；</li><li>ChannelHandler 如何绑定一个 EventLoop 线程；</li><li>你们 IM 的 ACK 机制是怎么做的；</li><li>说一下你们 IM 的消息的存储机制；</li><li>长连接 CPU 优化怎么做的；</li><li>私聊如何确保一定送达，发送网络不通的情况如何处理；</li><li>ReentrantLock 原理？AQS 原理？</li><li>写一个两个线程交替打印数据的题目；</li></ul><h3 id="ali-sumaitong-1-这个人妥妥的傻呗" tabindex="-1"><a class="header-anchor" href="#ali-sumaitong-1-这个人妥妥的傻呗"><span>Ali sumaitong 1 这个人妥妥的傻呗</span></a></h3><ul><li>说一下你们 IM 服务？</li><li>说一下你的直播服务？主要做什么的，有那些业务模块？</li><li>说一下你们线程池怎么用的，拒绝策略是什么样的？拒绝的任务怎么处理？</li><li>你们怎么保证送礼业务的最终一致性；</li><li>你做了那些优化？我说了优化机器的 CPU 使用率？</li><li>为什么大主播开播你们服务的 CPU 就上去了？QPS 增高和 CPU 有什么联系？</li><li>你怎么发现 CPU 增高的？ arthas 的 profiler 火焰图；</li><li>CPU 的峰刺你是怎么优化的？怎么定位的？</li><li>你做过 JVM 调优吗？有线上定位 JVM 问题的经验吗？</li><li>你说解决了内存泄露，为什么内存泄漏了，有哪些 GC Root 对象，整体分析一下；</li></ul><h3 id="ali-飞猪度假" tabindex="-1"><a class="header-anchor" href="#ali-飞猪度假"><span>Ali 飞猪度假</span></a></h3><h3 id="ali-飞猪-im" tabindex="-1"><a class="header-anchor" href="#ali-飞猪-im"><span>Ali 飞猪 IM</span></a></h3><h3 id="ali-飞猪度假-1" tabindex="-1"><a class="header-anchor" href="#ali-飞猪度假-1"><span>Ali 飞猪度假</span></a></h3><h3 id="meituan直播" tabindex="-1"><a class="header-anchor" href="#meituan直播"><span>meituan直播</span></a></h3><h3 id="didi-beijing-打车" tabindex="-1"><a class="header-anchor" href="#didi-beijing-打车"><span>didi beijing 打车</span></a></h3><h3 id="保险" tabindex="-1"><a class="header-anchor" href="#保险"><span>保险</span></a></h3><h3 id="alipay-直播" tabindex="-1"><a class="header-anchor" href="#alipay-直播"><span>alipay 直播</span></a></h3><h3 id="hello-iot" tabindex="-1"><a class="header-anchor" href="#hello-iot"><span>hello iot</span></a></h3><h3 id="zijie-直播广告" tabindex="-1"><a class="header-anchor" href="#zijie-直播广告"><span>zijie 直播广告</span></a></h3></div><!----><!----><!--[--><h2 id="doc-contributors" tabindex="-1"><a href="#doc-contributors" class="header-anchor"><span>Contributors</span></a></h2><div class="vp-contributors"><span target="_blank" rel="noreferrer" class="vp-contributor"><!----><span class="vp-contributor-name">Dylan Kwok</span></span></div><!--]--></div><footer class="vp-page-meta"><div class="vp-meta-item edit-link"><a class="auto-link external-link vp-meta-label" href="https://github.com/guosgbin/vuepress-blog/edit/main/src/test/HowToSayResume.md" aria-label="Edit this page on GitHub" rel="noopener noreferrer" target="_blank" iconsizing="both"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon" name="edit"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->Edit this page on GitHub<!----></a></div><div class="vp-meta-item git-info"><div class="update-time"><span class="vp-meta-label">Last Updated:</span><time class="vp-meta-info" datetime="2025-04-21T15:01:57.000Z" data-allow-mismatch>4/21/25, 3:01 PM</time></div></div></footer><!----><div id="comment" class="giscus-wrapper input-top vp-comment" vp-comment style="display:block;"><div style="display: flex;
align-items: center;
justify-content: center;
height: 96px"><span style="--loading-icon: url(&quot;data:image/svg+xml;utf8,%3Csvg xmlns=&#39;http://www.w3.org/2000/svg&#39; preserveAspectRatio=&#39;xMidYMid&#39; viewBox=&#39;25 25 50 50&#39;%3E%3CanimateTransform attributeName=&#39;transform&#39; type=&#39;rotate&#39; dur=&#39;2s&#39; keyTimes=&#39;0;1&#39; repeatCount=&#39;indefinite&#39; values=&#39;0;360&#39;%3E%3C/animateTransform%3E%3Ccircle cx=&#39;50&#39; cy=&#39;50&#39; r=&#39;20&#39; fill=&#39;none&#39; stroke=&#39;currentColor&#39; stroke-width=&#39;4&#39; stroke-linecap=&#39;round&#39;%3E%3Canimate attributeName=&#39;stroke-dasharray&#39; dur=&#39;1.5s&#39; keyTimes=&#39;0;0.5;1&#39; repeatCount=&#39;indefinite&#39; values=&#39;1,200;90,200;1,200&#39;%3E%3C/animate%3E%3Canimate attributeName=&#39;stroke-dashoffset&#39; dur=&#39;1.5s&#39; keyTimes=&#39;0;0.5;1&#39; repeatCount=&#39;indefinite&#39; values=&#39;0;-35px;-125px&#39;%3E%3C/animate%3E%3C/circle%3E%3C/svg%3E&quot;);
--icon-size: 48px;
display: inline-block;
width: var(--icon-size);
height: var(--icon-size);
background-color: currentcolor;
-webkit-mask-image: var(--loading-icon);
mask-image: var(--loading-icon);
"></span></div></div><!----><!--]--></main><!--]--><footer class="vp-footer-wrapper" vp-footer><div class="vp-footer">Default footer</div><div class="vp-copyright">Copyright © 2025 超威蓝猫 Dylan Kwok </div></footer></div><!--]--><!--[--><!----><!--[--><!--]--><!--]--><!--]--></div>
    <script type="module" src="/assets/app-B6zx7rvj.js" defer></script>
  </body>
</html>
