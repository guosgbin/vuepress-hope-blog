import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,b as a,o as n}from"./app-BJPl3VMZ.js";const e={};function l(h,i){return n(),t("div",null,i[0]||(i[0]=[a(`<table><thead><tr><th>版本</th><th>内容</th><th>时间</th></tr></thead><tbody><tr><td>V1</td><td>新建</td><td>2022年09月06日00:24:48</td></tr></tbody></table><h2 id="aqs-简介" tabindex="-1"><a class="header-anchor" href="#aqs-简介"><span>AQS 简介</span></a></h2><p>AbstractQueuedSynchronizer（后面简称为 AQS） 是整个 JUC 包的核心，JUC 包下的许多组件都是基于这个抽象类来实现的，其实就是使用了模板方法，让不同的子类去实现。</p><p>我们常用的同步器 ReentrantLock、CountDownLatch、CyclicBarrier 这些都是基于 AQS 的。</p><p>AQS 里面维护一个同步状态（资源），一个等待队列和一个 condition 队列分析。</p><br><p><strong>AQS 支持独占模式和共享模式</strong>，具体由子类实现。</p><ol><li>独占模式：某一时刻只能有一个线程能够获取资源；</li><li>共享模式：某一时刻可以有多个线程能够获取资源；</li></ol><br><p><strong>AQS 支持公平锁和非公平锁。</strong></p><ol><li>公平锁：根据尝试获取锁的先后顺序来获取锁，就是先到先得；</li><li>非公平锁：不是先到先得，前面的线程并没有优先获取锁的优势。我们熟知的 synchronized 就是一个非公平锁；</li></ol><br><p><strong>AQS 支持类似 Object 类提供的 wait，notify，notifyAll 机制，但是功能更强大。</strong></p><br><p><strong>AQS 支持中断和超时机制</strong>。</p><h2 id="资源是什么" tabindex="-1"><a class="header-anchor" href="#资源是什么"><span>资源是什么？</span></a></h2><p>在 AQS 中的同步状态（资源）就是一个 int 类型的值，对不同的同步器来说含义是不同的</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> volatile</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> state</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><table><thead><tr><th>同步器</th><th>同步状态含义</th></tr></thead><tbody><tr><td>CountDownLatch</td><td>资源 state 表示一个计数器的值，创建时 state 赋值初始值 n，当 n &gt; 0 时表示需要阻塞线程，当 n 减到 0 时表示所有阻塞的线程可以继续运行；</td></tr><tr><td>ReentrantLock</td><td>资源 state 表示锁是否占用<br>当 state = 0 时表示锁是空闲状态<br>当 state = 1 时表示锁已经被某个线程占用了<br>当 state &gt; 1 时表示锁重入了</td></tr><tr><td>Semaphore</td><td>资源 state 表示许可证 or 令牌，创建时给 state 赋值初始值 n，当 n &gt; 0 时表示当前线程可以获取这个许可证并继续向下运行。当 n = 0 时表示没有许可证了，当前线程需要阻塞并等待别的线程归还许可证；</td></tr><tr><td>CyclicBarrier</td><td>资源 state 表示的意思和 Semaphore 一样，可以把 CyclicBarrier 看成是一个可循环使用的 Semaphore；</td></tr></tbody></table><p>在 JUC 中还有一个 AbstractQueuedLongSynchronizer 类，和 AbstractQueuedSynchronizer 的区别就是前者的同步状态是 long 类型的，而后者的同步状态是 int 类型的，就这个区别。</p><h2 id="提供模板方法" tabindex="-1"><a class="header-anchor" href="#提供模板方法"><span>提供模板方法</span></a></h2><p>AQS 提供了一些模板方法，具体由子类去实现，如下：</p><table><thead><tr><th>抽象方法</th><th></th></tr></thead><tbody><tr><td>tryAcquire</td><td>尝试获取独占资源</td></tr><tr><td>tryRelease</td><td>尝试释放独占资源</td></tr><tr><td>tryAcquireShared</td><td>尝试获取共享资源</td></tr><tr><td>tryReleaseShared</td><td>尝试释放共享资源</td></tr><tr><td>isHeldExclusively</td><td>释放时独占模式</td></tr></tbody></table><p>我们常用的 ReentrantLock 就是使用独占模式的一个例子，它的内部实现了 tryAcquire，tryAcquireShared，isHeldExclusively 方法，我们后面具体分析。</p><h2 id="等待队列" tabindex="-1"><a class="header-anchor" href="#等待队列"><span>等待队列</span></a></h2><p>等待队列是一个 FIFO 队列，是Craig，Landin和Hagersten锁（CLH锁）的一种变种，采用双向链表实现。</p><p>先看下等待队列的节点的定义，就是一个内部类 Node。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    /** Marker to indicate a node is waiting in shared mode */</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 共享模式节点</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Node</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> SHARED </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Node</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    /** Marker to indicate a node is waiting in exclusive mode */</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 独占模式节点</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Node</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> EXCLUSIVE </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> CANCELLED </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">  1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> SIGNAL    </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> CONDITION </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> PROPAGATE </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 当前节点的状态</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    volatile</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> waitStatus</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 前驱</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    volatile</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Node</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> prev</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 后驱</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    volatile</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Node</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> next</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 结点包装的线程</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    volatile</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Thread</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // Condition队列使用，存储condition队列中的后继节点 单向链表</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    Node</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> nextWaiter</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>分析下属性：</p><ul><li>这个队列是一个双向链表，所以 Node 里面定义了代表前驱的 prev 指针和代表后驱的指针 next；</li><li>线程需要在队列中排队，thread 属性就是当前节点封装的线程对象；</li><li>SHARED 和 EXCLUSIVE 是一个标记，标记当前节点是在什么模式（独占 or 共享）下加入等待的；</li><li>前面说了 AQS 支持类似 wait 和 notify 的机制，其实是通过一个 condition 队列实现的，它是一个单向链表，nextWaiter 属性就维护了后驱指针；</li><li>waitStatus 属性表示当前节点的状态，取值和它们的含义如下表所示：</li></ul><table><thead><tr><th>key</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>CANCELLED</td><td>1</td><td>表示当前线程等待超时或者被中断，被取消排队了，取消争抢锁</td></tr><tr><td>SIGNAL</td><td>-1</td><td>表示当前线程可以唤醒它的 next 节点</td></tr><tr><td>CONDITION</td><td>-2</td><td>表示线程在条件队列里等待</td></tr><tr><td>PROPAGATE</td><td>-3</td><td>用于将唤醒后继线程传递下去，这个状态的引入是为了完善和增强共享锁的唤醒机制；</td></tr><tr><td></td><td>0</td><td>等待队列里的初始状态</td></tr></tbody></table><h2 id="condition-条件等待" tabindex="-1"><a class="header-anchor" href="#condition-条件等待"><span>Condition 条件等待</span></a></h2><p>Synchronized 同步锁在同步代码块中可以通过锁对象的 wait 和 notify 方法来实现线程同步。</p><p>对于 JUC 中的 Condition 接口，配合 Lock 锁也可以实现线程同步，通过 Condition 接口中的 await 和 signal 方法实现。</p><p>一个 Synchronized 锁只能有一个共享的变量锁对象的 wait 和 notify 来实现线程同步，而一个 Lock 锁可配合多个 Condition 实例使用。</p><p>Condition 必须和 Lock 配合使用，这和 Synchronized 的使用要求是一样的。</p><p>在 AbstractQueuedSynchronizer.Node 的属性中有个 nextWaiter 属性前面没有分析过，这个 nextWaiter 的含义是指向条件队列中当前节点的后驱节点。</p><p>条件队列是一个单向链表，通过 nextWaiter 连接。</p><p>当我们调用 await 方法后，当前线程就会被封装成一个节点加入到条件队列中去。因为 Lock 可以配合多个 Condition 使用，每个 Condition 都有自己的条件队列。</p><p>当调用指定 Condition 的 signal 方法后，就会将它的条件队列中的节点迁移到等待队列中，等待唤醒。当唤醒之前就会尝试重新获取锁，当获取到锁之后就可以执行自己的业务代码了。</p>`,40)]))}const p=s(e,[["render",l]]),k=JSON.parse('{"path":"/JDK_source/08-AQS%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D.html","title":"08-AQS简单介绍","lang":"en-US","frontmatter":{"title":"08-AQS简单介绍","description":"AQS 简介 AbstractQueuedSynchronizer（后面简称为 AQS） 是整个 JUC 包的核心，JUC 包下的许多组件都是基于这个抽象类来实现的，其实就是使用了模板方法，让不同的子类去实现。 我们常用的同步器 ReentrantLock、CountDownLatch、CyclicBarrier 这些都是基于 AQS 的。 AQS 里...","head":[["meta",{"property":"og:url","content":"https://blog.guosgbin.cn/JDK_source/08-AQS%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D.html"}],["meta",{"property":"og:title","content":"08-AQS简单介绍"}],["meta",{"property":"og:description","content":"AQS 简介 AbstractQueuedSynchronizer（后面简称为 AQS） 是整个 JUC 包的核心，JUC 包下的许多组件都是基于这个抽象类来实现的，其实就是使用了模板方法，让不同的子类去实现。 我们常用的同步器 ReentrantLock、CountDownLatch、CyclicBarrier 这些都是基于 AQS 的。 AQS 里..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-04-03T07:07:29.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-03T07:07:29.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"08-AQS简单介绍\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-03T07:07:29.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"超威蓝猫 Dylan Kwok\\",\\"url\\":\\"\\",\\"email\\":\\"guosgbin@163.com\\"}]}"]]},"git":{"createdTime":1743664049000,"updatedTime":1743664049000,"contributors":[{"name":"Dylan Kwok","username":"","email":"guosgbin@163.com","commits":1}]},"readingTime":{"minutes":5.08,"words":1525},"filePathRelative":"JDK_source/08-AQS简单介绍.md","localizedDate":"April 3, 2025","autoDesc":true}');export{p as comp,k as data};
