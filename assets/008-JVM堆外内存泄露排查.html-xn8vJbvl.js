import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,b as s,o as r}from"./app-DL4NvJby.js";const i="/assets/image-20250408155245132-DsqrehZd.png",o="/assets/image-20250408155321726-D20uQ4zB.png",l="/assets/image-20250408160005922-BoV3H-BE.png",n="/assets/image-20250408160133701-CSHRk0jR.png",c="/assets/image-20250408160205903-DSiTeBnt.png",d="/assets/image-20250408160225898-BG1Oqf3g.png",m="/assets/image-20250408160330321-DYxMrl2L.png",g="/assets/1726848209835-9714c9d5-9e28-4139-85cb-296a202a8366-Dim71i-R.png",p="/assets/1726848263533-08ba8f5a-10be-4513-956e-b37d5d13d628-C1Y1RxLz.png",b="/assets/image-20250408161758413-CzVKfrJC.png",h="/assets/image-20250408161823582-Wb3SA_7c.png",u={};function _(f,t){return r(),a("div",null,t[0]||(t[0]=[s('<h2 id="背景-现象" tabindex="-1"><a class="header-anchor" href="#背景-现象"><span>背景&amp;现象</span></a></h2><p>某个出海服务，需要记录设备日志，目前该记录操作会导致 JVM 频繁 Full GC，之前的开发使用动态配置开关将记录设备日志的操作给关掉了。</p><h2 id="排查方法" tabindex="-1"><a class="header-anchor" href="#排查方法"><span>排查方法</span></a></h2><ol><li>初步观察：确定排查方向；</li><li>测试环境复现：复现问题；</li><li>定位问题：分析问题根因；</li><li>代码改造：测试环境验证；</li><li>修复上线：观察改造效果；</li><li>问题沉淀：后续如何避免；</li></ol><h2 id="问题排查和分析" tabindex="-1"><a class="header-anchor" href="#问题排查和分析"><span>问题排查和分析</span></a></h2><h3 id="初步观察-确定排查方向" tabindex="-1"><a class="header-anchor" href="#初步观察-确定排查方向"><span>初步观察-确定排查方向</span></a></h3><p>打开记录设备日志的动态配置开关。</p><table><thead><tr><th></th><th>监控</th><th>分析</th></tr></thead><tbody><tr><td>JVM 监控</td><td><img src="'+i+'" alt="image-20250408155245132" style="zoom:30%;"></td><td>1）GC 次数明显变多，且有一次 full GC； <br><br><strong>2）非堆内存增长的很快，怀疑有堆外内存泄漏，可能有很多类加载；</strong></td></tr><tr><td>机器监控</td><td><img src="'+o+'" alt="image-20250408155321726" style="zoom:33%;"></td><td>1）开关开启后，CPU 使用率上升了 2 ~ 3 个百分点； <br><br>2）机器负载也有上升，但是这点负载对该配置影响并不大；</td></tr></tbody></table><h3 id="测试环境复现、定位问题" tabindex="-1"><a class="header-anchor" href="#测试环境复现、定位问题"><span>测试环境复现、定位问题</span></a></h3><table><thead><tr><th>排查思路</th><th>猜想/验证</th><th>详情</th><th>小结论</th></tr></thead><tbody><tr><td>full gc 原因</td><td>根据上面监控初步怀疑是频繁类加载导致的 metaspace 不够，触发 full gc。</td><td>从测试环境机器上下载 gc 日志，查看最近几次触发 full gc 的原因<br>简单展示下 full gc 的原因：<br><br>2024-09-20T15:01:21.966+0800: 861343.836: [GC (Allocation Failure) 2024-09-20T15:01:21.967+0800: 861343.836: [ParNew: 794478K-&gt;9617K(884736K), 0.0231782 secs] 1002604K-&gt;217743K(2523136K), 0.0236186 secs] [Times: user=0.05 sys=0.00, real=0.02 secs] <br><br>2024-09-20T15:06:39.123+0800: 861660.993: [Full GC (Metadata GC Threshold) 2024-09-20T15:06:39.123+0800: 861660.993: [CMS: 208125K-&gt;209470K(1638400K), 0.4697069 secs] 842719K-&gt;209470K(2523136K), [Metaspace: 213257K-&gt;213257K(1288192K)], 0.4743622 secs] [Times: user=0.48 sys=0.00, real=0.48 secs]</td><td><strong>已确定</strong>：通过日志确定确实就是 metaspace 不够，触发 full gc 了。</td></tr><tr><td>类加载情况</td><td>为了查看服务的类加载情况，我在测试环境的启动参数中增加下面两个 JVM 参数，<strong>打印类加载和类卸载的情况</strong><br><br>-XX:+TraceClassLoading<br>-XX:+TraceClassUnloading</td><td>重启服务后，发现日志打印了很多下面类加载的日志<br><br><img src="'+l+'" alt="image-20250408160005922" style="zoom:25%;"></td><td><strong>已确定</strong>：基本上可以确定就是类加载导致 metaspace 内存不够了。</td></tr><tr><td>定位代码</td><td>尝试定位具体代码</td><td>可以看到是 fastjson 导致的，先看 DeviceDataToES 相关的 json 操作，可以定位到 DeviceDataToES#buildDataToES 方法<br><br><img src="'+n+'" alt="image-20250408160133701" style="zoom:33%;"><br><br>可以定位到具体代码：SerializeConfig config = new SerializeConfig(); 继续深入：<br><br><img src="'+c+'" alt="image-20250408160205903" style="zoom:20%;"><br><br>继续看该 classLoader 使用的地方<br><br><img src="'+d+'" alt="image-20250408160225898" style="zoom:33%;"></td><td>**已确定：**已经定位到 metaspace 占用内存一直增长的具体代码了</td></tr><tr><td>测试环境复现</td><td>进一步验证问题代码导致 metaspace 溢出</td><td>简单压测一下触发该方法的 topic，发现下面日志疯狂打印：<br><br><img src="'+m+'" alt="image-20250408160330321" style="zoom:20%;"><br><br>对应监控 metaspace 占用内存陡增，<br><br><img src="'+g+'" alt="image.png" style="zoom:25%;"><br><br>对应类加载也激增：<br><br><img src="'+p+'" alt="img" style="zoom:25%;"><br><br>在触发一次 full gc 后，日志打印如下：说明卸载了大量多余的类<br><br><img src="'+b+'" alt="image-20250408161758413" style="zoom:25%;"><br><br>arthas 查看 ASMClassLoader 的实例个数和类加载的数量<br><br><img src="'+h+'" alt="image-20250408161823582" style="zoom:20%;"></td><td>压测确定问题代码导致 metaspace 占用内存一直增长，且 full gc 后卸载了这些类。</td></tr></tbody></table><h3 id="代码改造、修复上线" tabindex="-1"><a class="header-anchor" href="#代码改造、修复上线"><span>代码改造、修复上线</span></a></h3><p>SerializeConfig 作为成员变量时，每次会使用新的类加载器去加载要序列化的类。将 SerializeConfig 抽取出来即可。</p><h3 id="问题沉淀" tabindex="-1"><a class="header-anchor" href="#问题沉淀"><span>问题沉淀</span></a></h3><ul><li>涉及核心链路改动时，在测试环境压测，避免线上出现严重的性能 bug。</li><li>使用到 ASM 字节码相关技术、框架时，需要防止频繁的类加载使元空间内存不足，导致频繁的 full GC。</li></ul>',14)]))}const E=e(u,[["render",_]]),M=JSON.parse('{"path":"/business_issue_accumulations/008-JVM%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%8E%92%E6%9F%A5.html","title":"008-JVM堆外内存泄露排查","lang":"en-US","frontmatter":{"title":"008-JVM堆外内存泄露排查","description":"背景&现象 某个出海服务，需要记录设备日志，目前该记录操作会导致 JVM 频繁 Full GC，之前的开发使用动态配置开关将记录设备日志的操作给关掉了。 排查方法 初步观察：确定排查方向； 测试环境复现：复现问题； 定位问题：分析问题根因； 代码改造：测试环境验证； 修复上线：观察改造效果； 问题沉淀：后续如何避免； 问题排查和分析 初步观察-确定排查...","head":[["meta",{"property":"og:url","content":"https://blog.guosgbin.cn/business_issue_accumulations/008-JVM%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%8E%92%E6%9F%A5.html"}],["meta",{"property":"og:title","content":"008-JVM堆外内存泄露排查"}],["meta",{"property":"og:description","content":"背景&现象 某个出海服务，需要记录设备日志，目前该记录操作会导致 JVM 频繁 Full GC，之前的开发使用动态配置开关将记录设备日志的操作给关掉了。 排查方法 初步观察：确定排查方向； 测试环境复现：复现问题； 定位问题：分析问题根因； 代码改造：测试环境验证； 修复上线：观察改造效果； 问题沉淀：后续如何避免； 问题排查和分析 初步观察-确定排查..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-04-08T14:30:44.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-08T14:30:44.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"008-JVM堆外内存泄露排查\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-08T14:30:44.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"超威蓝猫 Dylan Kwok\\",\\"url\\":\\"\\",\\"email\\":\\"guosgbin@163.com\\"}]}"]]},"git":{"createdTime":1744122644000,"updatedTime":1744122644000,"contributors":[{"name":"Dylan Kwok","username":"","email":"guosgbin@163.com","commits":1}]},"readingTime":{"minutes":4.59,"words":1377},"filePathRelative":"business_issue_accumulations/008-JVM堆外内存泄露排查.md","localizedDate":"April 8, 2025","autoDesc":true}');export{E as comp,M as data};
