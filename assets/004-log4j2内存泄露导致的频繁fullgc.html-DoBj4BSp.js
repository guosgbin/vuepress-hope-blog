import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,b as r,o as s}from"./app-B6zx7rvj.js";const i="/assets/image-20240301122232905-DPS7j19B.png",l="/assets/image-20240301122412468-U-Jxgjwb.png",o="/assets/image-20240301142204610-BIRCo_XL.png",n="/assets/image-20240301142914193-ClrRwEqN.png",p="/assets/image-20240301142815763-LiHDRKv2.png",g="/assets/image-20240301143518060-BUMvmgk1.png",c="/assets/image-20240301153345137-BTrmg7bW.png",m="/assets/image-20240301154038886-CsfyOZWJ.png",u="/assets/image-20240301154444481-BBuc7DMx.png",d={};function h(_,e){return s(),t("div",null,e[0]||(e[0]=[r('<h2 id="现象" tabindex="-1"><a class="header-anchor" href="#现象"><span>现象</span></a></h2><p>线上服务突然发生频繁的 Full GC，并且每次 Full GC 后只回收一点点内存，老年代的内存使用率不降。</p><ul><li>频繁发生 Full GC 👇🏻</li></ul><img src="'+i+'" alt="image-20240301122232905" style="zoom:100%;"><ul><li>每次 Full GC 老年代只回收了一点点内存 👇🏻</li></ul><img src="'+l+'" alt="image-20240301122412468" style="zoom:100%;"><h2 id="排查方向" tabindex="-1"><a class="header-anchor" href="#排查方向"><span>排查方向</span></a></h2><p>第一时间下载 dump 的 prof 文件，并对将该服务器的流量切走。</p><h2 id="问题排查和分析" tabindex="-1"><a class="header-anchor" href="#问题排查和分析"><span>问题排查和分析</span></a></h2><h3 id="定位业务代码" tabindex="-1"><a class="header-anchor" href="#定位业务代码"><span>定位业务代码</span></a></h3><p>visualVm 发现大量 char[]。按大小排序，前面部分基本都是存储的 log 日志，大小都好几兆，怀疑是打了大日志有关，排查相关业务，关闭了一些不合理的日志。</p><img src="'+o+'" alt="image-20240301142204610" style="zoom:100%;"><p>将其中一个char[] 数组的内容拿出来看一下：</p><img src="'+n+'" alt="image-20240301142914193"><p>对应的代码如下：</p><img src="'+p+'" alt="image-20240301142815763"><p>从代码中看到，这条日志并不长，为啥这个 char[] 却好几m，而且 unansweredCnt:0 后面的日志明显跟前面的接不上, 随便找了其他的char[] 也有这种情况。</p><h3 id="分析引用链路" tabindex="-1"><a class="header-anchor" href="#分析引用链路"><span>分析引用链路</span></a></h3><p>通过 references，分析引用链路</p><img src="'+g+'" alt="image-20240301143518060"><p>发现日志最终缓存到 StringBuilder，而这个 StringBuilder 存储到了线程的 ThreadLocal 里面去了。</p><p>搜索 Log4j2 在什么地方使用了 StringBuilder，排查发现 org.apache.logging.log4j.message.ParameterizedMessage 这个类中有一个复用 StringBuilder 的代码，线上使用 log4j-api 的版本是 2.6.1</p><img src="'+c+'" alt="image-20240301153345137"><p>这段代码中 Log4j2 引用了一个 ThreadLocal 中的 StringBuilder，这样复用 StringBuilder 可以大幅提高日志输出效率，但是这段代码 buffer.setLength(0)，这个操作只会将 StringBuilder 的写入重置为从 0 开始写入，但不会回收 StringBuilder 已经占用的内存，由于当前的 ThreadLocal 是 tomcat 的线程池里的线程，线程一般不会销毁，所以 ThreadLocal 就基本没啥可能会被释放，导致StringBuilder 也不会被回收。这个 StringBuilder 的内存只会增加不会减少，由此导致内存泄漏。</p><h2 id="问题解决" tabindex="-1"><a class="header-anchor" href="#问题解决"><span>问题解决</span></a></h2><p>查看官网发现，这是一个 bug，具体地址如下：<a href="https://issues.apache.org/jira/browse/LOG4J2-1858" target="_blank" rel="noopener noreferrer">https://issues.apache.org/jira/browse/LOG4J2-1858</a></p><p>然后 log4j 官方在 2.9.0 版本修复了这个 bug， release note 地址：<a href="https://logging.apache.org/log4j/2.x/release-notes.html" target="_blank" rel="noopener noreferrer">https://logging.apache.org/log4j/2.x/release-notes.html</a></p><img src="'+m+'" alt="image-20240301154038886" style="zoom:100%;"><p>我们决定升级到 2.12.1</p><img src="'+u+'" alt="image-20240301154444481" style="zoom:100%;"><p>可以看到新版本中增加一个操作trimToMaxSize，当 buffer 的长度大于某一直时会触发 StringBuilder 的 trimToSize 操作，这个方法会回收 StringBuilder 的缓存。</p><h2 id="结论" tabindex="-1"><a class="header-anchor" href="#结论"><span>结论</span></a></h2><p>1、某些业务打印了大量大日志，导致每个线程 threadLocal 的 StringBuilder 占用内存增大，最大达到 5m；</p><p>2、目前系统常驻线程稳定在 6000~7000，最终日志 buffer 就会占到 3~4g；</p><p>3、规范日志输出，避免磁盘、内存浪费；</p><p>4、升级 log4j2 版本，从 2.6.1 到 2.12.1；</p>',36)]))}const b=a(d,[["render",h]]),j=JSON.parse('{"path":"/business_issue_accumulations/004-log4j2%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%AF%BC%E8%87%B4%E7%9A%84%E9%A2%91%E7%B9%81fullgc.html","title":"004-log4j2内存泄露导致频繁fullgc","lang":"en-US","frontmatter":{"title":"004-log4j2内存泄露导致频繁fullgc","description":"现象 线上服务突然发生频繁的 Full GC，并且每次 Full GC 后只回收一点点内存，老年代的内存使用率不降。 频繁发生 Full GC 👇🏻 image-20240301122232905 每次 Full GC 老年代只回收了一点点内存 👇🏻 image-20240301122412468 排查方向 第一时间下载 dump 的 prof...","head":[["meta",{"property":"og:url","content":"https://blog.guosgbin.cn/business_issue_accumulations/004-log4j2%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%AF%BC%E8%87%B4%E7%9A%84%E9%A2%91%E7%B9%81fullgc.html"}],["meta",{"property":"og:title","content":"004-log4j2内存泄露导致频繁fullgc"}],["meta",{"property":"og:description","content":"现象 线上服务突然发生频繁的 Full GC，并且每次 Full GC 后只回收一点点内存，老年代的内存使用率不降。 频繁发生 Full GC 👇🏻 image-20240301122232905 每次 Full GC 老年代只回收了一点点内存 👇🏻 image-20240301122412468 排查方向 第一时间下载 dump 的 prof..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-04-03T07:07:29.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-03T07:07:29.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"004-log4j2内存泄露导致频繁fullgc\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-03T07:07:29.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"超威蓝猫 Dylan Kwok\\",\\"url\\":\\"\\",\\"email\\":\\"guosgbin@163.com\\"}]}"]]},"git":{"createdTime":1743664049000,"updatedTime":1743664049000,"contributors":[{"name":"Dylan Kwok","username":"","email":"guosgbin@163.com","commits":1}]},"readingTime":{"minutes":2.82,"words":845},"filePathRelative":"business_issue_accumulations/004-log4j2内存泄露导致的频繁fullgc.md","localizedDate":"April 3, 2025","autoDesc":true}');export{b as comp,j as data};
