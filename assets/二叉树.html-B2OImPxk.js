import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as r,b as d,o}from"./app-BwQU3aYW.js";const n={};function a(l,t){return o(),r("div",null,t[0]||(t[0]=[d('<p><strong>每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！</strong></p><ol><li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li><li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li><li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li></ol><p>递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：</p><ul><li>如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的<a href="https://leetcode.cn/problems/path-sum-ii/" target="_blank" rel="noopener noreferrer">113. 路径总和 II</a>）</li><li>如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在<a href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html" target="_blank" rel="noopener noreferrer">236. 二叉树的最近公共祖先</a>中介绍）</li><li>如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。<a href="https://leetcode.cn/problems/path-sum/" target="_blank" rel="noopener noreferrer">112. 路径总和</a></li></ul><table><thead><tr><th>题目</th><th>难度</th><th>备注</th><th>关联</th><th></th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener noreferrer">144.二叉树的前序遍历</a></td><td>简单</td><td></td><td></td><td>可以再刷</td></tr><tr><td><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener noreferrer">94.二叉树的中序遍历</a></td><td>简单</td><td></td><td></td><td>可以再刷</td></tr><tr><td><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener noreferrer">145.二叉树的后序遍历</a></td><td>简单</td><td></td><td></td><td>可以再刷</td></tr><tr><td><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener noreferrer">102. 二叉树的层序遍历</a></td><td>中等</td><td></td><td></td><td>可以再刷</td></tr><tr><td><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener noreferrer">107. 二叉树的层序遍历 II</a></td><td>中等</td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/binary-tree-right-side-view/" target="_blank" rel="noopener noreferrer">199. 二叉树的右视图</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/binary-tree-right-side-view/solutions/214871/jian-dan-bfsdfs-bi-xu-miao-dong-by-sweetiee/" target="_blank" rel="noopener noreferrer">这个解法可以的</a></td><td></td><td>了解 dfs</td></tr><tr><td><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/" target="_blank" rel="noopener noreferrer">637. 二叉树的层平均值</a></td><td>简单</td><td></td><td></td><td>了解 dfs</td></tr><tr><td><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="noopener noreferrer">429. N 叉树的层序遍历</a></td><td>中等</td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/" target="_blank" rel="noopener noreferrer">515. 在每个树行中找最大值</a></td><td>中等</td><td></td><td></td><td>了解 dfs</td></tr><tr><td><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener noreferrer">116. 填充每个节点的下一个右侧节点指针</a></td><td>中等</td><td></td><td></td><td>O(1) 空间复杂度</td></tr><tr><td><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener noreferrer">117. 填充每个节点的下一个右侧节点指针 II</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/solutions/2510505/gong-shui-san-xie-xiang-xi-tu-jie-o1-kon-d6vg/" target="_blank" rel="noopener noreferrer">这个 O(1) 的解法</a></td><td></td><td>O(1) 空间复杂度</td></tr><tr><td><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener noreferrer">104. 二叉树的最大深度</a></td><td>简单</td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener noreferrer">111. 二叉树的最小深度</a></td><td>简单</td><td></td><td></td><td>了解 dfs，可以再刷</td></tr><tr><td><a href="https://leetcode.cn/problems/invert-binary-tree/" target="_blank" rel="noopener noreferrer">226. 翻转二叉树</a></td><td>简单</td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/symmetric-tree/" target="_blank" rel="noopener noreferrer">101. 对称二叉树</a></td><td>简单</td><td></td><td></td><td>可以再刷</td></tr><tr><td><a href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/" target="_blank" rel="noopener noreferrer">559. N 叉树的最大深度</a></td><td>简单</td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/count-complete-tree-nodes/" target="_blank" rel="noopener noreferrer">222. 完全二叉树的节点个数</a></td><td>简单</td><td>使用完全二叉树的性质<br>位运算</td><td></td><td>可以再刷</td></tr><tr><td><a href="https://leetcode.cn/problems/balanced-binary-tree/" target="_blank" rel="noopener noreferrer">110. 平衡二叉树</a></td><td>简单</td><td></td><td></td><td>可以再刷</td></tr><tr><td><a href="https://leetcode.cn/problems/binary-tree-paths/" target="_blank" rel="noopener noreferrer">257. 二叉树的所有路径</a></td><td>简单</td><td>层次遍历的解法比较新颖</td><td></td><td>可以再刷</td></tr><tr><td><a href="https://leetcode.cn/problems/sum-of-left-leaves/" target="_blank" rel="noopener noreferrer">404. 左叶子之和</a></td><td>简单</td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/" target="_blank" rel="noopener noreferrer">513. 找树左下角的值</a></td><td>简单</td><td>深度遍历的思路有点意思</td><td></td><td>可以再刷</td></tr><tr><td><a href="https://leetcode.cn/problems/path-sum/" target="_blank" rel="noopener noreferrer">112. 路径总和</a></td><td>简单</td><td>层次遍历的双队列可以</td><td></td><td>可以再刷</td></tr><tr><td><a href="https://leetcode.cn/problems/path-sum-ii/" target="_blank" rel="noopener noreferrer">113. 路径总和 II</a></td><td>中等</td><td>回溯</td><td></td><td>可以再刷</td></tr><tr><td><a href="https://leetcode.cn/problems/maximum-binary-tree/" target="_blank" rel="noopener noreferrer">654. 最大二叉树</a></td><td>中等</td><td>构造二叉树</td><td></td><td>可以再刷</td></tr><tr><td><a href="https://leetcode.cn/problems/merge-two-binary-trees/" target="_blank" rel="noopener noreferrer">617. 合并二叉树</a></td><td>简单</td><td>构造二叉树</td><td></td><td>可以再刷</td></tr><tr><td><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener noreferrer">106. 从中序与后序遍历序列构造二叉树</a></td><td>中等</td><td>构造二叉树</td><td></td><td>可以再刷</td></tr><tr><td><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener noreferrer">105. 从前序与中序遍历序列构造二叉树</a></td><td>中等</td><td>构造二叉树</td><td></td><td>可以再刷</td></tr><tr><td><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/" target="_blank" rel="noopener noreferrer">700. 二叉搜索树中的搜索</a></td><td>简单</td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/validate-binary-search-tree/" target="_blank" rel="noopener noreferrer">98. 验证二叉搜索树</a></td><td>中等</td><td></td><td></td><td>可以再刷</td></tr><tr><td><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/" target="_blank" rel="noopener noreferrer">530. 二叉搜索树的最小绝对差</a></td><td>简单</td><td>二叉搜索树的中序遍历<br>节点的值是递增的</td><td></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/" target="_blank" rel="noopener noreferrer">501. 二叉搜索树中的众数</a></td><td>简单</td><td></td><td></td><td>可以再刷</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table>',5)]))}const i=e(n,[["render",a]]),c=JSON.parse('{"path":"/leetcode_record/%E4%BA%8C%E5%8F%89%E6%A0%91.html","title":"二叉树","lang":"en-US","frontmatter":{"title":"二叉树","description":"每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！ 确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。 确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用...","head":[["meta",{"property":"og:url","content":"https://blog.guosgbin.cn/leetcode_record/%E4%BA%8C%E5%8F%89%E6%A0%91.html"}],["meta",{"property":"og:title","content":"二叉树"}],["meta",{"property":"og:description","content":"每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！ 确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。 确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-04-03T07:07:29.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-03T07:07:29.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"二叉树\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-03T07:07:29.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"超威蓝猫 Dylan Kwok\\",\\"url\\":\\"\\",\\"email\\":\\"guosgbin@163.com\\"}]}"]]},"git":{"createdTime":1743664049000,"updatedTime":1743664049000,"contributors":[{"name":"Dylan Kwok","username":"","email":"guosgbin@163.com","commits":1}]},"readingTime":{"minutes":4.1,"words":1231},"filePathRelative":"leetcode_record/二叉树.md","localizedDate":"April 3, 2025","autoDesc":true}');export{i as comp,c as data};
