import{_ as d}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as u,b as r,d as i,f as n,w as t,e as s,r as p,o as g}from"./app-B6zx7rvj.js";const k="/assets/image-20231022225007301-YTqCNv5w.png",h="/assets/image-20231023085432401-fR2ztzWd.png",v="/assets/image-20231023101545288-BkCAn_V-.png",A="data:image/png;base64,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",m="data:image/png;base64,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",b={},f={class:"table-of-contents"};function C(B,l){const o=p("router-link"),a=p("font"),e=p("Mermaid");return g(),u("div",null,[l[293]||(l[293]=r("<table><thead><tr><th>版本</th><th>内容</th><th>时间</th></tr></thead><tbody><tr><td>V1</td><td>新建</td><td>忘了，应该是 23 年底</td></tr><tr><td>V2</td><td>更新部分文案</td><td>2025-04-21 02:19:10</td></tr></tbody></table>",1)),i("nav",f,[i("ul",null,[i("li",null,[n(o,{to:"#jvm-内存区域的一些概念"},{default:t(()=>l[0]||(l[0]=[s("JVM 内存区域的一些概念")])),_:1}),i("ul",null,[i("li",null,[n(o,{to:"#jvm-内存区域划分"},{default:t(()=>l[1]||(l[1]=[s("JVM 内存区域划分")])),_:1})]),i("li",null,[n(o,{to:"#程序计数器的作用-线程私有吗-是否会发生-oom"},{default:t(()=>l[2]||(l[2]=[s("程序计数器的作用？线程私有吗？是否会发生 OOM？")])),_:1})]),i("li",null,[n(o,{to:"#虚拟机栈和本地方法栈-线程私有吗-是否会发生-oom"},{default:t(()=>l[3]||(l[3]=[s("虚拟机栈和本地方法栈？线程私有吗？是否会发生 OOM？")])),_:1})]),i("li",null,[n(o,{to:"#堆-堆的作用"},{default:t(()=>l[4]||(l[4]=[s("堆？堆的作用？")])),_:1})]),i("li",null,[n(o,{to:"#方法区存放的什么东西"},{default:t(()=>l[5]||(l[5]=[s("方法区存放的什么东西？")])),_:1})]),i("li",null,[n(o,{to:"#符号引用是什么"},{default:t(()=>l[6]||(l[6]=[s("符号引用是什么？")])),_:1})]),i("li",null,[n(o,{to:"#运行时常量池"},{default:t(()=>l[7]||(l[7]=[s("运行时常量池？")])),_:1})])])]),i("li",null,[n(o,{to:"#对象的布局、创建流程、生命周期"},{default:t(()=>l[8]||(l[8]=[s("对象的布局、创建流程、生命周期")])),_:1}),i("ul",null,[i("li",null,[n(o,{to:"#对象的内存布局"},{default:t(()=>l[9]||(l[9]=[s("对象的内存布局")])),_:1})]),i("li",null,[n(o,{to:"#对象的创建流程-给对象分配内存时的并发安全问题是如何解决的"},{default:t(()=>l[10]||(l[10]=[s("对象的创建流程？给对象分配内存时的并发安全问题是如何解决的？")])),_:1})]),i("li",null,[n(o,{to:"#内存分配的指针碰撞和空闲列表"},{default:t(()=>l[11]||(l[11]=[s("内存分配的指针碰撞和空闲列表")])),_:1})]),i("li",null,[n(o,{to:"#对象在堆中的生命周期"},{default:t(()=>l[12]||(l[12]=[s("对象在堆中的生命周期")])),_:1})])])]),i("li",null,[n(o,{to:"#内存泄漏"},{default:t(()=>l[13]||(l[13]=[s("内存泄漏")])),_:1}),i("ul",null,[i("li",null,[n(o,{to:"#内存泄漏有那些原因"},{default:t(()=>l[14]||(l[14]=[s("内存泄漏有那些原因")])),_:1})]),i("li",null,[n(o,{to:"#如何定位内存泄漏"},{default:t(()=>l[15]||(l[15]=[s("如何定位内存泄漏")])),_:1})])])]),i("li",null,[n(o,{to:"#gc-垃圾回收"},{default:t(()=>l[16]||(l[16]=[s("GC 垃圾回收")])),_:1}),i("ul",null,[i("li",null,[n(o,{to:"#如何判断对象已经死亡"},{default:t(()=>l[17]||(l[17]=[s("如何判断对象已经死亡？")])),_:1})]),i("li",null,[n(o,{to:"#有哪些对象是-gc-root-对象"},{default:t(()=>l[18]||(l[18]=[s("有哪些对象是 GC Root 对象？")])),_:1})]),i("li",null,[n(o,{to:"#java-的引用有那些-分别的特点是什么"},{default:t(()=>l[19]||(l[19]=[s("Java 的引用有那些？分别的特点是什么？")])),_:1})]),i("li",null,[n(o,{to:"#对分代收集理论的理解-为什么要分代-跨代引用问题是如何处理的"},{default:t(()=>l[20]||(l[20]=[s("对分代收集理论的理解？为什么要分代？跨代引用问题是如何处理的？")])),_:1})]),i("li",null,[n(o,{to:"#说下垃圾清理算法有那些"},{default:t(()=>l[21]||(l[21]=[s("说下垃圾清理算法有那些？")])),_:1})]),i("li",null,[n(o,{to:"#谈谈你对新生代的分区占比的理解-为什么要按这样的比例划分"},{default:t(()=>l[22]||(l[22]=[s("谈谈你对新生代的分区占比的理解？为什么要按这样的比例划分？")])),_:1})]),i("li",null,[n(o,{to:"#jvm-内存分配策略"},{default:t(()=>l[23]||(l[23]=[s("JVM 内存分配策略")])),_:1})]),i("li",null,[n(o,{to:"#垃圾回收的安全点的概念-如何让所有线程在垃圾回收前都跑到安全点位置停顿下来"},{default:t(()=>l[24]||(l[24]=[s("垃圾回收的安全点的概念？如何让所有线程在垃圾回收前都跑到安全点位置停顿下来？")])),_:1})]),i("li",null,[n(o,{to:"#垃圾回收有了安全点为什么还要安全区域"},{default:t(()=>l[25]||(l[25]=[s("垃圾回收有了安全点为什么还要安全区域？")])),_:1})]),i("li",null,[n(o,{to:"#jvm-的卡表-作用是什么-什么时候更新卡表"},{default:t(()=>l[26]||(l[26]=[s("JVM 的卡表？作用是什么？什么时候更新卡表？")])),_:1})]),i("li",null,[n(o,{to:"#简单说下-parnew-回收器"},{default:t(()=>l[27]||(l[27]=[s("简单说下 ParNew 回收器？")])),_:1})]),i("li",null,[n(o,{to:"#吞吐量是什么"},{default:t(()=>l[28]||(l[28]=[s("吞吐量是什么？")])),_:1})]),i("li",null,[n(o,{to:"#简单说下-cms-回收器-设计目的-收集过程-优缺点"},{default:t(()=>l[29]||(l[29]=[s("简单说下 CMS 回收器？设计目的？收集过程？优缺点？")])),_:1})]),i("li",null,[n(o,{to:"#如何优化-cms-垃圾回收器"},{default:t(()=>l[30]||(l[30]=[s("如何优化 CMS 垃圾回收器？")])),_:1})]),i("li",null,[n(o,{to:"#g1-垃圾回收器简单描述"},{default:t(()=>l[31]||(l[31]=[s("G1 垃圾回收器简单描述？")])),_:1})]),i("li",null,[n(o,{to:"#g1-垃圾回收器如何处理跨代引用"},{default:t(()=>l[32]||(l[32]=[s("G1 垃圾回收器如何处理跨代引用？")])),_:1})]),i("li",null,[n(o,{to:"#三色标记"},{default:t(()=>l[33]||(l[33]=[s("三色标记？")])),_:1})]),i("li",null,[n(o,{to:"#并发的可达性分析-并发扫描对象消失问题如何解决-增量更新和原始快照-satb"},{default:t(()=>l[34]||(l[34]=[s("并发的可达性分析？并发扫描对象消失问题如何解决？增量更新和原始快照（SATB）")])),_:1})]),i("li",null,[n(o,{to:"#g1-垃圾回收器的执行流程"},{default:t(()=>l[35]||(l[35]=[s("G1 垃圾回收器的执行流程？")])),_:1})]),i("li",null,[n(o,{to:"#g1-的停顿时间如何设置"},{default:t(()=>l[36]||(l[36]=[s("G1 的停顿时间如何设置？")])),_:1})]),i("li",null,[n(o,{to:"#cms-和-g1-比较"},{default:t(()=>l[37]||(l[37]=[s("CMS 和 G1 比较？")])),_:1})]),i("li",null,[n(o,{to:"#你们公司生产用的什么垃圾回收器的组合-为什么这样选"},{default:t(()=>l[38]||(l[38]=[s("你们公司生产用的什么垃圾回收器的组合？为什么这样选？")])),_:1})])])]),i("li",null,[n(o,{to:"#jvm-相关的命令"},{default:t(()=>l[39]||(l[39]=[s("JVM 相关的命令")])),_:1}),i("ul",null,[i("li",null,[n(o,{to:"#jps-的作用-常用的参数选项-jdk8"},{default:t(()=>l[40]||(l[40]=[s("jps 的作用？常用的参数选项？（JDK8）")])),_:1})]),i("li",null,[n(o,{to:"#jmap-的作用-常用的参数选项-jdk8"},{default:t(()=>l[41]||(l[41]=[s("jmap 的作用？常用的参数选项？（JDK8）")])),_:1})]),i("li",null,[n(o,{to:"#jstat-的作用-常用的参数选项-jdk8"},{default:t(()=>l[42]||(l[42]=[s("jstat 的作用？常用的参数选项？（JDK8）")])),_:1})]),i("li",null,[n(o,{to:"#jstack-的作用-常用的参数选项-jdk8"},{default:t(()=>l[43]||(l[43]=[s("jstack 的作用？常用的参数选项？（JDK8）")])),_:1})]),i("li",null,[n(o,{to:"#jinfo-的作用-常用的参数选项-jdk8"},{default:t(()=>l[44]||(l[44]=[s("jinfo 的作用？常用的参数选项？（JDK8）")])),_:1})]),i("li",null,[n(o,{to:"#如何查看-jvm-的一些参数的默认值"},{default:t(()=>l[45]||(l[45]=[s("如何查看 JVM 的一些参数的默认值？")])),_:1})])])]),i("li",null,[n(o,{to:"#class-文件结构"},{default:t(()=>l[46]||(l[46]=[s("Class 文件结构")])),_:1}),i("ul",null,[i("li",null,[n(o,{to:"#class-类文件结构"},{default:t(()=>l[47]||(l[47]=[s("Class 类文件结构")])),_:1})]),i("li",null,[n(o,{to:"#class-文件的常量池里面存的是什么"},{default:t(()=>l[48]||(l[48]=[s("Class 文件的常量池里面存的是什么？")])),_:1})]),i("li",null,[n(o,{to:"#class-文件中的访问标志"},{default:t(()=>l[49]||(l[49]=[s("Class 文件中的访问标志？")])),_:1})]),i("li",null,[n(o,{to:"#class-文件中类索引、父类索引、接口索引集合"},{default:t(()=>l[50]||(l[50]=[s("Class 文件中类索引、父类索引、接口索引集合？")])),_:1})]),i("li",null,[n(o,{to:"#class-文件中字段表集合"},{default:t(()=>l[51]||(l[51]=[s("Class 文件中字段表集合？")])),_:1})]),i("li",null,[n(o,{to:"#class-文件中方法表集合"},{default:t(()=>l[52]||(l[52]=[s("Class 文件中方法表集合？")])),_:1})])])]),i("li",null,[n(o,{to:"#类加载机制"},{default:t(()=>l[53]||(l[53]=[s("类加载机制")])),_:1}),i("ul",null,[i("li",null,[n(o,{to:"#什么是类加载机制"},{default:t(()=>l[54]||(l[54]=[s("什么是类加载机制？")])),_:1})]),i("li",null,[n(o,{to:"#类加载的流程"},{default:t(()=>l[55]||(l[55]=[s("类加载的流程？")])),_:1})]),i("li",null,[n(o,{to:"#类加载过程的加载部分"},{default:t(()=>l[56]||(l[56]=[s("类加载过程的加载部分？")])),_:1})]),i("li",null,[n(o,{to:"#类加载过程的连接阶段的验证阶段"},{default:t(()=>l[57]||(l[57]=[s("类加载过程的连接阶段的验证阶段？")])),_:1})]),i("li",null,[n(o,{to:"#类加载过程的连接阶段的准备阶段"},{default:t(()=>l[58]||(l[58]=[s("类加载过程的连接阶段的准备阶段？")])),_:1})]),i("li",null,[n(o,{to:"#类加载过程的连接阶段的解析阶段"},{default:t(()=>l[59]||(l[59]=[s("类加载过程的连接阶段的解析阶段？")])),_:1})]),i("li",null,[n(o,{to:"#类加载过程的连接初始化阶段"},{default:t(()=>l[60]||(l[60]=[s("类加载过程的连接初始化阶段？")])),_:1})]),i("li",null,[n(o,{to:"#类和类加载器的关系"},{default:t(()=>l[61]||(l[61]=[s("类和类加载器的关系？")])),_:1})]),i("li",null,[n(o,{to:"#jvm-中有哪些类加载器-jdk8"},{default:t(()=>l[62]||(l[62]=[s("JVM 中有哪些类加载器？（JDK8）")])),_:1})]),i("li",null,[n(o,{to:"#类加载器的双亲委派流程"},{default:t(()=>l[63]||(l[63]=[s("类加载器的双亲委派流程？")])),_:1})]),i("li",null,[n(o,{to:"#类加载器的双亲委派有什么好处"},{default:t(()=>l[64]||(l[64]=[s("类加载器的双亲委派有什么好处？")])),_:1})]),i("li",null,[n(o,{to:"#破坏双亲委派模型"},{default:t(()=>l[65]||(l[65]=[s("破坏双亲委派模型？")])),_:1})]),i("li",null,[n(o,{to:"#运行时栈帧结构"},{default:t(()=>l[66]||(l[66]=[s("运行时栈帧结构？")])),_:1})]),i("li",null,[n(o,{to:"#方法调用"},{default:t(()=>l[67]||(l[67]=[s("方法调用？")])),_:1})]),i("li",null,[n(o,{to:"#tomcat-为什么要自定义类加载器"},{default:t(()=>l[68]||(l[68]=[s("Tomcat 为什么要自定义类加载器？")])),_:1})])])])])]),l[294]||(l[294]=r('<blockquote><p>JDK8 垃圾回收器官方文档 <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/</a></p><p>JDK11 垃圾回收器官方文档 <a href="https://docs.oracle.com/en/java/javase/11/gctuning/index.html" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/en/java/javase/11/gctuning/index.html</a></p></blockquote><h2 id="jvm-内存区域的一些概念" tabindex="-1"><a class="header-anchor" href="#jvm-内存区域的一些概念"><span>JVM 内存区域的一些概念</span></a></h2><h3 id="jvm-内存区域划分" tabindex="-1"><a class="header-anchor" href="#jvm-内存区域划分"><span>JVM 内存区域划分</span></a></h3><p>JDK 8</p><img src="'+k+'" alt="image-20231022225007301" style="zoom:40%;">',5)),i("ol",null,[i("li",null,[n(a,{color:"purple"},{default:t(()=>l[69]||(l[69]=[i("b",null,"程序计数器",-1)])),_:1}),l[71]||(l[71]=s("：是一块较小的内存区域，用于记录当前线程执行的字节码指令地址；")),n(a,{color:"purple"},{default:t(()=>l[70]||(l[70]=[i("b",null,"(线程私有)",-1)])),_:1})]),i("li",null,[n(a,{color:"purple"},{default:t(()=>l[72]||(l[72]=[i("b",null,"Java 虚拟机栈",-1)])),_:1}),l[74]||(l[74]=s("：每个线程在运行时都会创建一个 Java 虚拟机栈，用于存储方法的局部变量、操作数栈、动态链接、方法出口等信息，每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程；")),n(a,{color:"purple"},{default:t(()=>l[73]||(l[73]=[i("b",null,"(线程私有)",-1)])),_:1})]),i("li",null,[n(a,{color:"purple"},{default:t(()=>l[75]||(l[75]=[i("b",null,"本地方法栈",-1)])),_:1}),l[76]||(l[76]=s("：与 Java 虚拟机栈类似，但是用于执行本地方法；"))]),i("li",null,[n(a,{color:"purple"},{default:t(()=>l[77]||(l[77]=[i("b",null,"Java 堆",-1)])),_:1}),l[79]||(l[79]=s("：是 JVM 中最大的一块内存区域，用于存储 Java 对象实例，被所有线程共享；")),n(a,{color:"purple"},{default:t(()=>l[78]||(l[78]=[i("b",null,"(线程共享)",-1)])),_:1})]),i("li",null,[n(a,{color:"purple"},{default:t(()=>l[80]||(l[80]=[i("b",null,"方法区",-1)])),_:1}),l[88]||(l[88]=s("：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据；")),n(a,{color:"purple"},{default:t(()=>l[81]||(l[81]=[i("b",null,"（线程共享）",-1)])),_:1}),i("ol",null,[l[87]||(l[87]=i("li",null,"在 JDK 1.8 之前，方法区也被称为 “永久代”",-1)),i("li",null,[l[84]||(l[84]=s("JDK 1.8 及以后，使用")),n(a,{color:"purple"},{default:t(()=>l[82]||(l[82]=[i("b",null,"元空间（MetaSpace）",-1)])),_:1}),l[85]||(l[85]=s("代替了永久代，元空间使用的是")),n(a,{color:"purple"},{default:t(()=>l[83]||(l[83]=[i("b",null,"本地内存",-1)])),_:1}),l[86]||(l[86]=s("。"))])])]),i("li",null,[n(a,{color:"purple"},{default:t(()=>l[89]||(l[89]=[i("b",null,"运行时常量池",-1)])),_:1}),l[90]||(l[90]=s("：它是方法区的一部分，Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。"))]),i("li",null,[n(a,{color:"purple"},{default:t(()=>l[91]||(l[91]=[i("b",null,"直接内存",-1)])),_:1}),l[92]||(l[92]=s("：JVM 中的一块非 Java 堆区域，用于存储 NIO（New Input/Output）缓冲区；"))])]),l[295]||(l[295]=i("h3",{id:"程序计数器的作用-线程私有吗-是否会发生-oom",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#程序计数器的作用-线程私有吗-是否会发生-oom"},[i("span",null,"程序计数器的作用？线程私有吗？是否会发生 OOM？")])],-1)),i("p",null,[l[94]||(l[94]=s("程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是")),n(a,{color:"purple"},{default:t(()=>l[93]||(l[93]=[i("b",null,"当前线程所执行的字节码的行号指示器",-1)])),_:1}),l[95]||(l[95]=s("。"))]),i("ul",null,[i("li",null,[n(a,{color:"purple"},{default:t(()=>l[96]||(l[96]=[i("b",null,"字节码解释器工作依据",-1)])),_:1}),l[98]||(l[98]=s("：在 JVM 的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。比如在执行顺序结构代码时，程序计数器会依次递增，指向下一条要执行的指令；当遇到条件分支、循环、跳转等语句时，程序计数器会根据具体的逻辑")),n(a,{color:"purple"},{default:t(()=>l[97]||(l[97]=[i("b",null,"将值调整到相应的指令地址",-1)])),_:1}),l[99]||(l[99]=s("，从而实现程序的流程控制。"))]),i("li",null,[n(a,{color:"purple"},{default:t(()=>l[100]||(l[100]=[i("b",null,"线程上下文切换",-1)])),_:1}),l[104]||(l[104]=s("：在多线程环境下，线程是轮流执行的，当一个线程的执行被暂停，另一个线程开始执行时，每个")),n(a,{color:"purple"},{default:t(()=>l[101]||(l[101]=[i("b",null,"线程",-1)])),_:1}),l[105]||(l[105]=s("都需要")),n(a,{color:"purple"},{default:t(()=>l[102]||(l[102]=[i("b",null,"记住",-1)])),_:1}),l[106]||(l[106]=s("自己当前执行到了")),n(a,{color:"purple"},{default:t(()=>l[103]||(l[103]=[i("b",null,"哪一条字节码指令",-1)])),_:1}),l[107]||(l[107]=s("。程序计数器就为每个线程保存了这个执行位置信息，当线程恢复执行时，能够根据程序计数器的值继续从上次中断的地方接着执行。"))])]),l[296]||(l[296]=i("p",null,"线程私有，不会发生 OOM：",-1)),i("ul",null,[i("li",null,[l[109]||(l[109]=s("程序计数器是")),n(a,{color:"purple"},{default:t(()=>l[108]||(l[108]=[i("b",null,"线程私有",-1)])),_:1}),l[110]||(l[110]=s("的；"))]),i("li",null,[n(a,{color:"purple"},{default:t(()=>l[111]||(l[111]=[i("b",null,"不会发生 OOM",-1)])),_:1}),l[113]||(l[113]=s("：程序计数器是唯一一个在 Java 虚拟机规范中没有规定任何 OOM 情况的区域。这是因为程序计数器所占用的内存空间非常小，并且它只是存储一个字节码指令的地址，这个地址是一个相对较小的整数值。")),n(a,{color:"purple"},{default:t(()=>l[112]||(l[112]=[i("b",null,"无论程序如何执行，程序计数器所需要的内存空间都是固定且有限的",-1)])),_:1}),l[114]||(l[114]=s("，不会随着程序的运行而不断增长，因此不会出现内存溢出的情况。"))])]),l[297]||(l[297]=i("h3",{id:"虚拟机栈和本地方法栈-线程私有吗-是否会发生-oom",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#虚拟机栈和本地方法栈-线程私有吗-是否会发生-oom"},[i("span",null,"虚拟机栈和本地方法栈？线程私有吗？是否会发生 OOM？")])],-1)),l[298]||(l[298]=i("p",null,[i("strong",null,"概念")],-1)),i("p",null,[l[116]||(l[116]=s("虚拟机栈和本地方法栈是JVM（Java Virtual Machine）中的两个重要的内存区域，分别用于存储Java方法和本地方法（native method）的执行信息。")),n(a,{color:"blue"},{default:t(()=>l[115]||(l[115]=[i("b",null,"它描述的是 Java 方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）",-1)])),_:1}),l[117]||(l[117]=s("，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。"))]),l[299]||(l[299]=i("blockquote",null,[i("p",null,"虚拟机栈的大小可以通过-Xss参数进行设置；本地方法栈的大小也可以通过-Xoss参数进行设置；")],-1)),l[300]||(l[300]=i("p",null,[i("strong",null,"是否线程私有")],-1)),l[301]||(l[301]=i("p",null,"d欧式线程私有的。每个线程都有自己独立的虚拟机栈，不同线程之间的虚拟机栈互不干扰。这是因为每个线程的执行路径和方法调用序列是独立的，每个线程都需要有自己的栈来记录方法调用的状态和局部变量等信息。",-1)),l[302]||(l[302]=i("p",null,[i("strong",null,"是否会发生 OOM")],-1)),l[303]||(l[303]=i("p",null,"可能会发生两种与内存相关的异常情况：",-1)),i("ul",null,[i("li",null,[n(a,{color:"blue"},{default:t(()=>l[118]||(l[118]=[i("b",null,"StackOverflowError",-1)])),_:1}),l[119]||(l[119]=s("：如果线程请求的栈深度大于虚拟机所允许的深度，就会抛出 ")),l[120]||(l[120]=i("code",null,"StackOverflowError",-1)),l[121]||(l[121]=s(" 异常。例如，在一个递归方法中，如果没有正确的终止条件，递归调用会不断进行，栈帧会不断入栈，最终导致栈深度超过虚拟机限制。"))]),i("li",null,[n(a,{color:"blue"},{default:t(()=>l[122]||(l[122]=[i("b",null,"OutOfMemoryError",-1)])),_:1}),l[123]||(l[123]=s("：如果虚拟机栈可以动态扩展（当前大部分的 Java 虚拟机都可动态扩展），当扩展时无法申请到足够的内存时会抛出 ")),l[124]||(l[124]=i("code",null,"OutOfMemoryError",-1)),l[125]||(l[125]=s(" 异常。不过这种情况相对较少，因为一般情况下栈的扩展是有限制的。"))])]),l[304]||(l[304]=i("h3",{id:"堆-堆的作用",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#堆-堆的作用"},[i("span",null,"堆？堆的作用？")])],-1)),i("p",null,[l[127]||(l[127]=i("strong",null,"定义",-1)),l[128]||(l[128]=s("：Java 堆是虚拟机所管理的内存中最大的一块区域。")),n(a,{color:"purple"},{default:t(()=>l[126]||(l[126]=[i("b",null,"它是被所有线程共享的一块内存区域，在虚拟机启动时创建",-1)])),_:1}),l[129]||(l[129]=s("。"))]),l[305]||(l[305]=i("p",null,[i("strong",null,"作用"),s("：")],-1)),i("ul",null,[i("li",null,[n(a,{color:"purple"},{default:t(()=>l[130]||(l[130]=[i("b",null,"用于存储对象实例",-1)])),_:1}),l[133]||(l[133]=s("。Java 堆是 JVM 中最大的一块内存区域，")),n(a,{color:"purple"},{default:t(()=>l[131]||(l[131]=[i("b",null,"被所有线程共享",-1)])),_:1}),l[134]||(l[134]=s("。它是")),n(a,{color:"purple"},{default:t(()=>l[132]||(l[132]=[i("b",null,"由垃圾回收器进行管理和维护的",-1)])),_:1}),l[135]||(l[135]=s("，可以动态地分配和释放内存。Java 堆的大小可以在启动 JVM 时设置，也可以通过在代码中使用 -Xmx 和 -Xms 这样的命令行选项进行设置；"))]),i("li",null,[n(a,{color:"purple"},{default:t(()=>l[136]||(l[136]=[i("b",null,"垃圾回收的主要区域",-1)])),_:1}),l[138]||(l[138]=s("：由于堆中存储了大量的对象实例，随着程序的运行，会有一些对象不再被引用，成为垃圾对象。Java 堆是垃圾收集器管理的主要区域。")),n(a,{color:"purple"},{default:t(()=>l[137]||(l[137]=[i("b",null,"垃圾收集器会定期或在必要时对堆进行扫描，识别并回收那些不再被引用的对象所占用的内存空间，以保证堆的有效利用",-1)])),_:1}),l[139]||(l[139]=s("。"))])]),i("p",null,[l[142]||(l[142]=i("strong",null,"实现",-1)),l[143]||(l[143]=s("：Java 堆的实现")),n(a,{color:"purple"},{default:t(()=>l[140]||(l[140]=[i("b",null,"通常是基于数组或链表",-1)])),_:1}),l[144]||(l[144]=s("的数据结构，其中每个元素都是一个对象实例。Java 堆的")),n(a,{color:"purple"},{default:t(()=>l[141]||(l[141]=[i("b",null,"内存分配通常是通过指针碰撞或空闲列表实现的",-1)])),_:1}),l[145]||(l[145]=s("。当需要分配内存时，垃圾回收器会搜索堆中的空闲内存块，并将其分配给对象实例。当对象实例不再被引用时，垃圾回收器会将其标记为垃圾，并在需要时将其回收；"))]),i("p",null,[l[147]||(l[147]=i("strong",null,"堆大小",-1)),l[148]||(l[148]=s("：Java 堆的大小对程序的性能和稳定性都有很大的影响。")),n(a,{color:"purple"},{default:t(()=>l[146]||(l[146]=[i("b",null,"如果 Java 堆的大小过小，将会导致频繁的垃圾回收和内存分配，从而降低程序的性能。如果 Java 堆的大小过大，将会浪费系统资源，从而导致系统稳定性的问题",-1)])),_:1}),l[149]||(l[149]=s("。因此，在设置 Java 堆的大小时，需要根据程序的实际情况进行调整；"))]),l[306]||(l[306]=i("h3",{id:"方法区存放的什么东西",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#方法区存放的什么东西"},[i("span",null,"方法区存放的什么东西？")])],-1)),l[307]||(l[307]=i("p",null,[i("strong",null,"方法区概念和存放的内容：")],-1)),i("p",null,[l[152]||(l[152]=s("方法区（Method Area）是 Java 虚拟机中的一块内存区域，用于存储")),n(a,{color:"blue"},{default:t(()=>l[150]||(l[150]=[i("b",null,"类的元数据、静态变量、常量池",-1)])),_:1}),l[153]||(l[153]=s("、即时编译器编译后的代码等数据。它是所有")),n(a,{color:"blue"},{default:t(()=>l[151]||(l[151]=[i("b",null,"线程共享",-1)])),_:1}),l[154]||(l[154]=s("的内存区域，与 Java 堆一样，也是在 Java 虚拟机启动时就被创建的。方法区通常被划分为以下几个部分："))]),i("ol",null,[i("li",null,[n(a,{color:"blue"},{default:t(()=>l[155]||(l[155]=[i("b",null,"运行时常量池",-1)])),_:1}),l[156]||(l[156]=s("：用于存储编译时生成的各种字面量和符号引用。字面量包括字符串常量、基本数据类型的常量值等。符号引用包括类和接口的全限定名、字段的名称和描述符、方法的名称和描述符等"))]),i("li",null,[n(a,{color:"blue"},{default:t(()=>l[157]||(l[157]=[i("b",null,"类的元数据",-1)])),_:1}),l[158]||(l[158]=s("：包括类的全限定名、父类信息、接口信息、字段信息、方法信息等。这些信息描述了类的结构和行为，JVM 在加载类时会将这些信息存储在方法区中。例如，类的字段信息包含了字段的名称、类型、修饰符等；方法信息包含了方法的名称、参数列表、返回类型、方法体的字节码等。"))]),i("li",null,[n(a,{color:"blue"},{default:t(()=>l[159]||(l[159]=[i("b",null,"静态变量",-1)])),_:1}),l[160]||(l[160]=s("：类的静态变量也存储在方法区中。静态变量是属于类的，而不是属于某个对象的，因此所有对象共享这些静态变量。"))]),i("li",null,[n(a,{color:"blue"},{default:t(()=>l[161]||(l[161]=[i("b",null,"即时编译器编译后的代码",-1)])),_:1}),l[162]||(l[162]=s("：JVM 在运行时会使用即时编译器（JIT）将热点代码（频繁执行的代码）编译成机器码，以提高程序的执行效率。编译后的机器码也会存储在方法区中。"))])]),l[308]||(l[308]=i("p",null,[i("strong",null,"方法区的实现方式"),s("：")],-1)),i("ul",null,[i("li",null,[n(a,{color:"blue"},{default:t(()=>l[163]||(l[163]=[i("b",null,"JDK 8 之前",-1)])),_:1}),l[164]||(l[164]=s("：方法区也被称为 “永久代”（Permanent Generation）。永久代有固定的大小限制，可以通过 ")),l[165]||(l[165]=i("code",null,"-XX:MaxPermSize",-1)),l[166]||(l[166]=s(" 参数来设置其最大大小。永久代使用的是 JVM 的堆内存，因此受到堆内存管理的影响。"))]),i("li",null,[n(a,{color:"blue"},{default:t(()=>l[167]||(l[167]=[i("b",null,"JDK 8 及以后",-1)])),_:1}),l[168]||(l[168]=s("：使用元空间（MetaSpace）代替了永久代。元空间使用的是本地内存（Native Memory），而不是 JVM 的堆内存。元空间的大小可以动态扩展，只受限于系统的可用内存。可以通过 ")),l[169]||(l[169]=i("code",null,"-XX:MetaspaceSize",-1)),l[170]||(l[170]=s(" 和 ")),l[171]||(l[171]=i("code",null,"-XX:MaxMetaspaceSize",-1)),l[172]||(l[172]=s(" 等参数来进行配置。"))])]),l[309]||(l[309]=i("h3",{id:"符号引用是什么",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#符号引用是什么"},[i("span",null,"符号引用是什么？")])],-1)),l[310]||(l[310]=i("p",null,"符号引用是一种用来描述所引用目标的符号表示，它是一种抽象的引用形式，并非直接指向内存中的实际地址。",-1)),i("ul",null,[i("li",null,[l[174]||(l[174]=s("编译时，编译器并不知道所引用的类、方法或者字段在运行时的具体内存地址，所以就用")),n(a,{color:"purple"},{default:t(()=>l[173]||(l[173]=[i("b",null,"符号引用来表示这些引用关系",-1)])),_:1}),l[175]||(l[175]=s("。"))]),i("li",null,[l[177]||(l[177]=s("等到类加载过程中，JVM 会把这些符号引用解析成直接引用（即")),n(a,{color:"purple"},{default:t(()=>l[176]||(l[176]=[i("b",null,"实际的内存地址",-1)])),_:1}),l[178]||(l[178]=s("）。"))])]),l[311]||(l[311]=i("p",null,"常见的符号引用的类型：",-1)),i("ul",null,[i("li",null,[n(a,{color:"purple"},{default:t(()=>l[179]||(l[179]=[i("b",null,"类和接口的符号引用",-1)])),_:1}),l[180]||(l[180]=s("：包括类和接口的全限定名、访问修饰符、父类和接口列表等信息；"))]),i("li",null,[n(a,{color:"purple"},{default:t(()=>l[181]||(l[181]=[i("b",null,"字段的符号引用",-1)])),_:1}),l[182]||(l[182]=s("：包括字段所属的类或接口、字段的名称和类型等信息；"))]),i("li",null,[n(a,{color:"purple"},{default:t(()=>l[183]||(l[183]=[i("b",null,"方法的符号引用",-1)])),_:1}),l[184]||(l[184]=s("：包括方法所属的类或接口、方法的名称、参数类型和返回值类型等信息；"))])]),l[312]||(l[312]=i("p",null,"符号引用和直接引用：",-1)),i("ul",null,[i("li",null,[n(a,{color:"purple"},{default:t(()=>l[185]||(l[185]=[i("b",null,"符号引用与直接引用的区别在于，符号引用是一个符号名称，而直接引用则是一个指向具体内存地址的指针",-1)])),_:1}),l[186]||(l[186]=s("。在 Java 虚拟机中，符号引用需要在类加载的过程中被解析成为直接引用，从而使得 Java 代码能够正确地执行；"))])]),l[313]||(l[313]=i("p",null,"在 JVM 中的处理过程:",-1)),i("ul",null,[i("li",null,[n(a,{color:"purple"},{default:t(()=>l[187]||(l[187]=[i("b",null,"编译阶段",-1)])),_:1}),l[188]||(l[188]=s("：Java 源文件编译成字节码文件时，编译器会把代码中对类、方法、字段的引用转换为符号引用，并存储在字节码文件的常量池表中。"))]),i("li",null,[n(a,{color:"purple"},{default:t(()=>l[189]||(l[189]=[i("b",null,"类加载阶段",-1)])),_:1}),l[190]||(l[190]=s("：当 JVM 加载一个类时，会读取字节码文件中的常量池，其中包含了各种符号引用。在类的链接阶段，JVM 会对这些符号引用进行解析，将其转换为直接引用。解析过程可能涉及到查找类的定义、验证引用的合法性等操作。"))]),i("li",null,[n(a,{color:"purple"},{default:t(()=>l[191]||(l[191]=[i("b",null,"运行阶段",-1)])),_:1}),l[192]||(l[192]=s("：在程序运行时，当调用方法或访问字段时，JVM 会使用解析后的直接引用找到对应的内存地址，从而执行相应的操作。"))])]),l[314]||(l[314]=i("h3",{id:"运行时常量池",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#运行时常量池"},[i("span",null,"运行时常量池？")])],-1)),i("p",null,[l[195]||(l[195]=i("strong",null,"定义",-1)),l[196]||(l[196]=s("：运行时常量池是方法区的一部分，它是类或接口的常量池在运行时的表现形式。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是")),n(a,{color:"blue"},{default:t(()=>l[193]||(l[193]=[i("b",null,"常量池表",-1)])),_:1}),l[197]||(l[197]=s("，用于")),n(a,{color:"blue"},{default:t(()=>l[194]||(l[194]=[i("b",null,"存放编译期生成的各种字面量和符号引用",-1)])),_:1}),l[198]||(l[198]=s("，这部分内容在类加载后会存放到方法区的运行时常量池中。"))]),l[315]||(l[315]=i("p",null,[i("strong",null,"每个类或接口有自己的运行时常量池"),s("：方法区是线程共享的。运行时常量池是在类加载时创建，且每个类或接口都有自己独立的运行时常量池。每个类或接口都有自己的运行时常量池，它包含的信息与类或接口的代码有关；")],-1)),l[316]||(l[316]=i("p",null,[i("strong",null,"作用"),s("：")],-1)),i("p",null,[l[202]||(l[202]=s("运行时常量池的主要作用是为 Java 程序提供一种")),n(a,{color:"blue"},{default:t(()=>l[199]||(l[199]=[i("b",null,"动态性的机制",-1)])),_:1}),l[203]||(l[203]=s("，")),n(a,{color:"blue"},{default:t(()=>l[200]||(l[200]=[i("b",null,"使程序可以在运行时动态地加载和使用类、方法和变量等",-1)])),_:1}),l[204]||(l[204]=s("。例如，程序可以通过")),n(a,{color:"blue"},{default:t(()=>l[201]||(l[201]=[i("b",null,"反射机制动态地加载和使用类",-1)])),_:1}),l[205]||(l[205]=s("，通过字符串拼接和反射机制动态地调用方法等；"))]),l[317]||(l[317]=i("h2",{id:"对象的布局、创建流程、生命周期",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#对象的布局、创建流程、生命周期"},[i("span",null,"对象的布局、创建流程、生命周期")])],-1)),l[318]||(l[318]=i("h3",{id:"对象的内存布局",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#对象的内存布局"},[i("span",null,"对象的内存布局")])],-1)),n(e,{id:"mermaid-315",code:"eJxLL0osyFDwCeJSAILknMTiYpfUNIXcxMw8hbTMnBwrZVdTNzM3N53ikqL87FQrZXNjRwRXtzwzpSTDyqigAlV7cWkSVLebm5uZszNct5ubk7OpEQHd+QUlmfl5iTlwI1ydXJ3gRriaWVhammA3Akw4anglliU+Xb/zxcaFmlZWVmC/6OraKThpQASfLtkCE4doAMs6azxdN+/Jvu5nUzc8612HRYELSPvLvROeLlz9tLUVRQGYcIJYYqjhm1iUrRCeX5QCUgMMCmRZI43nG3c/ndf9rKf95aQODAU1QNuf726pUXAy1oAwX07d/3TXMpBCWLAg2WgItdJQ4+nkjqc7ep4vaEQxEiZvpPG0o+3J7sVPd255ua8FqxJjjZdTGp93bXvWgGIERJER1PGGYNe3NiPCCG6OMUSJsSHU3U+XLH+6oR+7u50hAQ50NTg+9IEmPt+yANNQF0i4G2q8WLgUGPAWT9dOf9HVBFMBAFwP+Ug="}),l[319]||(l[319]=i("p",null,"Java 对象的内存布局由三部分组成：对象头、实例数据和对齐填充。",-1)),i("ol",null,[i("li",null,[n(a,{color:"purple"},{default:t(()=>l[206]||(l[206]=[i("b",null,"对象头",-1)])),_:1}),l[213]||(l[213]=s("：对象头是 Java 对象在内存中的开头部分，用于存储对象的元数据信息，包括")),i("ol",null,[i("li",null,[n(a,{color:"purple"},{default:t(()=>l[207]||(l[207]=[i("b",null,"Mark Word",-1)])),_:1}),l[208]||(l[208]=s("：保存了对象的哈希码、对象所属的类的引用、对象锁等信息；"))]),i("li",null,[n(a,{color:"purple"},{default:t(()=>l[209]||(l[209]=[i("b",null,"类型指针",-1)])),_:1}),l[210]||(l[210]=s("Java 虚拟机通过这个指针来确定这个对象是那个类的实例；"))]),i("li",null,[n(a,{color:"purple"},{default:t(()=>l[211]||(l[211]=[i("b",null,"如果对象是数组就有数组长度",-1)])),_:1}),l[212]||(l[212]=s("。"))])])]),i("li",null,[n(a,{color:"purple"},{default:t(()=>l[214]||(l[214]=[i("b",null,"实例数据",-1)])),_:1}),l[216]||(l[216]=s("：实例数据是 Java 对象中实际")),n(a,{color:"purple"},{default:t(()=>l[215]||(l[215]=[i("b",null,"存储的成员变量数据",-1)])),_:1}),l[217]||(l[217]=s("，包括基本类型数据、引用类型数据、数组类型数据等。实例数据的大小取决于对象中包含的成员变量数量和类型，不同的对象实例的实例数据大小可能不同；"))]),i("li",null,[n(a,{color:"purple"},{default:t(()=>l[218]||(l[218]=[i("b",null,"对齐填充",-1)])),_:1}),l[219]||(l[219]=s("：由于 Java 虚拟机要求对象的起始地址必须是 8 字节的整数倍，因此在实例数据末尾可能会添加一些无用的填充字节，以确保对象的大小是 8 字节的整数倍；"))])]),l[320]||(l[320]=i("p",null,"需要注意的是，Java 对象的内存布局可能会受到虚拟机实现的影响，不同的虚拟机实现可能会有不同的实现方式。此外，Java 对象的大小也可能会受到对象头、对齐填充等因素的影响，因此在计算对象的大小时需要考虑这些因素；",-1)),l[321]||(l[321]=i("h3",{id:"对象的创建流程-给对象分配内存时的并发安全问题是如何解决的",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#对象的创建流程-给对象分配内存时的并发安全问题是如何解决的"},[i("span",null,"对象的创建流程？给对象分配内存时的并发安全问题是如何解决的？")])],-1)),n(e,{id:"mermaid-353",code:"eJx1kd9KAkEUxu97igFvNsgLlQr2ItDV7car6gXENCVJcQWDDJT8V2qF+CcqTcPQAjFNCFPZl/HMzr5F46ySuDRXc4bf953vnDkJu0I+5DzYQPS4Ay5Jsnu8KBQOuj2ShLz+QIA3OLbFHVHckiLh4KmHN+xarH+lMeo/jvh4c+icOVg5fN0mzTw680QRzmdm49Ymz/NLP6NxD9k4uGmQ6VTpj5XHJKSuZnITJ3orGHOyzeEYhfDzhyaIIZuJow9aReSM0sn9q4LvwVIlcJBNq6kCpFPQfVDef9TqUKczsWwCKwTtbrrQdLgygsnd5ZpCYIoYnVEtZpXXT1ys01ZmTil1kGA9RLQ7tPpk+KZmCqRXnsk10kvA7Qt073G8vd5/4cbCDSBbJc0OdbNws6k8NzxyWm06iZnFtHPaXJCtQTsH+YqOs2gcK+zs7qAbWdDQG5F+E1q6jTgYKS7+E9eTarxBN4G/yuukyMh9jsgleKovDCdlmnuV/AUoJgyh"}),i("ol",null,[i("li",null,[n(a,{color:"blue"},{default:t(()=>l[220]||(l[220]=[i("b",null,"加载类的元信息",-1)])),_:1}),l[222]||(l[222]=s("：当 Java 程序执行 new 指令时，虚拟机首先会检查该指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的")),n(a,{color:"blue"},{default:t(()=>l[221]||(l[221]=[i("b",null,"类是否已经被加载、解析和初始化过",-1)])),_:1}),l[223]||(l[223]=s("。如果没有，则需要先进行类的加载过程，包括加载、验证、准备、解析和初始化等阶段，确保类的元数据信息已经被正确加载到方法区中。"))]),i("li",null,[n(a,{color:"blue"},{default:t(()=>l[224]||(l[224]=[i("b",null,"分配内存空间",-1)])),_:1}),l[231]||(l[231]=s("：在类加载检查通过后，虚拟机需要为新对象分配内存。对象所需的内存大小在类加载完成后就可以确定。内存的分配方式有两种：")),n(a,{color:"blue"},{default:t(()=>l[225]||(l[225]=[i("b",null,"指针碰撞",-1)])),_:1}),l[232]||(l[232]=s("和")),n(a,{color:"blue"},{default:t(()=>l[226]||(l[226]=[i("b",null,"空闲列表",-1)])),_:1}),l[233]||(l[233]=s("；")),i("ul",null,[i("li",null,[n(a,{color:"blue"},{default:t(()=>l[227]||(l[227]=[i("b",null,"指针碰撞",-1)])),_:1}),l[228]||(l[228]=s("：用 CAS 加失败重试保证分配内存的原子性；"))]),i("li",null,[n(a,{color:"blue"},{default:t(()=>l[229]||(l[229]=[i("b",null,"空闲列表",-1)])),_:1}),l[230]||(l[230]=s("：使用本地线程分配缓冲 TLAB，一个本地缓冲区用完了才回去加上同步锁定去分配新的缓冲区；"))])])]),i("li",null,[n(a,{color:"blue"},{default:t(()=>l[234]||(l[234]=[i("b",null,"内存初始化",-1)])),_:1}),l[236]||(l[236]=s("：内存分配完成后，虚拟机需要将分配到的内存空间都")),n(a,{color:"blue"},{default:t(()=>l[235]||(l[235]=[i("b",null,"初始化为零值",-1)])),_:1}),l[237]||(l[237]=s("（不包括对象头）。这一步保证了对象的实例变量在对象创建时就可以被赋予默认的初始值，使得程序员在使用对象时不需要为每个实例变量都显式地赋初值。"))]),i("li",null,[n(a,{color:"blue"},{default:t(()=>l[238]||(l[238]=[i("b",null,"初始化对象头",-1)])),_:1}),l[241]||(l[241]=s("：在分配内存空间之后，Java 虚拟机会初始化对象头。例如这个对象是")),n(a,{color:"blue"},{default:t(()=>l[239]||(l[239]=[i("b",null,"哪个类的实例",-1)])),_:1}),l[242]||(l[242]=s("、如何才能找到")),n(a,{color:"blue"},{default:t(()=>l[240]||(l[240]=[i("b",null,"类的元数据",-1)])),_:1}),l[243]||(l[243]=s("信息、对象的哈希码、对象的分代年龄等信息。"))]),i("li",null,[n(a,{color:"blue"},{default:t(()=>l[244]||(l[244]=[i("b",null,"执行构造方法",-1)])),_:1}),l[246]||(l[246]=s("：在对象头初始化完成之后，Java 虚拟机会执行对象的构造方法，完成对象的初始化工作。在构造方法中，")),n(a,{color:"blue"},{default:t(()=>l[245]||(l[245]=[i("b",null,"可以对对象的成员变量进行初始化",-1)])),_:1}),l[247]||(l[247]=s("，也可以执行其他操作；"))]),i("li",null,[n(a,{color:"blue"},{default:t(()=>l[248]||(l[248]=[i("b",null,"返回对象引用",-1)])),_:1}),l[249]||(l[249]=s("：在对象初始化完成之后，Java 虚拟机会返回对象的引用，这个引用可以被存储在局部变量、成员变量、静态变量等位置，用于后续的操作。"))])]),l[322]||(l[322]=i("h3",{id:"内存分配的指针碰撞和空闲列表",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#内存分配的指针碰撞和空闲列表"},[i("span",null,"内存分配的指针碰撞和空闲列表")])],-1)),l[323]||(l[323]=i("p",null,[i("strong",null,"指针碰撞"),s("：")],-1)),i("ul",null,[i("li",null,[n(a,{color:"purple"},{default:t(()=>l[250]||(l[250]=[i("b",null,"概念",-1)])),_:1}),l[254]||(l[254]=s("：在")),n(a,{color:"purple"},{default:t(()=>l[251]||(l[251]=[i("b",null,"连续的内存空间",-1)])),_:1}),l[255]||(l[255]=s("中分配变量或对象的方式。在指针碰撞中，Java 虚拟机使用一个")),n(a,{color:"purple"},{default:t(()=>l[252]||(l[252]=[i("b",null,"指针",-1)])),_:1}),l[256]||(l[256]=s("来记录当前")),n(a,{color:"purple"},{default:t(()=>l[253]||(l[253]=[i("b",null,"可用的内存空间的起始地址",-1)])),_:1}),l[257]||(l[257]=s("，每当分配一个对象时，就将指针向后移动对象所需的内存大小，以便为下一个对象分配内存空间。"))]),i("li",null,[n(a,{color:"purple"},{default:t(()=>l[258]||(l[258]=[i("b",null,"优点",-1)])),_:1}),l[259]||(l[259]=s("：实现简单，分配速度快，适合于内存空间较为连续的情况。但是它的缺点也很明显，"))]),i("li",null,[n(a,{color:"purple"},{default:t(()=>l[260]||(l[260]=[i("b",null,"缺点",-1)])),_:1}),l[262]||(l[262]=s("：当内存空间不连续时，就无法使用指针碰撞的方式进行内存分配。此外，指针碰撞还存在")),n(a,{color:"purple"},{default:t(()=>l[261]||(l[261]=[i("b",null,"内存碎片",-1)])),_:1}),l[263]||(l[263]=s("的问题，容易造成内存的浪费；"))]),i("li",null,[n(a,{color:"purple"},{default:t(()=>l[264]||(l[264]=[i("b",null,"适用场景",-1)])),_:1}),l[267]||(l[267]=s("：这种方式适用于使用")),n(a,{color:"purple"},{default:t(()=>l[265]||(l[265]=[i("b",null,"标记-整理",-1)])),_:1}),l[268]||(l[268]=s("算法或者")),n(a,{color:"purple"},{default:t(()=>l[266]||(l[266]=[i("b",null,"复制算法",-1)])),_:1}),l[269]||(l[269]=s("的垃圾收集器，因为这些算法会对内存进行规整，使得内存空间是连续的。例如，在使用 Serial、ParNew 等垃圾收集器时，就可以采用指针碰撞的方式来分配内存。"))]),i("li",null,[n(a,{color:"purple"},{default:t(()=>l[270]||(l[270]=[i("b",null,"并发问题及解决办法",-1)])),_:1}),l[271]||(l[271]=s("：在多线程环境下，指针碰撞可能会出现并发问题，因为多个线程可能同时修改指针的位置。为了解决这个问题，JVM 通常会采用 CAS 加上失败重试的方式来保证内存分配的原子性。也就是说，当一个线程尝试移动指针分配内存时，会先比较指针的当前值是否和预期值相同，如果相同则进行更新操作，否则重试。"))])]),l[324]||(l[324]=i("p",null,[i("strong",null,"空闲列表"),s("：")],-1)),i("ul",null,[i("li",null,[n(a,{color:"purple"},{default:t(()=>l[272]||(l[272]=[i("b",null,"概念",-1)])),_:1}),l[275]||(l[275]=s("：")),n(a,{color:"purple"},{default:t(()=>l[273]||(l[273]=[i("b",null,"空闲列表",-1)])),_:1}),l[276]||(l[276]=s("是一种在")),n(a,{color:"purple"},{default:t(()=>l[274]||(l[274]=[i("b",null,"非连续的内存空间",-1)])),_:1}),l[277]||(l[277]=s("中分配变量或对象的方式。在空闲列表中，Java 虚拟机使用一个链表来记录可用的内存空间，每当分配一个对象时，就从链表中找到一个足够大的内存块，将其分配给对象。"))]),i("li",null,[n(a,{color:"purple"},{default:t(()=>l[278]||(l[278]=[i("b",null,"优点",-1)])),_:1}),l[279]||(l[279]=s("：可以处理非连续的内存空间，避免了指针碰撞的缺点"))]),i("li",null,[n(a,{color:"purple"},{default:t(()=>l[280]||(l[280]=[i("b",null,"缺点",-1)])),_:1}),l[281]||(l[281]=s("：缺点也很明显，即链表的遍历和维护需要消耗时间和空间，分配速度相对较慢；"))]),i("li",null,[n(a,{color:"purple"},{default:t(()=>l[282]||(l[282]=[i("b",null,"适用场景",-1)])),_:1}),l[284]||(l[284]=s("：这种方式适用于使用")),n(a,{color:"purple"},{default:t(()=>l[283]||(l[283]=[i("b",null,"标记-清除",-1)])),_:1}),l[285]||(l[285]=s("算法的垃圾收集器，因为该算法不会对内存进行规整，会产生内存碎片，导致内存空间不连续。例如，CMS（Concurrent Mark Sweep）垃圾收集器就会采用空闲列表的方式来分配内存。"))]),i("li",null,[n(a,{color:"purple"},{default:t(()=>l[286]||(l[286]=[i("b",null,"并发问题及解决办法",-1)])),_:1}),l[288]||(l[288]=s("：为了提高并发性能，JVM 引入了")),n(a,{color:"purple"},{default:t(()=>l[287]||(l[287]=[i("b",null,"本地线程分配缓冲",-1)])),_:1}),l[289]||(l[289]=s("（Thread - Local Allocation Buffer，TLAB）。每个线程都有自己的 TLAB，线程在分配内存时，首先会在自己的 TLAB 中进行分配，这样可以避免多线程之间的竞争。只有当本地缓冲区用完了，线程才会加同步锁去分配新的缓冲区。"))])]),l[325]||(l[325]=r('<h3 id="对象在堆中的生命周期" tabindex="-1"><a class="header-anchor" href="#对象在堆中的生命周期"><span>对象在堆中的生命周期</span></a></h3><ol><li>在 JVM 内存模型的堆中，堆被划分为新生代和老年代（1:1:8） <ul><li>新生代又被进一步划分为 <strong>Eden区</strong> 和 <strong>Survivor区</strong>，Survivor 区由 <strong>From Survivor</strong> 和 <strong>To Survivor</strong> 组成</li></ul></li><li>当创建一个对象时，对象会被<strong>优先分配到新生代的 Eden 区</strong><ul><li>此时 JVM 会给对象定义一个<strong>对象年轻计数器</strong>（<code>-XX:MaxTenuringThreshold</code>）</li></ul></li><li>当 Eden 空间不足时，JVM 将执行新生代的垃圾回收（Minor GC） <ul><li>JVM 会把存活的对象转移到 Survivor 中，并且对象年龄 +1</li><li>对象在 Survivor 中同样也会经历 Minor GC，每经历一次 Minor GC，对象年龄都会+1</li></ul></li><li>如果分配的对象超过了<code>-XX:PetenureSizeThreshold</code>，对象会<strong>直接被分配到老年代</strong></li></ol><h2 id="内存泄漏" tabindex="-1"><a class="header-anchor" href="#内存泄漏"><span>内存泄漏</span></a></h2><h3 id="内存泄漏有那些原因" tabindex="-1"><a class="header-anchor" href="#内存泄漏有那些原因"><span>内存泄漏有那些原因</span></a></h3><p>Java 内存泄漏是指在Java程序运行时，由于对象没有被正确地释放或管理，导致内存空间被占用，最终导致程序崩溃或性能下降的现象。</p><ol><li><strong>对象没有被正确地释放</strong>：Java中的垃圾回收机制可以自动回收不再使用的对象，但如果程序中存在对对象的强引用，即使对象不再使用，垃圾回收机制也无法回收该对象所占用的内存空间，从而导致内存泄漏。 <ul><li><strong>内部类持有外部类的引用</strong>：非静态内部类会隐式持有外部类的引用，若内部类生命周期长于外部类，会使外部类无法被回收。如下例：</li></ul></li><li><strong>集合类使用不当</strong>：Java 中的集合类如 List、Map 等，在使用时需要注意及时清空或移除集合中的元素，否则集合中的元素会一直占用内存空间，导致内存泄漏。 <ul><li><strong>缓存使用不当</strong>：使用缓存时若没有合理的清理机制，缓存中的对象会不断增加并占用内存。例如：</li></ul></li><li><strong>未关闭 IO 流</strong>：Java中的IO流需要手动关闭，如果程序中未正确关闭IO流，就会导致内存泄漏。</li><li><strong>内存泄漏的第三方库</strong>：使用第三方库时，如果该库中存在内存泄漏的问题，就会导致 Java 程序出现内存泄漏。</li></ol><p>为了避免Java内存泄漏，我们需要在程序中<strong>合理地使用对象、集合类、静态变量和IO流，并及时释放不再使用的资源</strong>。同时，在使用第三方库时，也需要仔细查看该库是否存在内存泄漏的问题。</p><h3 id="如何定位内存泄漏" tabindex="-1"><a class="header-anchor" href="#如何定位内存泄漏"><span>如何定位内存泄漏</span></a></h3>',8)),n(a,{color:"purple"},{default:t(()=>l[290]||(l[290]=[s("观察系统表现")])),_:1}),l[326]||(l[326]=r("<ul><li><strong>内存使用监控</strong>：运用系统自带的监控工具（Linux 的 <code>top</code>、<code>htop</code> 或者 <code>free</code> 命令）来实时监控 Java 进程的内存使用状况。要是发现 Java 进程的内存占用持续增长，直至达到系统的物理内存上限，就可能存在内存泄漏问题。</li><li><strong>性能分析</strong>：借助 Java 自带的性能分析工具，例如 <code>jstat</code>、<code>jconsole</code>、<code>jvisualvm</code> 等，来监控 Java 堆内存、非堆内存、GC 频率等指标。若 GC 频率过高，并且每次 GC 后内存占用依旧没有明显下降，这或许意味着存在内存泄漏。</li></ul>",1)),n(a,{color:"purple"},{default:t(()=>l[291]||(l[291]=[s("生成堆转储文件")])),_:1}),l[327]||(l[327]=r('<ul><li><p><strong>手动触发</strong>：在程序运行期间，可以使用 <code>jmap</code> 命令手动触发堆转储文件的生成。例如：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>jmap -dump:format=b,file=heapdump.hprof &lt;pid&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>其中，<code>&lt;pid&gt;</code> 是 Java 进程的进程 ID，<code>heapdump.hprof</code> 是生成的堆转储文件的文件名。</p></li><li><p><strong>自动触发</strong>：也可以通过设置 JVM 参数，当堆内存达到一定阈值时自动生成堆转储文件。例如：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/path/to/dump/file</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>当程序发生 <code>OutOfMemoryError</code> 时，会自动在指定路径下生成堆转储文件。</p></li></ul>',1)),n(a,{color:"purple"},{default:t(()=>l[292]||(l[292]=[s("分析堆转储文件")])),_:1}),l[328]||(l[328]=r('<p>查看泄漏对象到 GC Roots 的引用链，找到泄漏对象是通过什么样的引用路径、与那些 GC Roots 对象关联，才导致垃圾回收器无法回收它们</p><ul><li>Eclipse Memory Analyzer（MAT）：这是一款功能强大的堆转储文件分析工具。它可以帮助你找出内存中占用大量空间的对象、对象之间的引用关系等。</li><li><strong>VisualVM</strong>：除了可以监控 Java 进程的性能指标外，VisualVM 也可以用于分析堆转储文件。在 VisualVM 中导入堆转储文件后，可以查看对象的分布情况、对象的引用关系等。</li></ul><h2 id="gc-垃圾回收" tabindex="-1"><a class="header-anchor" href="#gc-垃圾回收"><span>GC 垃圾回收</span></a></h2><h3 id="如何判断对象已经死亡" tabindex="-1"><a class="header-anchor" href="#如何判断对象已经死亡"><span><strong>如何判断对象已经死亡？</strong></span></a></h3><img src="'+h+'" alt="image-20231023085432401" style="zoom:50%;"><ol><li>可达性分析算法是Java虚拟机中常用的内存管理方式之一，它通过<strong>从一组根对象开始，遍历所有可达对象，将不可达的对象标记为垃圾对象</strong>，最后将垃圾对象回收。可达性分析算法的基本思路是： <ol><li><strong>根对象的选择</strong>：根对象包括静态变量、本地变量和虚拟机栈中的对象引用；</li><li><strong>根对象的遍历</strong>：从根对象开始，沿着对象之间的引用链，遍历所有可达对象，将所有可达的对象标记为存活对象；</li><li><strong>垃圾对象的回收</strong>：遍历完成后，剩下的对象即为垃圾对象，可以被回收；</li></ol></li><li>可达性分析算法的优点是可以处理循环引用的情况，避免了引用计数器的问题。但是，可达性分析算法有一个缺点，就是<strong>在对象引用链较长时，遍历所有对象可能会比较耗时，影响程序的性能</strong>；</li><li>为了提高可达性分析算法的效率，Java虚拟机采用了一些优化策略，如分代回收、增量回收、并发回收等。这些策略可以根据不同的应用场景和硬件环境进行调整，以达到最佳的内存管理效果；</li></ol><h3 id="有哪些对象是-gc-root-对象" tabindex="-1"><a class="header-anchor" href="#有哪些对象是-gc-root-对象"><span><strong>有哪些对象是 GC Root 对象？</strong></span></a></h3><ol><li><strong>虚拟机栈</strong>中引用的对象（栈帧中的本地变量表），<strong>参数</strong>、<strong>局部变量</strong>等，当方法执行完毕后，虚拟机栈中的引用对象也会被回收；</li><li>方法区中的<strong>静态类型属性引用的对象</strong>，譬如 Java 类的引用类型的静态变量；</li><li>在方法区中常量引用的对象，譬如<strong>字符串常量池</strong>；</li><li>本地方法栈中（Native 方法）引用的对象；</li><li>Java 虚拟机内部的引用，如<strong>基本数据类型对应的 Class 对象</strong>，一些<strong>常驻的异常类（空指针，内存溢出）</strong>，还有<strong>类加载器</strong>；</li><li>所有被<strong>同步锁持有的对象</strong>；</li><li>临时加入 GC Root 的对象，例如新生代的某个对象被老年代的对象给引用了，这是老年代的这个对象就会临时视为 GC Root 对象；</li></ol><h3 id="java-的引用有那些-分别的特点是什么" tabindex="-1"><a class="header-anchor" href="#java-的引用有那些-分别的特点是什么"><span><strong>Java 的引用有那些？分别的特点是什么？</strong></span></a></h3><ol><li><strong>强引用（Strong Reference）</strong>：强引用是指在程序中显式地使用 new 操作符创建的对象所持有的引用。只要强引用存在，垃圾回收器就不会回收该对象；</li><li><strong>软引用（Soft Reference）</strong>：软引用是一种有用的引用类型，它可以让对象存活更长的时间，<strong>直到内存不足时才被回收</strong>。在Java中，我们可以使用 SoftReference 类来创建软引用对象；</li><li><strong>弱引用（Weak Reference）</strong>：弱引用是一种比软引用更弱的引用类型，它的生命周期更短，<strong>只要没有强引用或软引用指向该对象，垃圾回收器就会回收该对象</strong>。在Java中，我们可以使用WeakReference类来创建弱引用对象；</li><li><strong>虚引用（Phantom Reference）</strong>：虚引用是一种最弱的引用类型，它几乎没有实际用途，只是用来跟踪对象被垃圾回收的状态，为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。在Java中，我们可以使用PhantomReference类来创建虚引用对象；</li></ol><h3 id="对分代收集理论的理解-为什么要分代-跨代引用问题是如何处理的" tabindex="-1"><a class="header-anchor" href="#对分代收集理论的理解-为什么要分代-跨代引用问题是如何处理的"><span><strong>对分代收集理论的理解？为什么要分代？跨代引用问题是如何处理的？</strong></span></a></h3><p><strong>为什么要分代？</strong></p><ul><li><p>弱分代假说：<strong>绝大多数的对象都是朝生夕灭的，也就是说，大部分对象在创建后很快就不再被使用，会在短时间内成为垃圾对象，可被垃圾回收器回收。</strong></p></li><li><p>强分代假说：<strong>熬过越多次垃圾回收的对象就越难以消亡</strong>，收集器应该按照回收对象的年龄分配到不同的区域之中。还有个是跨代引用相当于同代引用来说占极少数；</p></li></ul><p>基于这两个假说，分代收集理论将堆内存划分为不同的区域，每个区域对应不同生命周期的对象，<strong>针对不同区域采用不同的垃圾回收策略，以提高垃圾回收的效率。</strong></p><p><strong>跨代引用问题</strong>：</p><ul><li>在分代收集的体系下，对象可能存在跨代引用的情况，即<strong>新生代中的对象引用了老年代中的对象，或者老年代中的对象引用了新生代中的对象</strong>。如果在进行垃圾回收时，为了确定某个代中的对象是否存活，需要扫描整个堆来检查跨代引用，会大大增加垃圾回收的开销。例如，在进行新生代垃圾回收时，如果要考虑老年代对象对新生代对象的引用，就需要扫描整个老年代，这会显著降低垃圾回收的效率。</li></ul><p><strong>跨代引用问题是如何处理的？</strong></p><ul><li>跨代引用问题用一个记忆集来处理，在新生代上建立一个全局的记忆集，将老年代分为若干小块，表示出老年代那一块内存有跨代引用，此后发生 Minor GC 的时候，只有包含了跨代引用的小块内的对象才会被假如到 GC Root 中进行扫描；</li></ul><h3 id="说下垃圾清理算法有那些" tabindex="-1"><a class="header-anchor" href="#说下垃圾清理算法有那些"><span><strong>说下垃圾清理算法有那些？</strong></span></a></h3><ol><li><strong>标记-清除算法（Mark-Sweep）</strong>：该算法首先标记所有可达对象，然后清除所有不可达对象。但是该算法存在两个问题：1）标记和清除过程需要<strong>遍历整个堆内存，效率较低</strong>；2）清除后会产生<strong>内存碎片</strong>，不利于后续对象的分配；</li><li><strong>复制算法（Copying）</strong>：该算法将内存分为两个区域，每次只使用其中一个区域，当该区域无法再分配时，将其中的存活对象复制到另一个区域中，然后清除该区域的所有对象。该算法解决了内存碎片问题，但是需要将存活对象复制到另一个区域，导致空间浪费；</li><li><strong>标记-整理算法（Mark-Compact）</strong>：该算法先标记所有可达对象，然后将所有存活对象向一端移动，然后清除该端以外的所有对象。该算法解决了内存碎片问题，但是需要移动存活对象，需要暂停所有的用户线程，导致效率较低；</li><li><strong>分代算法（Generational）</strong>：该算法将内存分为多个年代，每个年代的存活时间不同，一般将新创建的对象放入新生代，存活时间短，然后将存活时间较长的对象放入老年代。<strong>新生代一般采用复制算法，老年代采用标记-整理算法</strong>。该算法充分利用了对象存活时间的特点，提高了垃圾回收效率；</li><li><strong>分区算法（Region）</strong>：该算法将内存分为多个连续的区域，每个区域大小相同，其中一个区域作为当前分配区，当该区域无法分配时，将其中的存活对象复制到另一个区域中，然后将该区域清空。该算法结合了复制算法和标记-整理算法的优点，能够更好地解决内存碎片问题；</li></ol><h3 id="谈谈你对新生代的分区占比的理解-为什么要按这样的比例划分" tabindex="-1"><a class="header-anchor" href="#谈谈你对新生代的分区占比的理解-为什么要按这样的比例划分"><span><strong>谈谈你对新生代的分区占比的理解？为什么要按这样的比例划分？</strong></span></a></h3><ol><li>因为有人专门研究过，<strong>新生代中超过 98%的对象都是熬不过第一次垃圾回收的</strong>，所以并不需要按照 1 : 1 来划分新生代的内存空间；</li><li>所以分为一个大的 Eden 区和两个小的 Survivor 空间，比例是 8 : 1 : 1，所以<strong>只有 10% 的内存浪费</strong>；</li></ol><h3 id="jvm-内存分配策略" tabindex="-1"><a class="header-anchor" href="#jvm-内存分配策略"><span>JVM 内存分配策略</span></a></h3><ul><li><p><strong>对象优先在 Eden 区分配</strong></p><p>大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。</p></li><li><p><strong>大对象直接进入老年代</strong></p><p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，<strong>避免在 Eden 区和 Survivor 区之间的大量内存复制。</strong></p></li><li><p><strong>长期存活的对象进入老年代</strong></p><p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。-XX:MaxTenuringThreshold 用来定义年龄的阈值。</p></li><li><p><strong>动态对象年龄判定</strong></p><p>虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p></li><li><p><strong>空间分配担保</strong></p><p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</p><p>如果不成立的话虚拟机会检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，那么就要进行一次 Full GC。</p></li></ul><h3 id="垃圾回收的安全点的概念-如何让所有线程在垃圾回收前都跑到安全点位置停顿下来" tabindex="-1"><a class="header-anchor" href="#垃圾回收的安全点的概念-如何让所有线程在垃圾回收前都跑到安全点位置停顿下来"><span><strong>垃圾回收的安全点的概念？如何让所有线程在垃圾回收前都跑到安全点位置停顿下来？</strong></span></a></h3><ol><li><strong>用户程序</strong>并<strong>不会</strong>在代码指令流的<strong>任意位置</strong>都能够<strong>停顿</strong>下来进行<strong>垃圾回收</strong>，必须<strong>强制</strong>执行到<strong>安全点</strong>的时候才能够<strong>暂停</strong>，只有在指令序列复用的地方才会产生安全点，例如<strong>方法调用，循环跳转，异常跳转</strong>等；</li><li>抢先式中断：发生垃圾回收时，系统先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程的运行，让他跑到安全点上再中断（这个现在没有虚拟机在用了）；</li><li><strong>主动式中断</strong>：当<strong>垃圾回收</strong>需要<strong>中断线程</strong>的时候，不直接对象线程操作，而是简单的设置一个<strong>标记位</strong>，各个<strong>线程</strong>执行过程中<strong>不断主动去轮询这个标记位</strong>，一旦发现中断标志为真时候就自己在最近的安全点主动挂起；</li></ol><h3 id="垃圾回收有了安全点为什么还要安全区域" tabindex="-1"><a class="header-anchor" href="#垃圾回收有了安全点为什么还要安全区域"><span><strong>垃圾回收有了安全点为什么还要安全区域？</strong></span></a></h3><ol><li>有了安全点，程序就可以在不太长的时间内就可以进到垃圾回收的安全点，但是有的程序可能没抢到 CPU 资源，并不在“执行”的状态（sleep、blocked），这时候线程无法响应虚拟机的中断请求，不能走到安全点来中断挂起自己，显然也不能持续等待线程重新被激活分配处理器时间；</li><li>安全区域指的是确保在某一段代码中，引用关系不会发生变化，因此在这个区域中的任意地方都是可以安全进行垃圾回收的；</li></ol><h3 id="jvm-的卡表-作用是什么-什么时候更新卡表" tabindex="-1"><a class="header-anchor" href="#jvm-的卡表-作用是什么-什么时候更新卡表"><span><strong>JVM 的卡表？作用是什么？什么时候更新卡表？</strong></span></a></h3><ol><li>为了解决<strong>对象跨代引用</strong>所带来的问题，垃圾收集器在新生代中建立了记忆集的数据结构，用于<strong>避免把整个老年代加进 GC Roots 扫描范围</strong>；</li><li>最常用的一种记忆集的实现形式就是卡表了，最简单形式可以只是一个<strong>字节数组</strong>；</li><li>字节数据的每一个元素都对应着其标识的内存区域中的一块特定大小的内存块，这个内存块称为卡页（Card Page），一个卡页的内存通常不止一个对象，只要卡页中至少有一个对象存在跨代指针，就会将对应卡表的数组元素的值标志为 1，称这个元素变脏，没有则标识为 0。在垃圾回收发生时，只要筛选出卡表中变脏的元素，就能简单的得到那些卡页中包含跨代指针，把它们加入到 GC Roots 中一并扫描；</li></ol><h3 id="简单说下-parnew-回收器" tabindex="-1"><a class="header-anchor" href="#简单说下-parnew-回收器"><span><strong>简单说下 ParNew 回收器？</strong></span></a></h3><p>ParNew 回收器是 Serial 回收器的多线程版本，专门用于<strong>新生代</strong>的垃圾回收。它主要应用于多核处理器的环境，借助并行执行垃圾回收任务，有效提升垃圾回收的效率和速度。</p><ul><li><strong>多线程并行回收</strong>：默认情况下，它开启的回收线程数量和处理器核心数一致。若机器核心数量众多，可通过 <code>-XX:ParallelGCThreads</code> 参数对垃圾回收线程数加以限制。</li><li><strong>内存分配策略</strong>：采用基于指针碰撞的内存分配策略。在这种策略下，空闲内存呈现规整排列，所有用过的内存处于一边，空闲的内存处于另一边，中间由一个指针作为分界点。分配内存时，只需将指针向空闲内存一侧移动与对象大小相等的距离即可，这种方式能快速分配内存空间，提高内存分配效率。</li><li><strong>与 CMS 搭配使用</strong>：ParNew 回收器能够和 CMS 垃圾回收器配合使用。CMS 是一款以获取最短回收停顿时间为目标的回收器，追求低延迟。ParNew 负责新生代的垃圾回收，CMS 负责老年代的垃圾回收，二者结合可以在一定程度上实现低延迟的垃圾回收，适合对响应时间要求较高的应用场景。</li></ul><h3 id="吞吐量是什么" tabindex="-1"><a class="header-anchor" href="#吞吐量是什么"><span><strong>吞吐量是什么？</strong></span></a></h3><ol><li>吞吐量（Throughput）是指在<strong>单位时间内完成的任务数量或数据量</strong>。在计算机科学中，吞吐量通常指在一段时间内，计算机系统能够处理的事务或数据量。吞吐量是衡量系统性能的重要指标之一，可以用来评估计算机系统的处理能力和效率；</li><li>在 JVM 中，吞吐量通常用来衡量垃圾回收的效率和性能。 <ul><li>吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 运行垃圾收集时间)；</li><li>以程序运行 100 分钟，其中垃圾回收花费 5 分钟，执行用户代码 95 分钟为例，计算吞吐量的式子为：<br> 吞吐量 = 95 / (95 + 5) × 100% = 95%</li></ul></li><li>在实际应用中，吞吐量不是唯一的性能指标，还需要考虑其他因素，例如延迟、响应时间、并发等。因此，在评估计算机系统或 JVM 垃圾回收器的性能时，需要综合考虑各种因素，并根据应用程序的需求选择合适的性能指标进行评估和优化；</li></ol><p>影响吞吐量的因素</p><ul><li><strong>垃圾回收器的选择</strong>：不同的垃圾回收器具有不同的吞吐量表现。例如，Parallel Scavenge 回收器就是一款以高吞吐量为目标的垃圾回收器，它通过并行回收的方式，减少垃圾回收的时间，从而提高吞吐量。而 CMS（Concurrent Mark Sweep）回收器则更注重低延迟，其吞吐量相对较低。</li><li><strong>堆内存大小</strong>：堆内存的大小会影响垃圾回收的频率和时间。如果堆内存过小，垃圾回收会更加频繁，从而降低吞吐量；如果堆内存过大，一次垃圾回收的时间可能会变长，也会对吞吐量产生影响。因此，需要根据应用程序的特点和系统资源，合理调整堆内存的大小。</li><li><strong>对象创建和销毁的频率</strong>：如果应用程序中对象的创建和销毁频率很高，会导致垃圾回收更加频繁，从而降低吞吐量。例如，在一个频繁创建临时对象的程序中，垃圾回收器需要不断地回收这些对象，会消耗大量的 CPU 资源。</li></ul><h3 id="简单说下-cms-回收器-设计目的-收集过程-优缺点" tabindex="-1"><a class="header-anchor" href="#简单说下-cms-回收器-设计目的-收集过程-优缺点"><span><strong>简单说下 CMS 回收器？设计目的？收集过程？优缺点？</strong></span></a></h3>',38)),n(e,{id:"mermaid-971",code:"eJxLL0osyFDwCeJSAILknMTiYpfUNIXiksSiktS8FIW0zJwcK2U3U1cnNzed4pKi/OxUK2UnVws3VxcoV7c8M6Ukw8qooMIa1YyCovzk1OJiqBGupm5mSEaYGzsiuOhGgAlHjeinexqeLu+O1bSysoI7SFfXTsFJ42nHXKDMswXtL9ZtAElD7QJrdAKrcdZ4unPb0/6J2NU4g9W4aLxs7302bQN2NS5gNa4wc3a0vpy5BF2NK1iNm0b0892Tn82dj+JUmGP0gCpqnjbOeblwf42Ck6HG011Tnk9Z8XxF99Nd/c9mNQFlsNiMosmFkCYAa1GuWg=="}),l[329]||(l[329]=r('<ol><li><p>CMS（Concurrent Mark Sweep）是一种以获取最短回收停顿时间为目标的收集器；</p></li><li><p>CMS回收器的工作方式包括以下几个阶段：</p><ol><li><strong>初始标记</strong>：在此阶段中，垃圾回收器会<strong>遍历整个对象图</strong>，标记所有直接与 GC Roots 关联的对象，将它们标记为&quot;已使用&quot;。（短暂的停顿）</li><li><strong>并发标记</strong>：此阶段<strong>垃圾回收线程与用户线程可以并发执行</strong>。CMS 会从初始标记阶段标记的对象开始，<strong>遍历整个对象图</strong>，标记出所有存活的对象。由于是并发执行，所以在这个过程中用户程序可以继续运行，不会产生明显的停顿；（这个时间耗时较长，但是不需要停顿用户线程）</li><li><strong>重新标记</strong>：由于并发标记阶段可能会出现对象引用关系的变化，所以需要进行重新标记来修正这些标记，<strong>确保所有存活的对象都被正确标记</strong>；（这个阶段停顿的时间通常会比初始标记稍微长一点，但也远比并发标记阶段的时间短）</li><li><strong>并发清除</strong>：在重新标记阶段结束后，垃圾回收器会并发将所有已经死亡的对象清除，因为不需要移动存活的对象，所有这个阶段也是<strong>可以和用户线程并发运行</strong>的；</li></ol></li><li><p>CMS 优点：</p><ol><li><strong>低停顿</strong>：CMS 回收器的最大优点就是低停顿，它通过并发标记和并发清除阶段，让垃圾回收过程与用户程序的执行尽可能地重叠，从而减少了垃圾回收对应用程序响应时间的影响。</li><li><strong>适合对响应时间要求高的应用</strong>：对于那些需要快速响应用户请求的应用，如 Web 服务器、在线交易系统等，CMS 回收器能够提供较好的用户体验。</li></ol></li><li><p>CMS 的缺点：</p><ol><li><strong>对 CPU 资源的占用</strong>：并发阶段虽然不会导致用户线程停顿，但是占用了一部分的处理器的计算能力，这可能会影响用户程序的性能；</li><li><strong>核心数的影响</strong>：CMS 默认启动的回收线程数是 (处理器核心数量 + 3) / 4，也就是说处理器核心数在四个或者以上，并发回收时垃圾回收线程不超过 25% 的处理器运算资源，但是假如当处理器的核心数不足四个时，CMS 对用户的影响就可能变得很大了；</li><li><strong>CMS 无法处理浮动垃圾</strong>：在最后并发清理阶段，用户线程还在继续运行，就可能继续产生垃圾，CMS 垃圾回收器无法再本次回收它们；</li><li><strong>CMS 需要预留部分内存给并发清除阶段的程序运行使用</strong>：因为在垃圾回收阶段用户线程还需要持续运行，那就要预留足够的内存给用户线程使用，因此 CMS 收集器不能像其他收集器那样等到老年代几乎完全使用完了再去收集，必须预留一部分空间给并发收集时的程序使用。老年代到一定的百分比空间后就会触发一次回收，这个值是可以设置的。需要注意的是过高的回收阈值可能会导致CMS无法及时回收垃圾，从而导致大量”并发失败“（并发失败会冻结用户线程的执行，临时启动 Serial Old 收集器进行老年代的垃圾回收），而过低的回收阈值则可能会导致频繁的垃圾回收，影响应用程序的性能。如果老年代的内存增长速度不是很块，就可以适当增大阈值了；</li><li><strong>内存碎片</strong>：CMS垃圾回收器使用了一种称为“标记-清除”的垃圾回收算法，这可能会导致内存碎片的产生，从而降低内存使用效率。因为是“标记-清除”，当内存碎片不够分配某个对象的时候，就会触发一次 Full GC 操作，但是 CMS 提供了一个开关，在 CMS 不得不进行 Full GC 时开启内存碎片的合并整理过程，因为这块内存必须要移动存活的对象，所以这个也是要暂停用户线程的，停顿时间就变长了。 CMS 又提供了一个参数，就是要求 CMS 在执行过若干次不整理空间的 Full GC 之后下一次进入 Full GC 之前会先进行碎片整理（默认为 0 表示每次都整理）；</li></ol></li></ol><h3 id="如何优化-cms-垃圾回收器" tabindex="-1"><a class="header-anchor" href="#如何优化-cms-垃圾回收器"><span><strong>如何优化 CMS 垃圾回收器？</strong></span></a></h3><ol><li><strong>调整堆内存</strong>：合理的堆内存大小能减少垃圾回收的频率，降低因频繁回收导致的性能损耗。**若堆内存过小，垃圾回收会更频繁；若过大，单次垃圾回收的时间会变长。**利用 <code>-Xmx</code> 和 <code>-Xms</code> 参数设置堆的最大和初始大小，尽量让这两个值相等，避免运行时堆大小动态调整带来的性能开销。例如：</li><li><strong>减少并发线程数</strong>：CMS垃圾回收器的并发阶段需要占用一定的CPU资源。如果并发线程数设置过高，可能会导致CPU过度使用，从而影响应用程序的性能。因此，可以适当减少并发线程数，以减轻CPU负担；</li><li><strong>优化垃圾回收器参数</strong>：CMS垃圾回收器有许多参数可以调整， <ol><li>CMSInitiatingOccupancyFraction：指定CMS垃圾回收器在进行CMS垃圾回收之前，堆内存使用率达到多少百分比时触发CMS垃圾回收。默认值为68%，可以根据应用程序的内存使用情况进行调整；</li><li>UseCMSInitiatingOccupancyOnly：如果设置为true，则CMS垃圾回收器只在堆内存使用率达到CMSInitiatingOccupancyFraction时触发CMS垃圾回收。如果设置为false（默认值），则CMS垃圾回收器会根据内存使用情况自动触发CMS垃圾回收。</li><li>CMSFullGCsBeforeCompaction：要求 CMS 在执行过若干次不整理空间的 Full GC 之后下一次进入 Full GC 之前会先进行碎片整理（默认为 0 表示每次都整理）；</li><li>CMSClassUnloadingEnabled：指定是否启用CMS垃圾回收器的类卸载功能。默认值为true，表示启用类卸载功能。如果设置为false，则CMS垃圾回收器不会卸载不再使用的类，从而可能导致内存泄漏；</li><li>UseCMSCompactAtFullCollection：设置 CMS 在完成垃圾收集后是否要进行一次内存碎片整理；</li><li>CMSScavengeBeforeRemark：指定在进行CMS垃圾回收的Remark阶段之前，是否进行一次Young GC。默认值为false，表示不进行Young GC。如果设置为true，则在Remark阶段之前进行一次Young GC，可以减少Remark阶段（重新标记）的停顿时间；</li><li>CMSParallelRemarkEnabled：指定是否启用CMS垃圾回收器的并行Remark功能。默认值为true，表示启用并行Remark功能。如果设置为false，则Remark阶段将会变为串行执行，可能会导致停顿时间的增加；</li><li>ParallelGCThreads：设置并行的垃圾回收线程数，默认（处理器核心数量 + 3）/ 4）；</li></ol></li></ol><h3 id="g1-垃圾回收器简单描述" tabindex="-1"><a class="header-anchor" href="#g1-垃圾回收器简单描述"><span><strong>G1 垃圾回收器简单描述？</strong></span></a></h3><ol><li>在 G1 垃圾回收器出现之前，垃圾回收的目标范围要么是整个新生代（Minor GC），要么就是针对老年代的（Major GC），再要么就是整个 Java 堆（Full GC）。而 G1 面向堆内存任何部分来组成回收集进行回收，衡量标准不再是它属于那个分代，而是那块内存中存放的垃圾数量越多，回收收益最大，这就是 G1 的 Mixed GC 模式；</li><li>G1 也是遵循分代收集理论设计的，把连续的堆划分为多个大小相等的独立区域（Region），每一个 Region 都可以根据需要扮演新生代的 Eden 空间、Survivor 空间，或者老年代空间。收集器能够对扮演不同的角色的 Region 采用不同的策略去处理；</li><li>Region 中有一类特殊的 Humongous 区域，专门用来存储大对象。G1 认为只要大小超过了一个 Region 容量一半的对象即可判断为大对象。每个 Region 的大小可以通过 -XX:G1HeapRegionSize 设定、取值范围为 1MB~32MB，且应该为 2 的 n 次幂。对于那些超过了整个 Region 的容量的超级大对象，将会被存到 N 个连续的 Humongous Region 之中，G1 的大多数行为都把 Humongous Region 作为老年代的一部分来看待；</li><li>虽然 G1 仍然保留新生代和老年代的概念，但是新生代和老年代不再是固定的了，它们都是一系列区域（不需要连续）的动态集合。G1 之所以能够建立可预测的停顿时间模型，是因为它将 Region 作为单次回收的最小单元，即每次收集到的内存空还能都是 Region 大小的整数倍，这样可以有计划的避免在整个 Java 堆中进行全区域的垃圾回收。更具体的思路是让 G1 去跟踪各个 Region 里面的垃圾堆积的“价值”大小，“价值”就是回收所获得的空间大小 以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间（-XX:MaxGCPauseMullis 指定，默认 200ms），优先处理回收价值收益最大的那些 Region，也就是“Garbage First” 的由来。这种使用 Region 划分内存空间，以及具有优先级的区域回收方式，保证了 G1 回收器在有限的时间内获得尽可能高的收集效率；</li></ol><h3 id="g1-垃圾回收器如何处理跨代引用" tabindex="-1"><a class="header-anchor" href="#g1-垃圾回收器如何处理跨代引用"><span><strong>G1 垃圾回收器如何处理跨代引用？</strong></span></a></h3><ol><li>使用记忆集避免全堆作为 GC Roots 扫描，但在 G1 收集器上的记忆集要复杂很多，每个 Region 都需要维护自己的记忆集，这些记忆集会记录下别的 Region 指向自己的指针，并标记这些指针分别在那些卡页的范围之内；</li><li>G1 的记忆集本质上是一个哈希表，key 是别的 Region 的起始地址，value 是一个集合，里面存储的元素是卡表的索引号。（双向卡表结构，卡表是“我指向谁”，这里还要保存“谁指向我”）；</li><li>Region 数量比传统收集器的分代数量要明显增多，因此 G1 收集器要比其他的传统的垃圾收集器有个更高的内存负担。根据经验，G1 至少要耗费大约约相当于 Java 堆容量的 10% 至 20% 的内存来维持收集器的工作；</li></ol><h3 id="三色标记" tabindex="-1"><a class="header-anchor" href="#三色标记"><span><strong>三色标记？</strong></span></a></h3><p>三色概念：</p><ul><li><strong>白色对象</strong>：表示尚未被垃圾回收器访问到的对象。在标记开始阶段，所有对象都被初始化为白色。可以将白色对象看作是 “未知对象”，垃圾回收器还没有对它们进行任何检查。</li><li><strong>灰色对象</strong>：表示已经被垃圾回收器访问到，但该对象引用的其他对象还没有被全部访问完的对象。灰色对象就像是一个 “正在处理” 的中间状态，垃圾回收器会继续从灰色对象出发，去访问它所引用的其他对象。</li><li><strong>黑色对象</strong>：表示已经被垃圾回收器访问到，并且该对象引用的其他对象也都已经被访问完的对象。黑色对象可以被认为是 “已处理对象”，垃圾回收器不会再对黑色对象进行进一步的处理。</li></ul><p>标记过程</p>',11)),n(e,{id:"mermaid-1188",code:"eJyNkE1LAkEcxu9+igEvG+QhQ4sNAvdlunTyKh1E15TEld2FOiplaoklFVhpL4eoS2ZhS7rWp3Fm9dRXaJ3Z1pcwnMPAzDzP7/88s62E03GwGXQBa0WSYVUVpBhQtbCiSakoiCWSSdYNfSIH4aKqKfKOxLo5cRWKgn307CaiWpz1pvfWJhlpRY5IqmojRB/0jyFWlgOj40xEStak3wgQ+nne8UPI8T7vDD/ZAkwIdTPo8XhrgWVZp5DHsw44BhXq1ot5pONMdvhsZyVGjmh4Bt/l+40m2OBBUJY1FaDuhXn+hF7a/df7aQ9PPAKD2jo6qVDnoKrjxvu0UiBK0aajRgkXTqc1ItFAJmQaZ7h+O1FgVJBbYkK4mMG1Is3U++iYl5/94hvRk68jZWlAS+w0Ma9buPww3oemGRKyzT8Enga3CD2jTAXUhfIdq+13t4SahyinO5CBUbE0w/ucTqeYVwc02xzjBPoH1jj0XMUtw2k3wt7so9rXv61F1w8RNT9R"}),l[330]||(l[330]=r('<ul><li><strong>初始阶段</strong>：将所有对象标记为白色。</li><li><strong>标记开始</strong>：从 GC Roots 开始遍历对象图，将 GC Roots 直接引用的对象标记为灰色，并将这些灰色对象放入待处理队列。</li><li><strong>并发标记</strong>：垃圾回收线程从待处理队列中取出一个灰色对象，将其标记为黑色，然后将该对象引用的所有白色对象标记为灰色，并将这些新标记的灰色对象放入待处理队列。重复这个过程，直到待处理队列为空。在这个过程中，用户线程可以继续运行，可能会修改对象之间的引用关系。</li><li><strong>标记结束</strong>：当待处理队列为空时，标记过程结束。此时，所有存活的对象都被标记为黑色，所有未被标记（即仍然为白色）的对象都是垃圾对象，可以被回收。</li></ul><p>三色标记存在的问题：对象漏标：</p><img src="'+v+'" alt="image-20231023101545288" style="zoom:67%;"><p>如果已经被C已经被标记为黑色了，因为是并发标记，此时可能会有线程在C中引用D。此时由于C已经被标记为黑色，不会再扫描D。D会被认为需要回收，此问题会导致系统出问题。</p><p>CMS 为了解决漏标的问题，增量更新的方法（Increment Update）</p><h3 id="并发的可达性分析-并发扫描对象消失问题如何解决-增量更新和原始快照-satb" tabindex="-1"><a class="header-anchor" href="#并发的可达性分析-并发扫描对象消失问题如何解决-增量更新和原始快照-satb"><span><strong>并发的可达性分析？并发扫描对象消失问题如何解决？增量更新和原始快照（SATB）</strong></span></a></h3><ol><li>如果用户线程和收集器是并发工作的，则可能会出现原本是存活的对象被误标记为已消亡的对象；</li><li>下面两个条件同时满足时会出现“对象消失”的现象，也就是原本应该是黑色的对象被误标记位白色； <ol><li><strong>插入条件</strong>：赋值器插入了一条或者多条从黑色对象到白色对象的新引用；</li><li><strong>删除条件</strong>：赋值器删除了全部从灰色对象到该白色对象的直接或间接引用；</li></ol></li><li>解决并发扫描对象消失的问题，只需要破坏上面一个条件就可以了 <ol><li><strong>增量更新要破坏的就是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根重新扫描一次；</strong></li><li>原始快照要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根重新扫描一次；</li></ol></li><li>CMS 基于增量更新来做并发标记的，G1 用原始快照来实现并发标记的；</li></ol><h3 id="g1-垃圾回收器的执行流程" tabindex="-1"><a class="header-anchor" href="#g1-垃圾回收器的执行流程"><span><strong>G1 垃圾回收器的执行流程？</strong></span></a></h3><ol><li>初始标记（Initial Marking）：标记一下 GC Roots 能直接关联到的对象，这个阶段需要暂停用户线程，但是很短暂；</li><li>并发标记（Concurrent Marking）：从 GC Roots 开始对堆中的对象进行可达性分析，递归扫描整个堆的对象图，找出要回收的对象，这个阶段耗时比较长，但是可与用户程序并发执行。对象图扫描完成后，还要重新处理 SATB（原始快照） 记录下的在并发时有引用变动的情况；</li><li>最终标记（Final Marking）：对用户线程一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那些少量的 SATB （原始快照）记录；</li><li>筛选回收（Live Data Counting and Evacution）：负责更新 Region 的统计数据，对每个 Region 的回收价值和成本进行排序，根据用户所期望的停顿时间来指定回收计划，可以自由选择任意多个 Region 构成回收集，然后把决定回收的哪一部分 Region 的存活对象复制到空的 Region 中，再清理掉整个旧 Region 的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集线程并行完成的；</li></ol><h3 id="g1-的停顿时间如何设置" tabindex="-1"><a class="header-anchor" href="#g1-的停顿时间如何设置"><span><strong>G1 的停顿时间如何设置？</strong></span></a></h3><ol><li>一般来说把停顿时间设置为一百，两百都很正常；</li><li>假如把停顿时间设置的很低，比如 20ms，就很可能出现的结果就是由于停顿目标时间太短，导致每次选出来的回收集只占堆内存的很小一部分，收集器收集的速度逐渐跟不上分配器分配内存的速度，导致垃圾慢慢堆积，最终占满堆引发 Full GC 反而减低性能；</li></ol><h3 id="cms-和-g1-比较" tabindex="-1"><a class="header-anchor" href="#cms-和-g1-比较"><span><strong>CMS 和 G1 比较？</strong></span></a></h3><p>设计目标：</p><ul><li><strong>CMS</strong>：以获取最短回收停顿时间为目标。它致力于减少垃圾回收时应用程序的停顿，让系统在运行过程中能更及时地响应用户请求，适用于对响应时间要求较高的应用，如 Web 应用程序、在线交易系统等。</li><li><strong>G1</strong>：旨在实现高吞吐量与低延迟的平衡。G1 既能在一定程度上保证系统的吞吐量，又能将垃圾回收的停顿时间控制在可接受的范围内，适用于大内存、多 CPU 的服务器端应用，能应对各种复杂的业务场景。</li></ul><p>堆内存划分：</p><ul><li><strong>CMS</strong>：采用传统的分代划分方式，将堆内存严格分为新生代和老年代。新生代又可细分为 Eden 区和两个 Survivor 区，不同代采用不同的垃圾回收策略，新生代通常使用复制算法，老年代使用标记 - 清除算法。</li><li><strong>G1</strong>：打破了传统的分代划分，将堆内存划分为多个大小相等的独立区域（Region）。每个 Region 可以根据需要扮演 Eden 区、Survivor 区、老年代或 Humongous Region（用于存储大对象）的角色，这种划分方式更加灵活，能更好地应对大内存和多 CPU 环境。</li></ul><p>垃圾复制算法：</p><ul><li><strong>CMS</strong>：老年代采用标记 - 清除算法。该算法分为初始标记、并发标记、重新标记和并发清除四个阶段。其中，初始标记和重新标记阶段会导致应用程序短暂停顿，并发标记和并发清除阶段可以与用户线程并发执行，从而减少整体的停顿时间。但标记 - 清除算法会产生内存碎片，可能导致后续大对象分配失败。</li><li><strong>G1</strong>：整体采用标记 - 整理算法，局部（Region 之间）采用复制算法。在垃圾回收过程中，G1 会根据各个 Region 的回收价值和成本进行排序，优先回收价值高的 Region。通过复制算法将存活的对象复制到其他空闲的 Region 中，然后清理掉被回收的 Region，避免了内存碎片的产生。</li></ul><ol><li><strong>G1 垃圾回收器是面向整堆的，而 CMS 是面向老年代的</strong>；</li><li>与 CMS 的“标记-清除”不同，**G1 从整体上看是基于“标记-整理”<strong>算法实现的回收器，但是从</strong>局部（两个 Region 之间）又是基于“标记-复制”**算法实现，无论如何，这两种算法都意味着 G1 运行期间不会产生内存空间碎片，垃圾收集完成之后能提供规整的内存；</li><li>在用户程序运行过程中，G1 无论是为了垃圾收集产生的内存占用还是程序运行时的额外负载都要比 CMS 高； <ol><li>就内存占用上来说。由于 G1 的卡表要比 CMS 的复杂。因为 CMS 只需要处理老年代到新生代的跨代引用问题，反过来不需要存。而 G1 因为每个 Region 在不同时刻扮演的角色不一样（新生代老年代），都必须有一份卡表，这导致 G1 的记忆集（和其他内存消耗）可能会占整堆的 20%，甚至更多；</li><li>在执行负载角度上。CMS 写后屏障维护卡表信息，而 G1 也是用写后屏障维护卡表信息，但是 G1 的卡表要比 CMS 的复杂。而且为了使用原始快照（SATB）算法，还需要写前屏障来跟踪并发时的指针变化情况。</li></ol></li><li>在小内存的应用上 CMS 的表现大概率仍然要优于 G1，而在大内存的应用上 G1 则大多发挥它的优势，这个优势的平衡点通常在 6GB 和 8GB 之间。</li></ol><h3 id="你们公司生产用的什么垃圾回收器的组合-为什么这样选" tabindex="-1"><a class="header-anchor" href="#你们公司生产用的什么垃圾回收器的组合-为什么这样选"><span><strong>你们公司生产用的什么垃圾回收器的组合？为什么这样选？</strong></span></a></h3><p>线上 service 使用的垃圾回收器</p><ul><li>新生代：UseParNewGC；</li><li>老年代：UseConcMarkSweepGC；</li></ul><p>进程信息</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>tomcat   13195     1 88 06:46 ?        03:25:32 /opt/java/jdk/bin/java -Xms12g -Xmx12g -Xmn3g -Xss512k -XX:+ExplicitGCInvokesConcurrent -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=70 -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=5 -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=15 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/data/soft/logs/bak -Xloggc:/data/soft/logs/gc.log.20230703_064617 -Djava.net.preferIPv4Stack=true -classpath /手动打码/WEB-INF/classes:/手动打码/WEB-INF/lib/* com.uxin.zb.bootstrap.Provider</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>根据提供的信息，这是关于Tomcat服务器的启动命令和参数配置。下面是对该命令和参数的分析：</p><ul><li><code>-Xms12g</code>：设置JVM的初始堆大小为12GB。</li><li><code>-Xmx12g</code>：设置JVM的最大堆大小为12GB。</li><li><code>-Xmn3g</code>：设置新生代（Young Generation）的大小为3GB。</li><li><code>-Xss512k</code>：设置线程栈大小为512KB。</li><li><code>-XX:+ExplicitGCInvokesConcurrent</code>：启用显式触发并发垃圾回收。</li><li><code>-XX:+UseParNewGC</code>：指定使用并行的新生代垃圾回收器。</li><li><code>-XX:+UseConcMarkSweepGC</code>：指定使用并发标记-清除（CMS）垃圾回收器。</li><li><code>-XX:CMSInitiatingOccupancyFraction=70</code>：设置CMS垃圾回收器触发标记阈值为70%。</li><li><code>-XX:+UseCMSCompactAtFullCollection</code>：指定在进行完整垃圾收集时使用压缩算法。</li><li><code>-XX:CMSFullGCsBeforeCompaction=5</code>：设置在进行压缩前进行完整垃圾回收的次数为5次。</li><li><code>-XX:+PrintGCDetails</code>：打印详细的垃圾回收信息。</li><li><code>-XX:+PrintGCDateStamps</code>：打印垃圾回收事件的日期时间戳。</li><li><code>-XX:SurvivorRatio=8</code>：设置幸存者空间（Survivor Space）与伊甸园空间（Eden Space）的大小比例为8:1。</li><li><code>-XX:MaxTenuringThreshold=15</code>：设置对象晋升到老年代的最大年龄阈值为15。</li><li><code>-XX:+HeapDumpOnOutOfMemoryError</code>：在发生OutOfMemoryError时生成堆转储文件。</li><li><code>-XX:HeapDumpPath=/data/soft/logs/bak</code>：指定堆转储文件的路径为<code>/data/soft/logs/bak</code>。</li><li><code>-Xloggc:/data/soft/logs/gc.log.20230703_064617</code>：将GC日志输出到<code>/data/soft/logs/gc.log.20230703_064617</code>文件中。</li><li><code>-Djava.net.preferIPv4Stack=true</code>：设置Java虚拟机首选使用IPv4网络栈。</li><li><code>-classpath /手动打码/WEB-INF/classes:/手动打码/WEB-INF/lib/*</code>：指定类路径，包括应用程序的类和依赖库。</li><li><code>com.uxin.zb.bootstrap.Provider</code>：要启动的主类。</li></ul><h2 id="jvm-相关的命令" tabindex="-1"><a class="header-anchor" href="#jvm-相关的命令"><span>JVM 相关的命令</span></a></h2><h3 id="jps-的作用-常用的参数选项-jdk8" tabindex="-1"><a class="header-anchor" href="#jps-的作用-常用的参数选项-jdk8"><span><strong>jps 的作用？常用的参数选项？</strong>（JDK8）</span></a></h3><ol><li>查看正在进行的 java 进程；</li><li>主要的参数有 -m、-v、-l； <ol><li>jps -m：显示传递给 main 方法的参数；</li><li>jps -l：显示应用 main 方法的完整包名或应用程序 JAR 文件的完整路径名；</li><li>jps -v：显示传递给 JVM 的参数。如堆大小、垃圾回收器等配置参数。</li></ol></li></ol><h3 id="jmap-的作用-常用的参数选项-jdk8" tabindex="-1"><a class="header-anchor" href="#jmap-的作用-常用的参数选项-jdk8"><span><strong>jmap 的作用？常用的参数选项？（JDK8）</strong></span></a></h3><blockquote><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jmap.html%EF%BC%9B" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jmap.html；</a></p></blockquote><p>用于打印堆内存的详细信息；</p><ol><li><code>jmap -histo[:live]</code>：打印当前堆中的对象信息，:live 表示只打印存活的对象；</li><li><code>jmap -heap</code>：查看当前堆的信息，老年代、新生代个已使用占它们的总内存的百分比，还可以看到元空间信息；假如是用的 G1，可以看到每个 Region 的大小；</li><li><code>jmap -dump:live, format=b, file=文件名</code>：dump 指定 pid 的堆快照；</li><li>教你怎么使用 MAT，<a href="https://eclipsesource.com/blogs/2013/01/21/10-tips-for-using-the-eclipse-memory-analyzer%EF%BC%9B" target="_blank" rel="noopener noreferrer">https://eclipsesource.com/blogs/2013/01/21/10-tips-for-using-the-eclipse-memory-analyzer；</a></li></ol><h3 id="jstat-的作用-常用的参数选项-jdk8" tabindex="-1"><a class="header-anchor" href="#jstat-的作用-常用的参数选项-jdk8"><span><strong>jstat 的作用？常用的参数选项？（JDK8）</strong></span></a></h3><blockquote><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html%EF%BC%9B" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html；</a></p></blockquote><p>用于查看 JVM 的统计信息；</p><ol><li>jstat -options：查看所有支持查询 JVM 统计信息的选项；</li><li>jstat -class：查看类加载信息；</li><li>jstat -gc：查看垃圾回收信息，例如 survivor 1 和 2 容量、survivor 1 和 2 已使用内存、eden 区容量和已使用的，老年代容量和已使用的，元空间容量和已使用的，新生代垃圾回收次数和时间，老年代垃圾回收次数和时间；</li><li>jstat -gccapacity：能看到和 -gc 类似的东西，大差不差；</li><li>jstat -gcutil：垃圾收集统计摘要，主要看的是 survivor 1 占用 survivor 1 的百分比，其他的 survivor 2、eden 区、老年代的百分比，然后新生代和来年代垃圾回收次数和时间；</li><li>jstat -gccause：除了能看到 -gcutil 的所有内容，还能看到上次垃圾回收的原因和本次垃圾回收的原因；</li><li>jstat -gcnew：新生代的统计信息；</li><li>jstat -gcold：老年代的统计信息；</li><li>jstat -gcmetacapacity：元空间；</li></ol><h3 id="jstack-的作用-常用的参数选项-jdk8" tabindex="-1"><a class="header-anchor" href="#jstack-的作用-常用的参数选项-jdk8"><span><strong>jstack 的作用？常用的参数选项？（JDK8）</strong></span></a></h3><blockquote><p>教你怎么排查线上 CPU 100% 问题；</p><p><a href="https://cloud.tencent.com/developer/article/1546726" target="_blank" rel="noopener noreferrer">https://cloud.tencent.com/developer/article/1546726</a></p></blockquote><ol><li>确认高 CPU 占用情况</li></ol><ul><li><p><strong>使用系统监控工具</strong>：在 Linux 系统中，常用 <code>top</code> 命令来实时监控系统的 CPU 使用情况。执行 <code>top</code> 命令后，按 <code>P</code> 键可以按照 CPU 使用率对进程进行排序，找到占用 CPU 最高的进程。</p></li><li><p><strong>确定问题进程</strong>：记录下占用 CPU 最高的进程的 PID（进程 ID），后续的排查将围绕该进程展开。</p></li></ul><ol start="2"><li>定位高 CPU 占用的线程</li></ol><ul><li><p><strong>找出高 CPU 线程</strong>：使用 <code>top -Hp &lt;PID&gt;</code> 命令查看指定进程中每个线程的 CPU 使用情况，其中 <code>&lt;PID&gt;</code> 是上一步记录的进程 ID。按 <code>P</code> 键同样可以按照 CPU 使用率对线程进行排序，找出占用 CPU 最高的线程。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>top -Hp 1234  # 假设 1234 是问题进程的 PID</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><strong>记录高 CPU 线程的 TID</strong>：记录下占用 CPU 最高的线程的 TID（线程 ID），后续需要将其转换为 16 进制格式。</p></li></ul><ol start="3"><li>将线程 ID 转换为 16 进制</li></ol><ul><li><p><strong>转换命令</strong>：使用 <code>printf &quot;%x\\n&quot; &lt;TID&gt;</code> 命令将线程 ID 转换为 16 进制格式，其中 <code>&lt;TID&gt;</code> 是上一步记录的线程 ID。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>printf &quot;%x\\n&quot; 5678  # 假设 5678 是高 CPU 线程的 TID</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>执行该命令后，会输出对应的 16 进制值，例如 <code>162e</code>。</p></li></ul><ol start="4"><li>获取进程的线程堆栈信息</li></ol><ul><li><p><strong>使用 <code>jstack</code> 命令</strong>：如果问题进程是 Java 进程，可以使用 <code>jstack &lt;PID&gt;</code> 命令获取该进程的线程堆栈信息，并将其输出到一个文件中。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>jstack 1234 &gt; thread_dump.log  # 假设 1234 是问题进程的 PID</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul><ol start="5"><li>在线程堆栈信息中定位问题代码</li></ol><ul><li><p><strong>查找线程信息</strong>：打开上一步生成的 <code>thread_dump.log</code> 文件，使用 <code>grep</code> 命令结合第 3 步得到的 16 进制线程 ID 查找对应的线程信息。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>grep &#39;0x162e&#39; thread_dump.log  # 假设 0x162e 是转换后的 16 进制线程 ID</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><strong>分析调用栈</strong>：在找到的线程信息中，查看线程的调用栈，从栈顶开始分析，找出可能导致 CPU 占用过高的代码方法。通常，长时间运行的循环、递归调用、死锁等问题都可能导致 CPU 使用率过高。</p></li></ul><h3 id="jinfo-的作用-常用的参数选项-jdk8" tabindex="-1"><a class="header-anchor" href="#jinfo-的作用-常用的参数选项-jdk8"><span><strong>jinfo 的作用？常用的参数选项？（JDK8）</strong></span></a></h3><ol><li><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jinfo.html" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jinfo.html</a></li><li>no-option：Prints both command-line flags and system property name-value pairs.</li><li>-flag name：Prints the name and value of the specified command-line flag.</li><li>-flag [+|-]name：enables or disables the specified Boolean command-line flag.</li><li>-flag name=value：Sets the specified command-line flag to the specified value.</li><li>-flags：Prints command-line flags passed to the JVM.</li><li>-sysprops：Prints Java system properties as name-value pairs.</li></ol><h3 id="如何查看-jvm-的一些参数的默认值" tabindex="-1"><a class="header-anchor" href="#如何查看-jvm-的一些参数的默认值"><span><strong>如何查看 JVM 的一些参数的默认值？</strong></span></a></h3><ol><li>java -XX:+PrintFlagsFinal</li></ol><h2 id="class-文件结构" tabindex="-1"><a class="header-anchor" href="#class-文件结构"><span>Class 文件结构</span></a></h2><h3 id="class-类文件结构" tabindex="-1"><a class="header-anchor" href="#class-类文件结构"><span><strong>Class 类文件结构</strong></span></a></h3><ol><li>Class 文件是一组以 8 个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符。当遇到需要占用 8 个字节以上的空间的数据项时，则会按照高位在前（大端）的方式分割成若干个 8 个字节进行存储；</li><li>魔数（Magic Number）：4个字节，用于标识文件类型，固定值为0xCAFEBABE；</li><li>次版本号（Minor Version）：2个字节，用于标识Class文件的次版本号；</li><li>主版本号（Major Version）：2个字节，用于标识Class文件的主版本号；</li><li>常量池容量（Constant Pool count）：2 个字节；</li><li>常量池（Constant Pool）：变长，用于存放Java类中的常量，如字符串、数字、类名、字段名、方法名等；</li><li>访问标志（Access Flags）：2个字节，用于标识Java类中的访问修饰符，如public、private、final等；</li><li>类索引（This Class）：2个字节，用于标识当前类在常量池中的索引；</li><li>父类索引（Super Class）：2个字节，用于标识当前类的父类在常量池中的索引；</li><li>接口索引个数（interface count）：2个字节；</li><li>接口索引集合（Interfaces）：2个字节，用于标识当前类实现的接口在常量池中的索引集合；</li><li>字段表个数（Fields count）：2 个字节；</li><li>字段表集合（Fields）：变长，用于存放Java类中的字段信息，如字段名、字段类型、访问修饰符等。</li><li>方法表个数（Methods）：2 个字节；</li><li>方法表集合（Methods）：变长，用于存放Java类中的方法信息，如方法名、返回类型、参数类型、问修饰符等。</li><li>属性表个数（Attributes count）：2 个字节；</li><li>属性表集合（Attributes）：变长，用于存放Java类中的属性信息，如源代码行数、调试信息等。</li></ol><h3 id="class-文件的常量池里面存的是什么" tabindex="-1"><a class="header-anchor" href="#class-文件的常量池里面存的是什么"><span><strong>Class 文件的常量池里面存的是什么？</strong></span></a></h3><ol><li><p>常量池主要存放两大类常量：字面量和符号引用；</p></li><li><p>字面量：如文本字符串、被声明为 final 的常量值等；</p></li><li><p>符号引用：主要包括以下几个几种常量：</p><ol><li>被模块导出或开放的包；</li><li>类和接口的全限定名；</li><li>字段的名称和描述符（类型和修饰符）；</li><li>方法的名称和描述符（参数类型和返回类型）；</li><li>方法句柄（函数式编程，对方法的引用，可以将一个方法作为一个对象来传递和调用）和方法类型（方法名、参数类型和返回类型）；</li><li>动态调用点和动态常量；</li></ol></li><li><p>常量池的作用是提供Java类的基本信息，是Java虚拟机解析Java类的重要依据。在Java虚拟机加载Java类时，会先解析常量池中的信息，然后才能正确加载和执行Java类；</p></li></ol><h3 id="class-文件中的访问标志" tabindex="-1"><a class="header-anchor" href="#class-文件中的访问标志"><span><strong>Class 文件中的访问标志？</strong></span></a></h3><ol><li>ACC_PUBLIC：是否是 public 类型；</li><li>ACC_FINAL：是否被声明为 final，只有类可以设置；</li><li>ACC_SUPER：略；</li><li>ACC_ABSTRACT：是否是抽象类型，对于接口和抽象类来说，此标志为真，其他类型值为假；</li><li>ACC_INTERFACE：标识这是一个接口；</li><li>ACC_SYNTHETIC：标识这个类并非由用户代码产生的；</li><li>ACC_ANNOTATION：表示这是一个注解；</li><li>ACC_ENUM：表示这是一个枚举；</li><li>ACC_MODULE：标识这是一个模块；</li></ol><h3 id="class-文件中类索引、父类索引、接口索引集合" tabindex="-1"><a class="header-anchor" href="#class-文件中类索引、父类索引、接口索引集合"><span><strong>Class 文件中类索引、父类索引、接口索引集合？</strong></span></a></h3><ol><li>Class 文件通过这三项数据来确定该类型的继承关系；</li><li>类索引：用于确定这个类的全限定类名；</li><li>父类索引：用于确定这个类的父类的全限定名，由于 Java 不支持多重继承，所以父类索引只有一个；</li><li>接口索引集合：通过该索引集合来确定该类的实现接口；</li></ol><h3 id="class-文件中字段表集合" tabindex="-1"><a class="header-anchor" href="#class-文件中字段表集合"><span><strong>Class 文件中字段表集合？</strong></span></a></h3><ol><li>字段表用于描述接口或者类中声明的变量。Java 语言中的字段包括类级变量以及实例级变量，但不包括方法内部声明的局部变量；</li><li>字段访问标志：字段可以包括的修饰符有字段的作用域（public、private、protected）、是实例变量还是类变量（static）、可变性（final）、并发可见性（volatile）、是否被序列化（transient）、字段数据类型（基本类型、对象、数组）、字段名称；</li><li>跟随字段访问标志的是两项索引值，name_index 和 descriptor_index。它们都是对常量池项的引用，分别代表着字段的简单名称以及字段和方法的描述符；描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型、以及顺序）和返回值；</li></ol><h3 id="class-文件中方法表集合" tabindex="-1"><a class="header-anchor" href="#class-文件中方法表集合"><span><strong>Class 文件中方法表集合？</strong></span></a></h3><ol><li>和字段表一样，包括访问标志，名称索引、描述符索引、属性表集合等几项；</li><li>访问标志：public、private、protected、static、final、Synchronized、bridge、varargs、native、abstract、strict、synthetic；</li><li>方法的定义可通过访问标志、名称索引、描述符索引来表达清楚，方法里面的代码经过 Javac 编译成字节码指令后，存放在方法属性表集合中的一个名为“Code”的属性中；</li></ol><h2 id="类加载机制" tabindex="-1"><a class="header-anchor" href="#类加载机制"><span>类加载机制</span></a></h2><h3 id="什么是类加载机制" tabindex="-1"><a class="header-anchor" href="#什么是类加载机制"><span><strong>什么是类加载机制？</strong></span></a></h3><ol><li>JVM 把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这个过程被称为虚拟机的类加载机制；</li></ol><h3 id="类加载的流程" tabindex="-1"><a class="header-anchor" href="#类加载的流程"><span><strong>类加载的流程？</strong></span></a></h3><figure><img src="'+A+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>',71)),n(e,{id:"mermaid-2082",code:"eJyVk1tPGkEUx9/9FJv4sk2qqTbYhjQmArs0TfrW9IX0ARXUlgBh6e0NKrfqIpsqF6EoVFtIKyhpQa7lw5QzO/stOjuD6FqbpvOwuzNn5nf+539m1wJO/zr3xDbFkbHicUqSzeXmpKAzEHR5Vzn3hsdjnhZNgkUUb0vBgO+FyzxtEe6Lgm08nXm9sRpcN8/73xgR/oBvxSVJY4JgEheuEO7dXbqc/o3g9QVdFwJEccFqnRwXRYvVNP+P49LLZV3DmOCmY0K4Q4eRMDcm0McS74B+CCrbz26ZzeaJHzMzi5yFh60SHgz0wLhKesRCo1Ze2/2Jdj5fjxI5zGsW1nItVG+ySPCtx2VY/n/NNl77KuPTMBU7LpyqoVGBh3gMjuM3R0UeV47QgXJzlFRN31a6ZuchUSSugJy5XqCdbnjIO9TeLioeGny79NUyxzu0UB4P42qjp+YjEK1q+wrU86Ak8c45pDKjroyHBUi0oJbFW+9QM/xgObAIZ7HJHA9OSP5Ru4syHfQ9DXIXDxVcllG2hdJnKFnXFRxE6LGPVSjFRu2auneIEgr33PnKOetxetdmrfo94eC0gxtlqpVeN9pf5igRqpbro2GR5VVLYZSJj3ot9eQLKAnu0dPHHK5EsLxJ88hRUL6xDajUh37qVygM0U2mR/++gJBvnZA6h35a3auythkFsJ9RIAJIjcwmrbiPCCSV0+IpSMS0aBJiUajloNOaNIRs1no5XD+GUN8IFFifCVC3sd0mENQo6a7kI1fFoMIQJT/pSQs/yGVki0aUyHpNUOh9hXj+pzzc3CYC4IPMFke9I1I1FLNGjn3qN7cuBFA="}),l[331]||(l[331]=r('<ol><li>加载；</li><li>连接：验证、准备、解析；</li><li>初始化；</li></ol><p>其中类加载的过程包括了<strong>加载、验证、准备、解析、初始化</strong>五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定(也成为动态绑定或晚期绑定)*。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><ul><li><strong>类的加载</strong>: 通过类的全限定名（包括包名和类名）来获取该类的二进制字节流，并将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构，同时在堆中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为方法区中这些数据的访问入口。</li><li><strong>连接</strong><ul><li>验证: 确保被加载的类的正确性。主要目的是确保加载的字节码文件符合 JVM 的规范，不会对 JVM 的安全造成威胁。</li><li><strong>准备</strong>: 为类的静态变量分配内存，并将其初始化为默认值。对于 <code>public static int value = 123;</code> 这个静态变量，在准备阶段，<code>value</code> 会被初始化为 0，而不是 123。真正赋值为 123 的操作是在初始化阶段完成的。</li><li><strong>解析</strong>: 把类的常量池中的符号引用转换为直接引用。符号引用是一种用符号来表示引用目标的方式，它与目标的实际内存地址无关；直接引用则是直接指向目标的内存地址。</li></ul></li><li><strong>初始化</strong>：为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。JVM 会执行类的初始化代码，包括静态变量的赋值和静态代码块的执行。这些代码是在编译时由编译器自动收集并放在类的 <code>&lt;clinit&gt;()</code> 方法中的。</li><li><strong>使用</strong>： 类访问方法区内的数据结构的接口， 对象是Heap区的数据</li><li><strong>卸载</strong>： 结束生命周期</li></ul><h3 id="类加载过程的加载部分" tabindex="-1"><a class="header-anchor" href="#类加载过程的加载部分"><span><strong>类加载过程的加载部分？</strong></span></a></h3><ol><li>类加载阶段，虚拟机主要做下面三件事情： <ol><li>通过类的全限定名来查找并加载类的二进制字节流；</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；（此时方法区内有类型数据、静态变量、常量等信息）</li><li>在 Java 堆中生成一个代表这个类的 java.lang.Class 实例，作为方法区这个类的各个数据访问入口；</li></ol></li><li>加载阶段的二进制流从哪里获取呢？ <ol><li>从 zip 包中读取，这也是日后 jar、war 格式的基础；</li><li>从网络中获取；</li><li>动态代理技术，运行时计算生成；等等；</li></ol></li></ol><h3 id="类加载过程的连接阶段的验证阶段" tabindex="-1"><a class="header-anchor" href="#类加载过程的连接阶段的验证阶段"><span><strong>类加载过程的连接阶段的验证阶段？</strong></span></a></h3><ol><li>目的：确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束，保证这些信息被当做代码运行后不会危害虚拟机自身的安全；</li><li>检验动作： <ol><li>文件格式校验：是否符合 Class 文件格式，并且能够被当前版本的虚拟机处理，（魔数、主次版本号等等），这部分主要目的是保证输入的字节流能正确的解析并存储到方法区中，格式上符合描述一个 Java 类型信息的要求。这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证之后，这段字节流才被允许进入 Java 虚拟机内存的方法区中进行存储；</li><li>元数据验证：对字节码描述的信息进行语义分析，保证它的描述信息符合《Java 语言规范》，例如是否有父类，父类是否继承了不被允许继承的 final 类，不是抽象类的类是否实现了所有父接口或父类的抽象方法等等；</li><li>字节码验证：这阶段对类的方法体进行校验分析（Class 文件中的 Code 属性），保证被校验类的方法在运行时不做出危害虚拟机安全的行为；（例如校验类型转换的正确性）</li><li>符号引用验证：符号引用验证可以看成是对类自身以外（常量池中的各种引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。（例如符号引用中的类、字段、方法的可访问性）</li></ol></li></ol><h3 id="类加载过程的连接阶段的准备阶段" tabindex="-1"><a class="header-anchor" href="#类加载过程的连接阶段的准备阶段"><span><strong>类加载过程的连接阶段的准备阶段？</strong></span></a></h3><ol><li>准备阶段为类中定义的静态变量分配内存并设置静态变量初始值，这些变量所使用的内存都是在方法区中（逻辑区域）分配。</li><li>静态变量赋值零值：int 是 0，long 是 0L 等；</li><li>常量直接赋值指定的初始值，而不是零值；</li></ol><h3 id="类加载过程的连接阶段的解析阶段" tabindex="-1"><a class="header-anchor" href="#类加载过程的连接阶段的解析阶段"><span><strong>类加载过程的连接阶段的解析阶段？</strong></span></a></h3><ol><li>解析阶段是 Java 虚拟机将常量池内的符号引用替换为直接引用的过程；</li><li>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。符号引用是指在程序中使用一个符号来代表一个变量或函数，而不是直接使用变量或函数的地址。这个符号在编译时会被解析成对应的地址，然后在程序运行时使用；</li><li>直接引用（Direct Reference）：直接引用是可以直接指向目标指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不相同，如果有直接引用，那引用的目标必定已经在虚拟机的内存中存在；</li><li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符这 7 类符号引用进行；</li></ol><h3 id="类加载过程的连接初始化阶段" tabindex="-1"><a class="header-anchor" href="#类加载过程的连接初始化阶段"><span><strong>类加载过程的连接初始化阶段？</strong></span></a></h3><ol><li>进行准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通过程序编码定制的主观计划去初始化类变量和其他资源；</li><li>初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code> 方法的过程。<code>&lt;clinit&gt;()</code> 方法是由编译器自动收集类中的所有类变量赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义再静态语句块之前的变量，定义再它之后的变量，在前面的静态语句代码块中可以赋值，但是不能访问；</li><li><code>&lt;clinit&gt;()</code>方法与类的构造函数（即在虚拟机视角中的实例构造器<code>&lt;init&gt;()</code>方法）不同，它不需要显示的调用父类构造函数，Java 虚拟机会保证在子类<code>&lt;clinit&gt;()</code>方法执行前，父类的 <code>&lt;clinit&gt;()</code> 方法已经执行完毕。因此在 Java 虚拟机中的第一个被执行的<code>&lt;clinit&gt;()</code>方法的类型肯定是 Object 类型的；</li><li>由于父类的 <code>&lt;clinit&gt;()</code> 方法先执行，也就意味着父类中定义的静态语句代码块要优先于子类的变量赋值操作；</li><li><code>&lt;clinit&gt;()</code>方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成 <code>&lt;clinit&gt;()</code> 方法；</li></ol><h3 id="类和类加载器的关系" tabindex="-1"><a class="header-anchor" href="#类和类加载器的关系"><span><strong>类和类加载器的关系？</strong></span></a></h3><ol><li>对于任意一个类，都必须由加载它的<strong>类加载器</strong>和<strong>这个类本身一起共同确定其在 Java 虚拟机中的唯一性</strong>，每个类加载器，都拥有一个独立的类名称空间；</li><li>比较两个类<strong>是否”相等“</strong>，只有在这两个类是由<strong>同一个类加载器加载的前提下</strong>才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个 Java 虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等；</li><li>这里的”相等“，包括代表类的 Class 对象的 equals() 方法，isAssignableFrom() 方法，isInstance() 方法的返回结果，也包括了使用 instanceof 关键字做的对象所属关系的判定等各种情况；</li></ol><h3 id="jvm-中有哪些类加载器-jdk8" tabindex="-1"><a class="header-anchor" href="#jvm-中有哪些类加载器-jdk8"><span><strong>JVM 中有哪些类加载器？（JDK8）</strong></span></a></h3><img src="'+m+`" alt="img"><ol><li>类加载器（Class Loader）是Java虚拟机（JVM）的一个重要组成部分，它负责将Java类加载到内存中，并生成对应的Class对象。在Java程序运行时，类加载器会动态地加载所需的类，可以实现类的动态加载和卸载，从而实现Java应用程序的灵活性和可扩展性。Java虚拟机中默认提供了三种类加载器： <ol><li><strong>Bootstrap Class Loader</strong>：也称为根类加载器，启动类加载器，它是Java虚拟机的内置类加载器，负责加载Java核心类库，JAVA_HOME/lib 目录，如java.lang包中的类；</li><li><strong>Extension Class Loader</strong>：也称为扩展类加载器，它负责加载Java扩展类库，JAVA_HOME/lib、ext 如javax包中的类；</li><li><strong>Application Class Loader</strong>：也称为应用程序类加载器，它负责加载应用程序的类，即用户自定义的类。类路径（Classpath）;</li><li><strong>自定义类加载器</strong>：继承 ClassLoader 类，实现自己的类加载器。自定义类加载器可以实现自定义的类加载策略，比如从网络或数据库中加载类，从而实现Java应用程序的更高的灵活性和可扩展性。</li></ol></li><li>总之，类加载器是Java虚拟机的一个重要组成部分，它负责将Java类加载到内存中，并生成对应的Class对象。Java虚拟机提供了默认的类加载器，同时也支持自定义类加载器，从而实现Java应用程序的灵活性和可扩展性。</li></ol><h3 id="类加载器的双亲委派流程" tabindex="-1"><a class="header-anchor" href="#类加载器的双亲委派流程"><span><strong>类加载器的双亲委派流程？</strong></span></a></h3><ol><li>当一个类加载器需要加载一个类时，它首先会向上委托给父类加载器去加载，每一层次的类加载器都是如此；</li><li>如果父类加载器无法加载该类，则会向下委托给子类加载器去加载；</li><li>如果子类加载器也无法加载该类，则该类加载器会尝试自己加载该类；</li><li>如果该类加载器还是无法加载该类，则会抛出ClassNotFoundException异常；</li></ol><h3 id="类加载器的双亲委派有什么好处" tabindex="-1"><a class="header-anchor" href="#类加载器的双亲委派有什么好处"><span><strong>类加载器的双亲委派有什么好处？</strong></span></a></h3><ol><li>双亲委派模型的主要作用是保证Java类的唯一性和安全性。由于父类加载器优先加载类，所以<strong>同一个类只会被加载一次</strong>，从而避免了重复加载和内存浪费的问题。</li><li>同时，由于父类加载器是Java核心类库的加载器，所以它们具有更高的安全性，可以<strong>防止恶意类的加载和执行</strong>。</li><li>举个例子：以 Object 类为例，在双亲委派模型下就能保证是启动类加载器去加载它了，这时 Object 类再程序的各种类加载器环境中都能够保证是同一个类。如果没有双亲委派机制，都又各个类加载器自行加载的话，如果用户自己也写了个 Object 类，并放在程序的 classpath 中，那么系统中就会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无法保证；</li></ol><h3 id="破坏双亲委派模型" tabindex="-1"><a class="header-anchor" href="#破坏双亲委派模型"><span><strong>破坏双亲委派模型？</strong></span></a></h3><ol><li><p>破坏双亲委派模型通常是为了实现一些特殊的需求，比如实现Java的热部署功能或者在同一个JVM中加载不同版本的类等。下面介绍两种破坏双亲委派模型的方式：</p><ol><li><strong>自定义类加载器</strong>：通过自定义类加载器，可以实现破坏双亲委派模型。自定义类加载器可以重写loadClass方法，在该方法中实现自己的类加载逻辑，从而实现在同一个JVM中加载不同版本的类。比如，可以在自定义类加载器中先尝试从缓存中加载类，如果缓存中不存在，则从指定的目录中加载类；</li><li><strong>线程上下文类加载器</strong>：线程上下文类加载器是Java 1.2引入的一个新特性，它可以在运行时为线程指定类加载器。通过设置线程上下文类加载器，可以实现在不同的线程中加载不同的类。比如，在Web应用程序中，可以为每个Web应用程序设置一个独立的线程上下文类加载器，从而实现Java的热部署功能；</li></ol></li><li><p>总之，破坏双亲委派模型可以实现一些特殊的需求，但是需要注意破坏双亲委派模型可能会导致类的冲突和安全问题。一般情况下，还是建议遵循双亲委派模型，尽量不要破坏它；</p></li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> java.io.ByteArrayOutputStream</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> java.io.File</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> java.io.FileInputStream</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> java.io.IOException</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 自定义类加载器，打破双亲委派模型</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> CustomWebappClassLoader</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> extends</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ClassLoader</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> classPath</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> CustomWebappClassLoader</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> classPath</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ClassLoader</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> parent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        super</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(parent);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">classPath</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> classPath;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Override</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> loadClass</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> throws</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ClassNotFoundException</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 先尝试自己加载类</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        try</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">            byte</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">classData</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> loadClassData</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(name);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (classData </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">                return</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> defineClass</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(name, classData, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">classData</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Exception</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 自己加载失败，交给父类加载器处理</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> super</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">loadClass</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(name);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> byte</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">[] </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">loadClassData</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> filePath</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> classPath </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> File</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">separatorChar</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">replace</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;.&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">File</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">separatorChar</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;.class&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        try</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">FileInputStream</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> fis</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> FileInputStream</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(filePath);</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">             ByteArrayOutputStream</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> bos</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ByteArrayOutputStream</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()) {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">            byte</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">buffer</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> byte</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1024</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> bytesRead</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            while</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ((bytesRead </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> fis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">read</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(buffer)) </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">                bos</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">write</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(buffer, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, bytesRead);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> bos</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toByteArray</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">IOException</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="运行时栈帧结构" tabindex="-1"><a class="header-anchor" href="#运行时栈帧结构"><span><strong>运行时栈帧结构？</strong></span></a></h3><ol><li>栈帧中存储了方法的局部变量表、操作数栈、动态连接和方法返回地址和一些额外的附加信息；</li><li>在编译 Java 程序源码的时候，栈帧中需要多大的局部变量表，需要多深的操作数栈就已经被分析计算出来，并且写入到方法表的 Code 属性之中。也就是说一个栈帧需要分配多少内存，并不会受到程序运行期变量数据的影响，而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式；</li><li>对于执行引擎来讲，只有位于栈顶的方法才才是运行的，只有位于栈顶的栈帧才是生效的，其被称为“当前栈帧”，与这个栈帧所关联的方法被称为“当前方法”。执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作；</li><li>依次分析： <ol><li>局部变量表：它的作用是在方法执行时，存储方法中定义的局部变量，包括方法参数和方法内部定义的变量。局部变量表是一个数组，数组元素的类型和数量由编译器在编译期间确定。在方法执行过程中，局部变量表的作用是存储方法中使用的变量，在方法执行结束后，这些变量的值将被销毁。局部变量表的大小是在编译期间确定的，它的大小取决于方法中定义的局部变量的数量和类型，以及方法参数的数量和类型。Java虚拟机规范要求，局部变量表中的变量必须在使用之前进行初始化。如果某个变量没有被初始化，Java虚拟机将抛出一个异常。当一个方法被调用时，Java 虚拟机会使用局部变量表来完成参数值到参数变量列表的传递过程，即实参到形参的传递。如果执行的方法是实例方法，那么局部变量表的第 0 位个索引的变量槽的默认是用于传递方法所属对象实例的引用，就是 this 关键字访问。其余参数则按照参数表顺序排列，占用从 1 开始的位置，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的变量槽；</li><li>操作数栈：在方法执行时，存储方法中需要进行计算的操作数和中间结果。操作数栈是一个后进先出（LIFO）的栈结构，可以存储各种类型的数据，包括整数、浮点数、对象引用等。例如，在执行一条加法指令时，需要从操作数栈中弹出两个数值，执行加法运算后再将结果压入操作数栈中。当方法执行结束后，操作数栈中的数据将被销毁。Java虚拟机规范要求，操作数栈中的数据必须具有明确的类型，以便在进行计算时进行类型检查。如果操作数栈中的数据类型不匹配，Java虚拟机将抛出一个异常。操作数栈的大小是有限制的，如果操作数栈中的元素数量超过了其大小限制，Java虚拟机将抛出一个StackOverflowError异常。因此，在编写Java程序时，需要注意操作数栈的大小限制，避免出现这种异常；</li><li>动态连接：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程的动态连接。Class 文件的常量池中存有大量符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候会被转化为直接引用（静态解析）。另外一部分在每一次运行期间都转化为直接引用，这部分称为动态连接；</li><li>方法返回地址：当一个方法退出后会有两种方式退出这个方法。第一种是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者，方法是否有返回值以及返回值的类型将更具遇到何种方法返回指令来决定，这种退出方式称为“正常调用完成”。另一种是在方法的执行过程中遇到了异常，并且这个异常没有在方法中得到妥善处理。这种退出方法的方式称为“异常调用完成”。一个方法使用异常完成出口的方式退出，是不会给它的上层调用者提供任何返回值的。无论采用什么退出方式，在方法退出之后，都必须返回到最初方法被调用是的位置，程序才能继续执行。一般来说，方法正常退出时，主调方法的 PC 计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息；</li><li>附加信息：略；</li></ol></li></ol><h3 id="方法调用" tabindex="-1"><a class="header-anchor" href="#方法调用"><span><strong>方法调用？</strong></span></a></h3><p>一切方法调用在 Class 文件里面存储的都只是符号引用，而不是方法在实际运行时的内存布局中的内存地址（直接引用）。这个特性给 Java 带来了更强大的动态扩展能力，但也使得 Java 方法调用的过程变得复杂，某些调用需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用；</p><p><strong>解析</strong>：所有方法调用的目标方法在 Class 文件里面都是一个常量池的符号引用，在类加载阶段，会将其中的一部分符号引用转化为直接引用，这种解析能够成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在程序代码写好、编译器进行编译的那一刻就已经确定下来了。这类方法的调用被称为解析。</p><p>针对“编译器可知，运行期不可变”这个方法的要求，主要有静态方法和私有方法两大类。前者与类型直接关联，后者在外部不可被访问。这两种都适合在类加载阶段进行解析，将符号引用解析为该方法的直接引用。</p><ol><li>静态方法；</li><li>私有方法；</li><li>实例构造器；</li><li>父类方法；</li><li>被 final 修饰的方法；</li></ol><p><strong>静态分派</strong>（典型应用：方法重载）：假设 Human 是父类，有两个子类 Man 和 Woman。Human 称为变量的“静态类型”，后面的 Man 称为变量“实际类型”（或者运行时类型）。静态类型和实际类型在程序中都可能发生变化，区别是静态类型的变化仅仅再使用时发生，变量本身的静态类型不会改变，并且最终的静态类型是在编译器可知的；而实际类型变化的结果在运行期才可以确定，编译器在编译程序时候并不知道一个对象的实际类型是什么；</p><p>虚拟机（准确的说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判定依据的。由于静态类型在编译器可知，所以在编译阶段，Javac 编译器就根据参数的静态类型决定了会使用那个重载版本；</p><p><strong>动态分派</strong>（典型应用：方法重写）</p><h3 id="tomcat-为什么要自定义类加载器" tabindex="-1"><a class="header-anchor" href="#tomcat-为什么要自定义类加载器"><span><strong>Tomcat 为什么要自定义类加载器？</strong></span></a></h3><p>一个功能健全的 Web 服务器需要解决下面问题</p><ol><li>部署在同一个服务器上的两个 Web 应用程序所使用的 Java 类库可以实现相互隔离；</li><li>部署在同一个服务器上的两个 Web 应用程序所使用的 Java 类库可以互相共享；</li><li>基于安全考虑，一般来说，服务器所使用的类库应该与应用程序的类库互相独立；</li></ol><p>因为存在上面的问题，在部署Web 应用时。单独的一个 Classpath 就不能满足需求了，所以各种 Web 服务器都不约而同的提供了好几个不同含义的 ClassPath 路径供用户存放第三方类库，这些路径一般会以“lib”或者“classes”命名。被放置到不同路径的类库，具备不同的访问范围和服务对象，通常每一个目录都会有一个相应的自定义类加载器去加载放置在里面的 Java 类库。</p>`,39))])}const M=d(b,[["render",C]]),F=JSON.parse('{"path":"/interviewQA/JVM%E9%97%AE%E9%A2%98.html","title":"JVM相关问题","lang":"en-US","frontmatter":{"title":"JVM相关问题","description":"JDK8 垃圾回收器官方文档 https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ JDK11 垃圾回收器官方文档 https://docs.oracle.com/en/java/javase/11/gctuning/index.html JVM 内存区域的一些概念 JV...","head":[["meta",{"property":"og:url","content":"https://blog.guosgbin.cn/interviewQA/JVM%E9%97%AE%E9%A2%98.html"}],["meta",{"property":"og:title","content":"JVM相关问题"}],["meta",{"property":"og:description","content":"JDK8 垃圾回收器官方文档 https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ JDK11 垃圾回收器官方文档 https://docs.oracle.com/en/java/javase/11/gctuning/index.html JVM 内存区域的一些概念 JV..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-04-21T14:37:13.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-21T14:37:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JVM相关问题\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-21T14:37:13.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"超威蓝猫 Dylan Kwok\\",\\"url\\":\\"\\",\\"email\\":\\"guosgbin@163.com\\"}]}"]]},"git":{"createdTime":1743664049000,"updatedTime":1745246233000,"contributors":[{"name":"Dylan Kwok","username":"","email":"guosgbin@163.com","commits":3}]},"readingTime":{"minutes":87.64,"words":26292},"filePathRelative":"interviewQA/JVM问题.md","localizedDate":"April 3, 2025","autoDesc":true}');export{M as comp,F as data};
